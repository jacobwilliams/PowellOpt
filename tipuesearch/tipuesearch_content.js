var tipuesearch = {"pages":[{"title":" PowellOpt ","text":"PowellOpt Optimization algorithms by M.J.D. Powell About This is a collection of derivative-free optimization algorithms by M.J.D. Powell.\nThe package contains: LINCOA (LINearly Constrained Optimization Algorithm) BOBYQA (Bound Optimization BY Quadratic Approximation) NEWUOA (NEW Unconstrained Optimization Algorithm) UOBYQA (Unconstrained Optimization BY Quadratic Approximation) COBYLA (Constrained Optimization BY Linear Approximations) Building The Fortran Package Manager (fpm) is a great package manager and build system for Fortran.\nYou can build using provided fpm.toml : fpm build To use PowellOpt within your fpm project, add the following to your fpm.toml file: [dependencies] PowellOpt = { git = \"https://github.com/jacobwilliams/PowellOpt.git\" } Documentation The API documentation for the current master branch can be found here .  This is generated by processing the source files with FORD . License The original routines were written in FORTRAN 77. They have been refactored into\nmodern Fortran for this package. The original sourcecode was written by Powell and\nreleased without charges or restrictions (see below). The modifications are released\nunder a BSD-style license . See also Original sourcecode PRIMA Modernized reference implementations for Powell's derivative-free optimization methods. Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"func – PowellOpt","text":"interface private  subroutine func(n, x, f) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (*) real(kind=wp) :: f Description calfun interface","tags":"","loc":"interface/func.html"},{"title":"func – PowellOpt","text":"interface private  subroutine func(n, m, x, f, con) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(in), dimension(*) :: x real(kind=wp), intent(out) :: f real(kind=wp), intent(out), dimension(*) :: con Description calcfc interface","tags":"","loc":"interface/func~2.html"},{"title":"func – PowellOpt","text":"interface private  subroutine func(n, x, f) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (*) real(kind=wp) :: f Description calfun interface","tags":"","loc":"interface/func~3.html"},{"title":"func – PowellOpt","text":"interface private  subroutine func(n, x, f) Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (*) real(kind=wp) :: f Description calfun interface","tags":"","loc":"interface/func~4.html"},{"title":"func – PowellOpt","text":"interface private  subroutine func(n, x, f) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out) :: f Description calfun interface","tags":"","loc":"interface/func~5.html"},{"title":"newuoa – PowellOpt","text":"public  subroutine newuoa(n, npt, x, rhobeg, rhoend, iprint, maxfun, calfun) This subroutine seeks the least value of a function of many variables,\nby a trust region method that forms quadratic models by interpolation.\nThere can be some freedom in the interpolation conditions, which is\ntaken up by minimizing the Frobenius norm of the change to the second\nderivative of the quadratic model, beginning with a zero matrix. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the number of variables. must be at least 2. integer, intent(in) :: npt The number of interpolation conditions.\nIts value must be in the interval [N+2,(N+1)(N+2)/2] . real(kind=wp), intent(inout), dimension(*) :: x Initial values of the variables must be set in X(1),X(2),...,X(N). They\nwill be changed to the values that give the least calculated F. real(kind=wp), intent(in) :: rhobeg RHOBEG and RHOEND must be set to the initial and final values of a trust\nregion radius, so both must be positive with RHOEND<=RHOBEG. Typically\nRHOBEG should be about one tenth of the greatest expected change to a\nvariable, and RHOEND should indicate the accuracy that is required in\nthe final values of the variables. real(kind=wp), intent(in) :: rhoend RHOBEG and RHOEND must be set to the initial and final values of a trust\nregion radius, so both must be positive with RHOEND<=RHOBEG. Typically\nRHOBEG should be about one tenth of the greatest expected change to a\nvariable, and RHOEND should indicate the accuracy that is required in\nthe final values of the variables. integer, intent(in) :: iprint The value of IPRINT should be set to 0, 1, 2 or 3, which controls the\namount of printing. Specifically, there is no output if IPRINT=0 and\nthere is output only at the return if IPRINT=1. Otherwise, each new\nvalue of RHO is printed, with the best vector of variables so far and\nthe corresponding value of the objective function. Further, each new\nvalue of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun an upper bound on the number of calls of CALFUN. procedure( func ) :: calfun It must set F to the value of the objective function \nfor the variables X(1),X(2),...,X(N) . Calls proc~~newuoa~~CallsGraph proc~newuoa newuoa proc~newuob newuob proc~newuoa->proc~newuob proc~bigden bigden proc~newuob->proc~bigden proc~biglag biglag proc~newuob->proc~biglag proc~trsapp trsapp proc~newuob->proc~trsapp proc~update update proc~newuob->proc~update den den proc~bigden->den denex denex proc~bigden->denex par par proc~bigden->par Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~newuoa~~CalledByGraph proc~newuoa newuoa proc~newuoa_test newuoa_test proc~newuoa_test->proc~newuoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine newuoa ( n , npt , x , rhobeg , rhoend , iprint , maxfun , calfun ) implicit none integer , intent ( in ) :: n !! the number of variables. must be at least 2. integer , intent ( in ) :: npt !! The number of interpolation conditions. !! Its value must be in the interval `[N+2,(N+1)(N+2)/2]`. real ( wp ), dimension ( * ), intent ( inout ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). They !! will be changed to the values that give the least calculated F. real ( wp ), intent ( in ) :: rhobeg !! RHOBEG and RHOEND must be set to the initial and final values of a trust !! region radius, so both must be positive with RHOEND<=RHOBEG. Typically !! RHOBEG should be about one tenth of the greatest expected change to a !! variable, and RHOEND should indicate the accuracy that is required in !! the final values of the variables. real ( wp ), intent ( in ) :: rhoend !! RHOBEG and RHOEND must be set to the initial and final values of a trust !! region radius, so both must be positive with RHOEND<=RHOBEG. Typically !! RHOBEG should be about one tenth of the greatest expected change to a !! variable, and RHOEND should indicate the accuracy that is required in !! the final values of the variables. integer , intent ( in ) :: iprint !! The value of IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, each new !! value of RHO is printed, with the best vector of variables so far and !! the corresponding value of the objective function. Further, each new !! value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! an upper bound on the number of calls of CALFUN. procedure ( func ) :: calfun !! It must set F to the value of the objective function !! for the variables `X(1),X(2),...,X(N)`. real ( wp ), dimension (:), allocatable :: w integer :: np , nptm , ndim , ixb , ixo , ixn , ixp , ifv , igq , ihq , ipq , ibmat , izmat , id , ivl , iw ! Partition the working space array, so that different parts of it can be ! treated separately by the subroutine that performs the main calculation. np = n + 1 nptm = npt - np if ( npt < n + 2 . or . npt > (( n + 2 ) * np ) / 2 ) then write ( * , * ) 'Return from NEWUOA because NPT is not in the required interval' return end if ! The array W will be used for working space allocate ( w (( NPT + 13 ) * ( NPT + N ) + 3 * N * ( N + 3 ) / 2 )) ndim = npt + n ixb = 1 ixo = ixb + n ixn = ixo + n ixp = ixn + n ifv = ixp + n * npt igq = ifv + npt ihq = igq + n ipq = ihq + ( n * np ) / 2 ibmat = ipq + npt izmat = ibmat + ndim * n id = izmat + npt * nptm ivl = id + n iw = ivl + ndim ! The above settings provide a partition of W for subroutine NEWUOB. ! The partition requires the first NPT*(NPT+N)+5*N*(N+3)/2 elements of ! W plus the space that is needed by the last array of NEWUOB. call newuob ( n , npt , x , rhobeg , rhoend , iprint , maxfun , w ( ixb ), w ( ixo ), w ( ixn ), & w ( ixp ), w ( ifv ), w ( igq ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , & w ( id ), w ( ivl ), w ( iw ), calfun ) deallocate ( w ) end subroutine newuoa","tags":"","loc":"proc/newuoa.html"},{"title":"newuob – PowellOpt","text":"private  subroutine newuob(n, npt, x, rhobeg, rhoend, iprint, maxfun, xbase, xopt, xnew, xpt, fval, gq, hq, pq, bmat, zmat, ndim, d, vlag, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: x real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: xbase real :: xopt real :: xnew real :: xpt real :: fval real :: gq real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: d real :: vlag real :: w procedure( func ) :: calfun Calls proc~~newuob~~CallsGraph proc~newuob newuob proc~bigden bigden proc~newuob->proc~bigden proc~biglag biglag proc~newuob->proc~biglag proc~trsapp trsapp proc~newuob->proc~trsapp proc~update update proc~newuob->proc~update den den proc~bigden->den denex denex proc~bigden->denex par par proc~bigden->par Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~newuob~~CalledByGraph proc~newuob newuob proc~newuoa newuoa proc~newuoa->proc~newuob proc~newuoa_test newuoa_test proc~newuoa_test->proc~newuoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine newuob ( n , npt , x , rhobeg , rhoend , iprint , maxfun , xbase , xopt , xnew , xpt , & fval , gq , hq , pq , bmat , zmat , ndim , d , vlag , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension x ( * ), xbase ( * ), xopt ( * ), xnew ( * ), xpt ( npt , * ), fval ( * ), gq ( * ), hq & ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), d ( * ), vlag ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, X, RHOBEG, RHOEND, IPRINT and MAXFUN are identical !       to the corresponding arguments in SUBROUTINE NEWUOA. !     XBASE will hold a shift of origin that should reduce the contributions !       from rounding errors to values of the model and Lagrange functions. !     XOPT will be set to the displacement from XBASE of the vector of !       variables that provides the least calculated F so far. !     XNEW will be set to the displacement from XBASE of the vector of !       variables for the current calculation of F. !     XPT will contain the interpolation point coordinates relative to XBASE. !     FVAL will hold the values of F at the interpolation points. !     GQ will hold the gradient of the quadratic model at XBASE. !     HQ will hold the explicit second derivatives of the quadratic model. !     PQ will contain the parameters of the implicit second derivatives of !       the quadratic model. !     BMAT will hold the last N columns of H. !     ZMAT will hold the factorization of the leading NPT by NPT submatrix of !       H, this factorization being ZMAT times Diag(DZ) times ZMAT&#94;T, where !       the elements of DZ are plus or minus one, as specified by IDZ. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     D is reserved for trial steps from XOPT. !     VLAG will contain the values of the Lagrange functions at a new point X. !       They are part of a product that requires VLAG to be of length NDIM. !     The array W will be used for working space. Its length must be at least !       10*NDIM = 10*(NPT+N). ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp tenth = 0.1_wp zero = 0.0_wp np = n + 1 nh = ( n * np ) / 2 nptm = npt - np nftest = max ( maxfun , 1 ) ! !     Set the initial elements of XPT, BMAT, HQ, PQ and ZMAT to zero. ! do j = 1 , n xbase ( j ) = x ( j ) do k = 1 , npt xpt ( k , j ) = zero end do do i = 1 , ndim bmat ( i , j ) = zero end do end do do ih = 1 , nh hq ( ih ) = zero end do do k = 1 , npt pq ( k ) = zero do j = 1 , nptm zmat ( k , j ) = zero end do end do ! !     Begin the initialization procedure. NF becomes one more than the number !     of function values so far. The coordinates of the displacement of the !     next initial interpolation point from XBASE are set in XPT(NF,.). ! rhosq = rhobeg * rhobeg recip = one / rhosq reciq = sqrt ( half ) / rhosq nf = 0 50 nfm = nf nfmm = nf - n nf = nf + 1 if ( nfm <= 2 * n ) then if ( nfm >= 1 . and . nfm <= n ) then xpt ( nf , nfm ) = rhobeg else if ( nfm > n ) then xpt ( nf , nfmm ) = - rhobeg end if else itemp = ( nfmm - 1 ) / n jpt = nfm - itemp * n - n ipt = jpt + itemp if ( ipt > n ) then itemp = jpt jpt = ipt - n ipt = itemp end if xipt = rhobeg if ( fval ( ipt + np ) < fval ( ipt + 1 )) xipt = - xipt xjpt = rhobeg if ( fval ( jpt + np ) < fval ( jpt + 1 )) xjpt = - xjpt xpt ( nf , ipt ) = xipt xpt ( nf , jpt ) = xjpt end if ! !     Calculate the next value of F, label 70 being reached immediately !     after this calculation. The least function value so far and its index !     are required. ! do j = 1 , n x ( j ) = xpt ( nf , j ) + xbase ( j ) end do go to 310 70 fval ( nf ) = f if ( nf == 1 ) then fbeg = f fopt = f kopt = 1 else if ( f < fopt ) then fopt = f kopt = nf end if ! !     Set the nonzero initial elements of BMAT and the quadratic model in !     the cases when NF is at most 2*N+1. ! if ( nfm <= 2 * n ) then if ( nfm >= 1 . and . nfm <= n ) then gq ( nfm ) = ( f - fbeg ) / rhobeg if ( npt < nf + n ) then bmat ( 1 , nfm ) = - one / rhobeg bmat ( nf , nfm ) = one / rhobeg bmat ( npt + nfm , nfm ) = - half * rhosq end if else if ( nfm > n ) then bmat ( nf - n , nfmm ) = half / rhobeg bmat ( nf , nfmm ) = - half / rhobeg zmat ( 1 , nfmm ) = - reciq - reciq zmat ( nf - n , nfmm ) = reciq zmat ( nf , nfmm ) = reciq ih = ( nfmm * ( nfmm + 1 )) / 2 temp = ( fbeg - f ) / rhobeg hq ( ih ) = ( gq ( nfmm ) - temp ) / rhobeg gq ( nfmm ) = half * ( gq ( nfmm ) + temp ) end if ! !     Set the off-diagonal second derivatives of the Lagrange functions and !     the initial quadratic model. ! else ih = ( ipt * ( ipt - 1 )) / 2 + jpt if ( xipt < zero ) ipt = ipt + n if ( xjpt < zero ) jpt = jpt + n zmat ( 1 , nfmm ) = recip zmat ( nf , nfmm ) = recip zmat ( ipt + 1 , nfmm ) = - recip zmat ( jpt + 1 , nfmm ) = - recip hq ( ih ) = ( fbeg - fval ( ipt + 1 ) - fval ( jpt + 1 ) + f ) / ( xipt * xjpt ) end if if ( nf < npt ) go to 50 ! !     Begin the iterative procedure, because the initial model is complete. ! rho = rhobeg delta = rho idz = 1 diffa = zero diffb = zero itest = 0 xoptsq = zero do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do 90 nfsav = nf ! !     Generate the next trust region step and test its length. Set KNEW !     to -1 if the purpose of the next F will be to improve the model. ! 100 knew = 0 call trsapp ( n , npt , xopt , xpt , gq , hq , pq , delta , d , w , w ( np ), w ( np + n ), & w ( np + 2 * n ), crvmin ) dsq = zero do i = 1 , n dsq = dsq + d ( i ) ** 2 end do dnorm = min ( delta , sqrt ( dsq )) if ( dnorm < half * rho ) then knew = - 1 delta = tenth * delta ratio = - 1.0_wp if ( delta <= 1.5_wp * rho ) delta = rho if ( nf <= nfsav + 2 ) go to 460 temp = 0.125_wp * crvmin * rho * rho if ( temp <= max ( diffa , diffb , diffc )) go to 460 go to 490 end if ! !     Shift XBASE if XOPT may be too far from XBASE. First make the changes !     to BMAT that do not depend on ZMAT. ! 120 if ( dsq <= 1.0e-3_wp * xoptsq ) then tempq = 0.25_wp * xoptsq do k = 1 , npt sum = zero do i = 1 , n sum = sum + xpt ( k , i ) * xopt ( i ) end do temp = pq ( k ) * sum sum = sum - half * xoptsq w ( npt + k ) = sum do i = 1 , n gq ( i ) = gq ( i ) + temp * xpt ( k , i ) xpt ( k , i ) = xpt ( k , i ) - half * xopt ( i ) vlag ( i ) = bmat ( k , i ) w ( i ) = sum * xpt ( k , i ) + tempq * xopt ( i ) ip = npt + i do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + vlag ( i ) * w ( j ) + w ( i ) * vlag ( j ) end do end do end do ! !     Then the revisions of BMAT that depend on ZMAT are calculated. ! do k = 1 , nptm sumz = zero do i = 1 , npt sumz = sumz + zmat ( i , k ) w ( i ) = w ( npt + i ) * zmat ( i , k ) end do do j = 1 , n sum = tempq * sumz * xopt ( j ) do i = 1 , npt sum = sum + w ( i ) * xpt ( i , j ) end do vlag ( j ) = sum if ( k < idz ) sum = - sum do i = 1 , npt bmat ( i , j ) = bmat ( i , j ) + sum * zmat ( i , k ) end do end do do i = 1 , n ip = i + npt temp = vlag ( i ) if ( k < idz ) temp = - temp do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + temp * vlag ( j ) end do end do end do ! !     The following instructions complete the shift of XBASE, including !     the changes to the parameters of the quadratic model. ! ih = 0 do j = 1 , n w ( j ) = zero do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) xpt ( k , j ) = xpt ( k , j ) - half * xopt ( j ) end do do i = 1 , j ih = ih + 1 if ( i < j ) gq ( j ) = gq ( j ) + hq ( ih ) * xopt ( i ) gq ( i ) = gq ( i ) + hq ( ih ) * xopt ( j ) hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + xopt ( i ) * w ( j ) bmat ( npt + i , j ) = bmat ( npt + j , i ) end do end do do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) xopt ( j ) = zero end do xoptsq = zero end if ! !     Pick the model step if KNEW is positive. A different choice of D !     may be made later, if the choice of D by BIGLAG causes substantial !     cancellation in DENOM. ! if ( knew > 0 ) then call biglag ( n , npt , xopt , xpt , bmat , zmat , idz , ndim , knew , dstep , d , alpha , & vlag , vlag ( npt + 1 ), w , w ( np ), w ( np + n )) end if ! !     Calculate VLAG and BETA for the current choice of D. The first NPT !     components of W_check will be held in W. ! do k = 1 , npt suma = zero sumb = zero sum = zero do j = 1 , n suma = suma + xpt ( k , j ) * d ( j ) sumb = sumb + xpt ( k , j ) * xopt ( j ) sum = sum + bmat ( k , j ) * d ( j ) end do w ( k ) = suma * ( half * suma + sumb ) vlag ( k ) = sum end do beta = zero do k = 1 , nptm sum = zero do i = 1 , npt sum = sum + zmat ( i , k ) * w ( i ) end do if ( k < idz ) then beta = beta + sum * sum sum = - sum else beta = beta - sum * sum end if do i = 1 , npt vlag ( i ) = vlag ( i ) + sum * zmat ( i , k ) end do end do bsum = zero dx = zero do j = 1 , n sum = zero do i = 1 , npt sum = sum + w ( i ) * bmat ( i , j ) end do bsum = bsum + sum * d ( j ) jp = npt + j do k = 1 , n sum = sum + bmat ( jp , k ) * d ( k ) end do vlag ( jp ) = sum bsum = bsum + sum * d ( j ) dx = dx + d ( j ) * xopt ( j ) end do beta = dx * dx + dsq * ( xoptsq + dx + dx + half * dsq ) + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     If KNEW is positive and if the cancellation in DENOM is unacceptable, !     then BIGDEN calculates an alternative model step, XNEW being used for !     working space. ! if ( knew > 0 ) then temp = one + alpha * beta / vlag ( knew ) ** 2 if ( abs ( temp ) <= 0.8_wp ) then call bigden ( n , npt , xopt , xpt , bmat , zmat , idz , ndim , kopt , knew , d , w , & vlag , beta , xnew , w ( ndim + 1 ), w ( 6 * ndim + 1 )) end if end if ! !     Calculate the next value of the objective function. ! 290 do i = 1 , n xnew ( i ) = xopt ( i ) + d ( i ) x ( i ) = xbase ( i ) + xnew ( i ) end do nf = nf + 1 310 if ( nf > nftest ) then nf = nf - 1 if ( iprint > 0 ) print 320 320 format ( / 4 x , 'Return from NEWUOA because CALFUN has been' ,& ' called MAXFUN times.' ) go to 530 end if call calfun ( n , x , f ) if ( iprint == 3 ) then print 330 , nf , f , ( x ( i ), i = 1 , n ) 330 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( nf <= npt ) go to 70 if ( knew ==- 1 ) go to 530 ! !     Use the quadratic model to predict the change in F due to the step D, !     and set DIFF to the error of this prediction. ! vquad = zero ih = 0 do j = 1 , n vquad = vquad + d ( j ) * gq ( j ) do i = 1 , j ih = ih + 1 temp = d ( i ) * xnew ( j ) + d ( j ) * xopt ( i ) if ( i == j ) temp = half * temp vquad = vquad + temp * hq ( ih ) end do end do do k = 1 , npt vquad = vquad + pq ( k ) * w ( k ) end do diff = f - fopt - vquad diffc = diffb diffb = diffa diffa = abs ( diff ) if ( dnorm > rho ) nfsav = nf ! !     Update FOPT and XOPT if the new F is the least value of the objective !     function so far. The branch when KNEW is positive occurs if D is not !     a trust region step. ! fsave = fopt if ( f < fopt ) then fopt = f xoptsq = zero do i = 1 , n xopt ( i ) = xnew ( i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do end if ksave = knew if ( knew > 0 ) go to 410 ! !     Pick the next value of DELTA after a trust region step. ! if ( vquad >= zero ) then if ( iprint > 0 ) print 370 370 format ( / 4 x , 'Return from NEWUOA because a trust' ,& ' region step has failed to reduce Q.' ) go to 530 end if ratio = ( f - fsave ) / vquad if ( ratio <= tenth ) then delta = half * dnorm else if ( ratio <= 0.7_wp ) then delta = max ( half * delta , dnorm ) else delta = max ( half * delta , dnorm + dnorm ) end if if ( delta <= 1.5_wp * rho ) delta = rho ! !     Set KNEW to the index of the next interpolation point to be deleted. ! rhosq = max ( tenth * delta , rho ) ** 2 ktemp = 0 detrat = zero if ( f >= fsave ) then ktemp = kopt detrat = one end if do k = 1 , npt hdiag = zero do j = 1 , nptm temp = one if ( j < idz ) temp = - one hdiag = hdiag + temp * zmat ( k , j ) ** 2 end do temp = abs ( beta * hdiag + vlag ( k ) ** 2 ) distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( distsq > rhosq ) temp = temp * ( distsq / rhosq ) ** 3 if ( temp > detrat . and . k /= ktemp ) then detrat = temp knew = k end if end do if ( knew == 0 ) go to 460 ! !     Update BMAT, ZMAT and IDZ, so that the KNEW-th interpolation point !     can be moved. Begin the updating of the quadratic model, starting !     with the explicit second derivative term. ! 410 call update ( n , npt , bmat , zmat , idz , ndim , vlag , beta , knew , w ) fval ( knew ) = f ih = 0 do i = 1 , n temp = pq ( knew ) * xpt ( knew , i ) do j = 1 , i ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * xpt ( knew , j ) end do end do pq ( knew ) = zero ! !     Update the other second derivative parameters, and then the gradient !     vector of the model. Also include the new interpolation point. ! do j = 1 , nptm temp = diff * zmat ( knew , j ) if ( j < idz ) temp = - temp do k = 1 , npt pq ( k ) = pq ( k ) + temp * zmat ( k , j ) end do end do gqsq = zero do i = 1 , n gq ( i ) = gq ( i ) + diff * bmat ( knew , i ) gqsq = gqsq + gq ( i ) ** 2 xpt ( knew , i ) = xnew ( i ) end do ! !     If a trust region step makes a small change to the objective function, !     then calculate the gradient of the least Frobenius norm interpolant at !     XBASE, and store it in W, using VLAG for a vector of right hand sides. ! if ( ksave == 0 . and . delta == rho ) then if ( abs ( ratio ) > 1.0e-2_wp ) then itest = 0 else do k = 1 , npt vlag ( k ) = fval ( k ) - fval ( kopt ) end do gisq = zero do i = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , i ) * vlag ( k ) end do gisq = gisq + sum * sum w ( i ) = sum end do ! !     Test whether to replace the new quadratic model by the least Frobenius !     norm interpolant, making the replacement if the test is satisfied. ! itest = itest + 1 if ( gqsq < 10 0.0_wp * gisq ) itest = 0 if ( itest >= 3 ) then do i = 1 , n gq ( i ) = w ( i ) end do do ih = 1 , nh hq ( ih ) = zero end do do j = 1 , nptm w ( j ) = zero do k = 1 , npt w ( j ) = w ( j ) + vlag ( k ) * zmat ( k , j ) end do if ( j < idz ) w ( j ) = - w ( j ) end do do k = 1 , npt pq ( k ) = zero do j = 1 , nptm pq ( k ) = pq ( k ) + zmat ( k , j ) * w ( j ) end do end do itest = 0 end if end if end if if ( f < fsave ) kopt = knew ! !     If a trust region step has provided a sufficient decrease in F, then !     branch for another trust region calculation. The case KSAVE>0 occurs !     when the new function value was calculated by a model step. ! if ( f <= fsave + tenth * vquad ) go to 100 if ( ksave > 0 ) go to 100 ! !     Alternatively, find out if the interpolation points are close enough !     to the best point so far. ! knew = 0 460 distsq = 4.0_wp * delta * delta do k = 1 , npt sum = zero do j = 1 , n sum = sum + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( sum > distsq ) then knew = k distsq = sum end if end do ! !     If KNEW is positive, then set DSTEP, and branch back for the next !     iteration, which will generate a \"model step\". ! if ( knew > 0 ) then dstep = max ( min ( tenth * sqrt ( distsq ), half * delta ), rho ) dsq = dstep * dstep go to 120 end if if ( ratio > zero ) go to 100 if ( max ( delta , dnorm ) > rho ) go to 100 ! !     The calculations with the current value of RHO are complete. Pick the !     next values of RHO and DELTA. ! 490 if ( rho > rhoend ) then delta = half * rho ratio = rho / rhoend if ( ratio <= 1 6.0_wp ) then rho = rhoend else if ( ratio <= 25 0.0_wp ) then rho = sqrt ( ratio ) * rhoend else rho = tenth * rho end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) print 500 500 format ( 5 x ) print 510 , rho , nf 510 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 520 , fopt , ( xbase ( i ) + xopt ( i ), i = 1 , n ) 520 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if go to 90 end if ! !     Return from the calculation, after another Newton-Raphson step, if !     it is too short to have been tried before. ! if ( knew ==- 1 ) go to 290 530 if ( fopt <= f ) then do i = 1 , n x ( i ) = xbase ( i ) + xopt ( i ) end do f = fopt end if if ( iprint >= 1 ) then print 550 , nf 550 format ( / 4 x , 'At the return from NEWUOA' , 5 x ,& 'Number of function values =' , i6 ) print 520 , f , ( x ( i ), i = 1 , n ) end if end subroutine newuob","tags":"","loc":"proc/newuob.html"},{"title":"bigden – PowellOpt","text":"private  subroutine bigden(n, npt, xopt, xpt, bmat, zmat, idz, ndim, kopt, knew, d, w, vlag, beta, s, wvec, prod) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xopt real :: xpt real :: bmat real :: zmat integer :: idz integer :: ndim integer :: kopt integer :: knew real :: d real :: w real :: vlag real :: beta real :: s real :: wvec real :: prod Calls proc~~bigden~~CallsGraph proc~bigden bigden den den proc~bigden->den denex denex proc~bigden->denex par par proc~bigden->par Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~bigden~~CalledByGraph proc~bigden bigden proc~newuob newuob proc~newuob->proc~bigden proc~newuoa newuoa proc~newuoa->proc~newuob proc~newuoa_test newuoa_test proc~newuoa_test->proc~newuoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bigden ( n , npt , xopt , xpt , bmat , zmat , idz , ndim , kopt , knew , d , w , vlag , & beta , s , wvec , prod ) implicit real ( wp ) ( a - h , o - z ) dimension xopt ( * ), xpt ( npt , * ), bmat ( ndim , * ), zmat ( npt , * ), d ( * ), w ( * ), vlag & ( * ), s ( * ), wvec ( ndim , * ), prod ( ndim , * ) dimension den ( 9 ), denex ( 9 ), par ( 9 ) ! !     N is the number of variables. !     NPT is the number of interpolation equations. !     XOPT is the best interpolation point so far. !     XPT contains the coordinates of the current interpolation points. !     BMAT provides the last N columns of H. !     ZMAT and IDZ give a factorization of the first NPT by NPT submatrix of H. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     KOPT is the index of the optimal interpolation point. !     KNEW is the index of the interpolation point that is going to be moved. !     D will be set to the step from XOPT to the new point, and on entry it !       should be the D that was calculated by the last call of BIGLAG. The !       length of the initial D provides a trust region bound on the final D. !     W will be set to Wcheck for the final choice of D. !     VLAG will be set to Theta*Wcheck+e_b for the final choice of D. !     BETA will be set to the value that will occur in the updating formula !       when the KNEW-th interpolation point is moved to its new position. !     S, WVEC, PROD and the private arrays DEN, DENEX and PAR will be used !       for working space. ! !     D is calculated in a way that should provide a denominator with a large !     modulus in the updating formula when the KNEW-th interpolation point is !     shifted to the new position XOPT+D. ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp quart = 0.25_wp two = 2.0_wp zero = 0.0_wp twopi = 8.0_wp * atan ( one ) nptm = npt - n - 1 ! !     Store the first NPT elements of the KNEW-th column of H in W(N+1) !     to W(N+NPT). ! do k = 1 , npt w ( n + k ) = zero end do do j = 1 , nptm temp = zmat ( knew , j ) if ( j < idz ) temp = - temp do k = 1 , npt w ( n + k ) = w ( n + k ) + temp * zmat ( k , j ) end do end do alpha = w ( n + knew ) ! !     The initial search direction D is taken from the last call of BIGLAG, !     and the initial S is set below, usually to the direction from X_OPT !     to X_KNEW, but a different direction to an interpolation point may !     be chosen, in order to prevent S from being nearly parallel to D. ! dd = zero ds = zero ss = zero xoptsq = zero do i = 1 , n dd = dd + d ( i ) ** 2 s ( i ) = xpt ( knew , i ) - xopt ( i ) ds = ds + d ( i ) * s ( i ) ss = ss + s ( i ) ** 2 xoptsq = xoptsq + xopt ( i ) ** 2 end do if ( ds * ds > 0.99_wp * dd * ss ) then ksav = knew dtest = ds * ds / ss do k = 1 , npt if ( k /= kopt ) then dstemp = zero sstemp = zero do i = 1 , n diff = xpt ( k , i ) - xopt ( i ) dstemp = dstemp + d ( i ) * diff sstemp = sstemp + diff * diff end do if ( dstemp * dstemp / sstemp < dtest ) then ksav = k dtest = dstemp * dstemp / sstemp ds = dstemp ss = sstemp end if end if end do do i = 1 , n s ( i ) = xpt ( ksav , i ) - xopt ( i ) end do end if ssden = dd * ss - ds * ds iterc = 0 densav = zero ! !     Begin the iteration by overwriting S with a vector that has the !     required length and direction. ! 70 iterc = iterc + 1 temp = one / sqrt ( ssden ) xoptd = zero xopts = zero do i = 1 , n s ( i ) = temp * ( dd * s ( i ) - ds * d ( i )) xoptd = xoptd + xopt ( i ) * d ( i ) xopts = xopts + xopt ( i ) * s ( i ) end do ! !     Set the coefficients of the first two terms of BETA. ! tempa = half * xoptd * xoptd tempb = half * xopts * xopts den ( 1 ) = dd * ( xoptsq + half * dd ) + tempa + tempb den ( 2 ) = two * xoptd * dd den ( 3 ) = two * xopts * dd den ( 4 ) = tempa - tempb den ( 5 ) = xoptd * xopts do i = 6 , 9 den ( i ) = zero end do ! !     Put the coefficients of Wcheck in WVEC. ! do k = 1 , npt tempa = zero tempb = zero tempc = zero do i = 1 , n tempa = tempa + xpt ( k , i ) * d ( i ) tempb = tempb + xpt ( k , i ) * s ( i ) tempc = tempc + xpt ( k , i ) * xopt ( i ) end do wvec ( k , 1 ) = quart * ( tempa * tempa + tempb * tempb ) wvec ( k , 2 ) = tempa * tempc wvec ( k , 3 ) = tempb * tempc wvec ( k , 4 ) = quart * ( tempa * tempa - tempb * tempb ) wvec ( k , 5 ) = half * tempa * tempb end do do i = 1 , n ip = i + npt wvec ( ip , 1 ) = zero wvec ( ip , 2 ) = d ( i ) wvec ( ip , 3 ) = s ( i ) wvec ( ip , 4 ) = zero wvec ( ip , 5 ) = zero end do ! !     Put the coefficents of THETA*Wcheck in PROD. ! do jc = 1 , 5 nw = npt if ( jc == 2 . or . jc == 3 ) nw = ndim do k = 1 , npt prod ( k , jc ) = zero end do do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * wvec ( k , jc ) end do if ( j < idz ) sum = - sum do k = 1 , npt prod ( k , jc ) = prod ( k , jc ) + sum * zmat ( k , j ) end do end do if ( nw == ndim ) then do k = 1 , npt sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * wvec ( npt + j , jc ) end do prod ( k , jc ) = prod ( k , jc ) + sum end do end if do j = 1 , n sum = zero do i = 1 , nw sum = sum + bmat ( i , j ) * wvec ( i , jc ) end do prod ( npt + j , jc ) = sum end do end do ! !     Include in DEN the part of BETA that depends on THETA. ! do k = 1 , ndim sum = zero do i = 1 , 5 par ( i ) = half * prod ( k , i ) * wvec ( k , i ) sum = sum + par ( i ) end do den ( 1 ) = den ( 1 ) - par ( 1 ) - sum tempa = prod ( k , 1 ) * wvec ( k , 2 ) + prod ( k , 2 ) * wvec ( k , 1 ) tempb = prod ( k , 2 ) * wvec ( k , 4 ) + prod ( k , 4 ) * wvec ( k , 2 ) tempc = prod ( k , 3 ) * wvec ( k , 5 ) + prod ( k , 5 ) * wvec ( k , 3 ) den ( 2 ) = den ( 2 ) - tempa - half * ( tempb + tempc ) den ( 6 ) = den ( 6 ) - half * ( tempb - tempc ) tempa = prod ( k , 1 ) * wvec ( k , 3 ) + prod ( k , 3 ) * wvec ( k , 1 ) tempb = prod ( k , 2 ) * wvec ( k , 5 ) + prod ( k , 5 ) * wvec ( k , 2 ) tempc = prod ( k , 3 ) * wvec ( k , 4 ) + prod ( k , 4 ) * wvec ( k , 3 ) den ( 3 ) = den ( 3 ) - tempa - half * ( tempb - tempc ) den ( 7 ) = den ( 7 ) - half * ( tempb + tempc ) tempa = prod ( k , 1 ) * wvec ( k , 4 ) + prod ( k , 4 ) * wvec ( k , 1 ) den ( 4 ) = den ( 4 ) - tempa - par ( 2 ) + par ( 3 ) tempa = prod ( k , 1 ) * wvec ( k , 5 ) + prod ( k , 5 ) * wvec ( k , 1 ) tempb = prod ( k , 2 ) * wvec ( k , 3 ) + prod ( k , 3 ) * wvec ( k , 2 ) den ( 5 ) = den ( 5 ) - tempa - half * tempb den ( 8 ) = den ( 8 ) - par ( 4 ) + par ( 5 ) tempa = prod ( k , 4 ) * wvec ( k , 5 ) + prod ( k , 5 ) * wvec ( k , 4 ) den ( 9 ) = den ( 9 ) - half * tempa end do ! !     Extend DEN so that it holds all the coefficients of DENOM. ! sum = zero do i = 1 , 5 par ( i ) = half * prod ( knew , i ) ** 2 sum = sum + par ( i ) end do denex ( 1 ) = alpha * den ( 1 ) + par ( 1 ) + sum tempa = two * prod ( knew , 1 ) * prod ( knew , 2 ) tempb = prod ( knew , 2 ) * prod ( knew , 4 ) tempc = prod ( knew , 3 ) * prod ( knew , 5 ) denex ( 2 ) = alpha * den ( 2 ) + tempa + tempb + tempc denex ( 6 ) = alpha * den ( 6 ) + tempb - tempc tempa = two * prod ( knew , 1 ) * prod ( knew , 3 ) tempb = prod ( knew , 2 ) * prod ( knew , 5 ) tempc = prod ( knew , 3 ) * prod ( knew , 4 ) denex ( 3 ) = alpha * den ( 3 ) + tempa + tempb - tempc denex ( 7 ) = alpha * den ( 7 ) + tempb + tempc tempa = two * prod ( knew , 1 ) * prod ( knew , 4 ) denex ( 4 ) = alpha * den ( 4 ) + tempa + par ( 2 ) - par ( 3 ) tempa = two * prod ( knew , 1 ) * prod ( knew , 5 ) denex ( 5 ) = alpha * den ( 5 ) + tempa + prod ( knew , 2 ) * prod ( knew , 3 ) denex ( 8 ) = alpha * den ( 8 ) + par ( 4 ) - par ( 5 ) denex ( 9 ) = alpha * den ( 9 ) + prod ( knew , 4 ) * prod ( knew , 5 ) ! !     Seek the value of the angle that maximizes the modulus of DENOM. ! sum = denex ( 1 ) + denex ( 2 ) + denex ( 4 ) + denex ( 6 ) + denex ( 8 ) denold = sum denmax = sum isave = 0 iu = 49 temp = twopi / real ( iu + 1 , wp ) par ( 1 ) = one do i = 1 , iu angle = real ( i , wp ) * temp par ( 2 ) = cos ( angle ) par ( 3 ) = sin ( angle ) do j = 4 , 8 , 2 par ( j ) = par ( 2 ) * par ( j - 2 ) - par ( 3 ) * par ( j - 1 ) par ( j + 1 ) = par ( 2 ) * par ( j - 1 ) + par ( 3 ) * par ( j - 2 ) end do sumold = sum sum = zero do j = 1 , 9 sum = sum + denex ( j ) * par ( j ) end do if ( abs ( sum ) > abs ( denmax )) then denmax = sum isave = i tempa = sumold else if ( i == isave + 1 ) then tempb = sum end if end do if ( isave == 0 ) tempa = sum if ( isave == iu ) tempb = denold step = zero if ( tempa /= tempb ) then tempa = tempa - denmax tempb = tempb - denmax step = half * ( tempa - tempb ) / ( tempa + tempb ) end if angle = temp * ( real ( isave , wp ) + step ) ! !     Calculate the new parameters of the denominator, the new VLAG vector !     and the new D. Then test for convergence. ! par ( 2 ) = cos ( angle ) par ( 3 ) = sin ( angle ) do j = 4 , 8 , 2 par ( j ) = par ( 2 ) * par ( j - 2 ) - par ( 3 ) * par ( j - 1 ) par ( j + 1 ) = par ( 2 ) * par ( j - 1 ) + par ( 3 ) * par ( j - 2 ) end do beta = zero denmax = zero do j = 1 , 9 beta = beta + den ( j ) * par ( j ) denmax = denmax + denex ( j ) * par ( j ) end do do k = 1 , ndim vlag ( k ) = zero do j = 1 , 5 vlag ( k ) = vlag ( k ) + prod ( k , j ) * par ( j ) end do end do tau = vlag ( knew ) dd = zero tempa = zero tempb = zero do i = 1 , n d ( i ) = par ( 2 ) * d ( i ) + par ( 3 ) * s ( i ) w ( i ) = xopt ( i ) + d ( i ) dd = dd + d ( i ) ** 2 tempa = tempa + d ( i ) * w ( i ) tempb = tempb + w ( i ) * w ( i ) end do if ( iterc >= n ) go to 340 if ( iterc > 1 ) densav = max ( densav , denold ) if ( abs ( denmax ) <= 1.1_wp * abs ( densav )) go to 340 densav = denmax ! !     Set S to half the gradient of the denominator with respect to D. !     Then branch for the next iteration. ! do i = 1 , n temp = tempa * xopt ( i ) + tempb * d ( i ) - vlag ( npt + i ) s ( i ) = tau * bmat ( knew , i ) + alpha * temp end do do k = 1 , npt sum = zero do j = 1 , n sum = sum + xpt ( k , j ) * w ( j ) end do temp = ( tau * w ( n + k ) - alpha * vlag ( k )) * sum do i = 1 , n s ( i ) = s ( i ) + temp * xpt ( k , i ) end do end do ss = zero ds = zero do i = 1 , n ss = ss + s ( i ) ** 2 ds = ds + d ( i ) * s ( i ) end do ssden = dd * ss - ds * ds if ( ssden >= 1.0e-8_wp * dd * ss ) go to 70 ! !     Set the vector W before the RETURN from the subroutine. ! 340 do k = 1 , ndim w ( k ) = zero do j = 1 , 5 w ( k ) = w ( k ) + wvec ( k , j ) * par ( j ) end do end do vlag ( kopt ) = vlag ( kopt ) + one end subroutine bigden","tags":"","loc":"proc/bigden.html"},{"title":"biglag – PowellOpt","text":"private  subroutine biglag(n, npt, xopt, xpt, bmat, zmat, idz, ndim, knew, delta, d, alpha, hcol, gc, gd, s, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xopt real :: xpt real :: bmat real :: zmat integer :: idz integer :: ndim integer :: knew real :: delta real :: d real :: alpha real :: hcol real :: gc real :: gd real :: s real :: w Called by proc~~biglag~~CalledByGraph proc~biglag biglag proc~newuob newuob proc~newuob->proc~biglag proc~newuoa newuoa proc~newuoa->proc~newuob proc~newuoa_test newuoa_test proc~newuoa_test->proc~newuoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine biglag ( n , npt , xopt , xpt , bmat , zmat , idz , ndim , knew , delta , d , alpha , & hcol , gc , gd , s , w ) implicit real ( wp ) ( a - h , o - z ) dimension xopt ( * ), xpt ( npt , * ), bmat ( ndim , * ), zmat ( npt , * ), d ( * ), hcol ( * ), & gc ( * ), gd ( * ), s ( * ), w ( * ) ! !     N is the number of variables. !     NPT is the number of interpolation equations. !     XOPT is the best interpolation point so far. !     XPT contains the coordinates of the current interpolation points. !     BMAT provides the last N columns of H. !     ZMAT and IDZ give a factorization of the first NPT by NPT submatrix of H. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     KNEW is the index of the interpolation point that is going to be moved. !     DELTA is the current trust region bound. !     D will be set to the step from XOPT to the new point. !     ALPHA will be set to the KNEW-th diagonal element of the H matrix. !     HCOL, GC, GD, S and W will be used for working space. ! !     The step D is calculated in a way that attempts to maximize the modulus !     of LFUNC(XOPT+D), subject to the bound ||D|| .LE. DELTA, where LFUNC is !     the KNEW-th Lagrange function. ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp zero = 0.0_wp twopi = 8.0_wp * atan ( one ) delsq = delta * delta nptm = npt - n - 1 ! !     Set the first NPT components of HCOL to the leading elements of the !     KNEW-th column of H. ! iterc = 0 do k = 1 , npt hcol ( k ) = zero end do do j = 1 , nptm temp = zmat ( knew , j ) if ( j < idz ) temp = - temp do k = 1 , npt hcol ( k ) = hcol ( k ) + temp * zmat ( k , j ) end do end do alpha = hcol ( knew ) ! !     Set the unscaled initial direction D. Form the gradient of LFUNC at !     XOPT, and multiply D by the second derivative matrix of LFUNC. ! dd = zero do i = 1 , n d ( i ) = xpt ( knew , i ) - xopt ( i ) gc ( i ) = bmat ( knew , i ) gd ( i ) = zero dd = dd + d ( i ) ** 2 end do do k = 1 , npt temp = zero sum = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) sum = sum + xpt ( k , j ) * d ( j ) end do temp = hcol ( k ) * temp sum = hcol ( k ) * sum do i = 1 , n gc ( i ) = gc ( i ) + temp * xpt ( k , i ) gd ( i ) = gd ( i ) + sum * xpt ( k , i ) end do end do ! !     Scale D and GD, with a sign change if required. Set S to another !     vector in the initial two dimensional subspace. ! gg = zero sp = zero dhd = zero do i = 1 , n gg = gg + gc ( i ) ** 2 sp = sp + d ( i ) * gc ( i ) dhd = dhd + d ( i ) * gd ( i ) end do scale = delta / sqrt ( dd ) if ( sp * dhd < zero ) scale = - scale temp = zero if ( sp * sp > 0.99_wp * dd * gg ) temp = one tau = scale * ( abs ( sp ) + half * scale * abs ( dhd )) if ( gg * delsq < 0.01_wp * tau * tau ) temp = one do i = 1 , n d ( i ) = scale * d ( i ) gd ( i ) = scale * gd ( i ) s ( i ) = gc ( i ) + temp * gd ( i ) end do ! !     Begin the iteration by overwriting S with a vector that has the !     required length and direction, except that termination occurs if !     the given D and S are nearly parallel. ! 80 iterc = iterc + 1 dd = zero sp = zero ss = zero do i = 1 , n dd = dd + d ( i ) ** 2 sp = sp + d ( i ) * s ( i ) ss = ss + s ( i ) ** 2 end do temp = dd * ss - sp * sp if ( temp <= 1.0e-8_wp * dd * ss ) go to 160 denom = sqrt ( temp ) do i = 1 , n s ( i ) = ( dd * s ( i ) - sp * d ( i )) / denom w ( i ) = zero end do ! !     Calculate the coefficients of the objective function on the circle, !     beginning with the multiplication of S by the second derivative matrix. ! do k = 1 , npt sum = zero do j = 1 , n sum = sum + xpt ( k , j ) * s ( j ) end do sum = hcol ( k ) * sum do i = 1 , n w ( i ) = w ( i ) + sum * xpt ( k , i ) end do end do cf1 = zero cf2 = zero cf3 = zero cf4 = zero cf5 = zero do i = 1 , n cf1 = cf1 + s ( i ) * w ( i ) cf2 = cf2 + d ( i ) * gc ( i ) cf3 = cf3 + s ( i ) * gc ( i ) cf4 = cf4 + d ( i ) * gd ( i ) cf5 = cf5 + s ( i ) * gd ( i ) end do cf1 = half * cf1 cf4 = half * cf4 - cf1 ! !     Seek the value of the angle that maximizes the modulus of TAU. ! taubeg = cf1 + cf2 + cf4 taumax = taubeg tauold = taubeg isave = 0 iu = 49 temp = twopi / real ( iu + 1 , wp ) do i = 1 , iu angle = real ( i , wp ) * temp cth = cos ( angle ) sth = sin ( angle ) tau = cf1 + ( cf2 + cf4 * cth ) * cth + ( cf3 + cf5 * cth ) * sth if ( abs ( tau ) > abs ( taumax )) then taumax = tau isave = i tempa = tauold else if ( i == isave + 1 ) then tempb = tau end if tauold = tau end do if ( isave == 0 ) tempa = tau if ( isave == iu ) tempb = taubeg step = zero if ( tempa /= tempb ) then tempa = tempa - taumax tempb = tempb - taumax step = half * ( tempa - tempb ) / ( tempa + tempb ) end if angle = temp * ( real ( isave , wp ) + step ) ! !     Calculate the new D and GD. Then test for convergence. ! cth = cos ( angle ) sth = sin ( angle ) tau = cf1 + ( cf2 + cf4 * cth ) * cth + ( cf3 + cf5 * cth ) * sth do i = 1 , n d ( i ) = cth * d ( i ) + sth * s ( i ) gd ( i ) = cth * gd ( i ) + sth * w ( i ) s ( i ) = gc ( i ) + gd ( i ) end do if ( abs ( tau ) <= 1.1_wp * abs ( taubeg )) go to 160 if ( iterc < n ) go to 80 160 return end subroutine biglag","tags":"","loc":"proc/biglag.html"},{"title":"trsapp – PowellOpt","text":"private  subroutine trsapp(n, npt, xopt, xpt, gq, hq, pq, delta, step, d, g, hd, hs, crvmin) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xopt real :: xpt real :: gq real :: hq real :: pq real :: delta real :: step real :: d real :: g real :: hd real :: hs real :: crvmin Called by proc~~trsapp~~CalledByGraph proc~trsapp trsapp proc~newuob newuob proc~newuob->proc~trsapp proc~newuoa newuoa proc~newuoa->proc~newuob proc~newuoa_test newuoa_test proc~newuoa_test->proc~newuoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine trsapp ( n , npt , xopt , xpt , gq , hq , pq , delta , step , d , g , hd , hs , crvmin ) implicit real ( wp ) ( a - h , o - z ) dimension xopt ( * ), xpt ( npt , * ), gq ( * ), hq ( * ), pq ( * ), step ( * ), d ( * ), g ( * ), & hd ( * ), hs ( * ) ! !     N is the number of variables of a quadratic objective function, Q say. !     The arguments NPT, XOPT, XPT, GQ, HQ and PQ have their usual meanings, !       in order to define the current quadratic model Q. !     DELTA is the trust region radius, and has to be positive. !     STEP will be set to the calculated trial step. !     The arrays D, G, HD and HS will be used for working space. !     CRVMIN will be set to the least curvature of H along the conjugate !       directions that occur, except that it is set to zero if STEP goes !       all the way to the trust region boundary. ! !     The calculation of STEP begins with the truncated conjugate gradient !     method. If the boundary of the trust region is reached, then further !     changes to STEP may be made, each one being in the 2D space spanned !     by the current STEP and the corresponding gradient of Q. Thus STEP !     should provide a substantial reduction to Q within the trust region. ! !     Initialization, which includes setting HD to H times XOPT. ! half = 0.5_wp zero = 0.0_wp twopi = 8.0_wp * atan ( 1.0_wp ) delsq = delta * delta iterc = 0 itermax = n itersw = itermax do i = 1 , n d ( i ) = xopt ( i ) end do go to 170 ! !     Prepare for the first line search. ! 20 qred = zero dd = zero do i = 1 , n step ( i ) = zero hs ( i ) = zero g ( i ) = gq ( i ) + hd ( i ) d ( i ) = - g ( i ) dd = dd + d ( i ) ** 2 end do crvmin = zero if ( dd == zero ) go to 160 ds = zero ss = zero gg = dd ggbeg = gg ! !     Calculate the step to the trust region boundary and the product HD. ! 40 iterc = iterc + 1 temp = delsq - ss bstep = temp / ( ds + sqrt ( ds * ds + dd * temp )) go to 170 50 dhd = zero do j = 1 , n dhd = dhd + d ( j ) * hd ( j ) end do ! !     Update CRVMIN and set the step-length ALPHA. ! alpha = bstep if ( dhd > zero ) then temp = dhd / dd if ( iterc == 1 ) crvmin = temp crvmin = min ( crvmin , temp ) alpha = min ( alpha , gg / dhd ) end if qadd = alpha * ( gg - half * alpha * dhd ) qred = qred + qadd ! !     Update STEP and HS. ! ggsav = gg gg = zero do i = 1 , n step ( i ) = step ( i ) + alpha * d ( i ) hs ( i ) = hs ( i ) + alpha * hd ( i ) gg = gg + ( g ( i ) + hs ( i )) ** 2 end do ! !     Begin another conjugate direction iteration if required. ! if ( alpha < bstep ) then if ( qadd <= 0.01_wp * qred ) go to 160 if ( gg <= 1.0e-4_wp * ggbeg ) go to 160 if ( iterc == itermax ) go to 160 temp = gg / ggsav dd = zero ds = zero ss = zero do i = 1 , n d ( i ) = temp * d ( i ) - g ( i ) - hs ( i ) dd = dd + d ( i ) ** 2 ds = ds + d ( i ) * step ( i ) ss = ss + step ( i ) ** 2 end do if ( ds <= zero ) go to 160 if ( ss < delsq ) go to 40 end if crvmin = zero itersw = iterc ! !     Test whether an alternative iteration is required. ! 90 if ( gg <= 1.0e-4_wp * ggbeg ) go to 160 sg = zero shs = zero do i = 1 , n sg = sg + step ( i ) * g ( i ) shs = shs + step ( i ) * hs ( i ) end do sgk = sg + shs angtest = sgk / sqrt ( gg * delsq ) if ( angtest <=- 0.99_wp ) go to 160 ! !     Begin the alternative iteration by calculating D and HD and some !     scalar products. ! iterc = iterc + 1 temp = sqrt ( delsq * gg - sgk * sgk ) tempa = delsq / temp tempb = sgk / temp do i = 1 , n d ( i ) = tempa * ( g ( i ) + hs ( i )) - tempb * step ( i ) end do go to 170 120 dg = zero dhd = zero dhs = zero do i = 1 , n dg = dg + d ( i ) * g ( i ) dhd = dhd + hd ( i ) * d ( i ) dhs = dhs + hd ( i ) * step ( i ) end do ! !     Seek the value of the angle that minimizes Q. ! cf = half * ( shs - dhd ) qbeg = sg + cf qsav = qbeg qmin = qbeg isave = 0 iu = 49 temp = twopi / real ( iu + 1 , wp ) do i = 1 , iu angle = real ( i , wp ) * temp cth = cos ( angle ) sth = sin ( angle ) qnew = ( sg + cf * cth ) * cth + ( dg + dhs * cth ) * sth if ( qnew < qmin ) then qmin = qnew isave = i tempa = qsav else if ( i == isave + 1 ) then tempb = qnew end if qsav = qnew end do if ( isave == zero ) tempa = qnew if ( isave == iu ) tempb = qbeg angle = zero if ( tempa /= tempb ) then tempa = tempa - qmin tempb = tempb - qmin angle = half * ( tempa - tempb ) / ( tempa + tempb ) end if angle = temp * ( real ( isave , wp ) + angle ) ! !     Calculate the new STEP and HS. Then test for convergence. ! cth = cos ( angle ) sth = sin ( angle ) reduc = qbeg - ( sg + cf * cth ) * cth - ( dg + dhs * cth ) * sth gg = zero do i = 1 , n step ( i ) = cth * step ( i ) + sth * d ( i ) hs ( i ) = cth * hs ( i ) + sth * hd ( i ) gg = gg + ( g ( i ) + hs ( i )) ** 2 end do qred = qred + reduc ratio = reduc / qred if ( iterc < itermax . and . ratio > 0.01_wp ) go to 90 160 return ! !     The following instructions act as a subroutine for setting the vector !     HD to the vector D multiplied by the second derivative matrix of Q. !     They are called from three different places, which are distinguished !     by the value of ITERC. ! 170 do i = 1 , n hd ( i ) = zero end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * d ( j ) end do temp = temp * pq ( k ) do i = 1 , n hd ( i ) = hd ( i ) + temp * xpt ( k , i ) end do end do ih = 0 do j = 1 , n do i = 1 , j ih = ih + 1 if ( i < j ) hd ( j ) = hd ( j ) + hq ( ih ) * d ( i ) hd ( i ) = hd ( i ) + hq ( ih ) * d ( j ) end do end do if ( iterc == 0 ) go to 20 if ( iterc <= itersw ) go to 50 go to 120 end subroutine trsapp","tags":"","loc":"proc/trsapp.html"},{"title":"update – PowellOpt","text":"private  subroutine update(n, npt, bmat, zmat, idz, ndim, vlag, beta, knew, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: bmat real :: zmat integer :: idz integer :: ndim real :: vlag real :: beta integer :: knew real :: w Called by proc~~update~~CalledByGraph proc~update update proc~newuob newuob proc~newuob->proc~update proc~newuoa newuoa proc~newuoa->proc~newuob proc~newuoa_test newuoa_test proc~newuoa_test->proc~newuoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update ( n , npt , bmat , zmat , idz , ndim , vlag , beta , knew , w ) implicit real ( wp ) ( a - h , o - z ) dimension bmat ( ndim , * ), zmat ( npt , * ), vlag ( * ), w ( * ) ! !     The arrays BMAT and ZMAT with IDZ are updated, in order to shift the !     interpolation point that has index KNEW. On entry, VLAG contains the !     components of the vector Theta*Wcheck+e_b of the updating formula !     (6.11), and BETA holds the value of the parameter that has this name. !     The vector W is used for working space. ! !     Set some constants. ! one = 1.0_wp zero = 0.0_wp nptm = npt - n - 1 ! !     Apply the rotations that put zeros in the KNEW-th row of ZMAT. ! jl = 1 do j = 2 , nptm if ( j == idz ) then jl = idz else if ( zmat ( knew , j ) /= zero ) then temp = sqrt ( zmat ( knew , jl ) ** 2 + zmat ( knew , j ) ** 2 ) tempa = zmat ( knew , jl ) / temp tempb = zmat ( knew , j ) / temp do i = 1 , npt temp = tempa * zmat ( i , jl ) + tempb * zmat ( i , j ) zmat ( i , j ) = tempa * zmat ( i , j ) - tempb * zmat ( i , jl ) zmat ( i , jl ) = temp end do zmat ( knew , j ) = zero end if end do ! !     Put the first NPT components of the KNEW-th column of HLAG into W, !     and calculate the parameters of the updating formula. ! tempa = zmat ( knew , 1 ) if ( idz >= 2 ) tempa = - tempa if ( jl > 1 ) tempb = zmat ( knew , jl ) do i = 1 , npt w ( i ) = tempa * zmat ( i , 1 ) if ( jl > 1 ) w ( i ) = w ( i ) + tempb * zmat ( i , jl ) end do alpha = w ( knew ) tau = vlag ( knew ) tausq = tau * tau denom = alpha * beta + tausq vlag ( knew ) = vlag ( knew ) - one ! !     Complete the updating of ZMAT when there is only one nonzero element !     in the KNEW-th row of the new matrix ZMAT, but, if IFLAG is set to one, !     then the first column of ZMAT will be exchanged with another one later. ! iflag = 0 if ( jl == 1 ) then temp = sqrt ( abs ( denom )) tempb = tempa / temp tempa = tau / temp do i = 1 , npt zmat ( i , 1 ) = tempa * zmat ( i , 1 ) - tempb * vlag ( i ) end do if ( idz == 1 . and . temp < zero ) idz = 2 if ( idz >= 2 . and . temp >= zero ) iflag = 1 else ! !     Complete the updating of ZMAT in the alternative case. ! ja = 1 if ( beta >= zero ) ja = jl jb = jl + 1 - ja temp = zmat ( knew , jb ) / denom tempa = temp * beta tempb = temp * tau temp = zmat ( knew , ja ) scala = one / sqrt ( abs ( beta ) * temp * temp + tausq ) scalb = scala * sqrt ( abs ( denom )) do i = 1 , npt zmat ( i , ja ) = scala * ( tau * zmat ( i , ja ) - temp * vlag ( i )) zmat ( i , jb ) = scalb * ( zmat ( i , jb ) - tempa * w ( i ) - tempb * vlag ( i )) end do if ( denom <= zero ) then if ( beta < zero ) idz = idz + 1 if ( beta >= zero ) iflag = 1 end if end if ! !     IDZ is reduced in the following case, and usually the first column !     of ZMAT is exchanged with a later one. ! if ( iflag == 1 ) then idz = idz - 1 do i = 1 , npt temp = zmat ( i , 1 ) zmat ( i , 1 ) = zmat ( i , idz ) zmat ( i , idz ) = temp end do end if ! !     Finally, update the matrix BMAT. ! do j = 1 , n jp = npt + j w ( jp ) = bmat ( knew , j ) tempa = ( alpha * vlag ( jp ) - tau * w ( jp )) / denom tempb = ( - beta * w ( jp ) - tau * vlag ( jp )) / denom do i = 1 , jp bmat ( i , j ) = bmat ( i , j ) + tempa * vlag ( i ) + tempb * w ( i ) if ( i > npt ) bmat ( jp , i - npt ) = bmat ( i , j ) end do end do end subroutine update","tags":"","loc":"proc/update.html"},{"title":"newuoa_test – PowellOpt","text":"public  subroutine newuoa_test() The Chebyquad test problem (Fletcher, 1965) for N = 2,4,6 and 8,\nwith NPT = 2N+1. Arguments None Calls proc~~newuoa_test~~CallsGraph proc~newuoa_test newuoa_test proc~newuoa newuoa proc~newuoa_test->proc~newuoa proc~newuob newuob proc~newuoa->proc~newuob proc~bigden bigden proc~newuob->proc~bigden proc~biglag biglag proc~newuob->proc~biglag proc~trsapp trsapp proc~newuob->proc~trsapp proc~update update proc~newuob->proc~update den den proc~bigden->den denex denex proc~bigden->denex par par proc~bigden->par Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine newuoa_test () implicit none real ( wp ) :: x ( 10 ) integer :: iprint , maxfun , n , npt , i real ( wp ) :: rhoend , rhobeg iprint = 2 maxfun = 5000 rhoend = 1.0e-6_wp do n = 2 , 8 , 2 npt = 2 * n + 1 do i = 1 , n x ( i ) = real ( i , wp ) / real ( n + 1 , wp ) end do rhobeg = 0.2_wp * x ( 1 ) print 20 , n , npt 20 format ( / / 4 x , 'Results with N =' , i2 , ' and NPT =' , i3 ) call newuoa ( n , npt , x , rhobeg , rhoend , iprint , maxfun , calfun ) end do contains subroutine calfun ( n , x , f ) implicit none integer :: n real ( wp ) :: x ( * ) real ( wp ) :: f real ( wp ) :: y ( 10 , 10 ) integer :: i , j , np , iw real ( wp ) :: sum do j = 1 , n y ( 1 , j ) = 1.0_wp y ( 2 , j ) = 2.0_wp * x ( j ) - 1.0_wp end do do i = 2 , n do j = 1 , n y ( i + 1 , j ) = 2.0_wp * y ( 2 , j ) * y ( i , j ) - y ( i - 1 , j ) end do end do f = 0.0_wp np = n + 1 iw = 1 do i = 1 , np sum = 0.0_wp do j = 1 , n sum = sum + y ( i , j ) end do sum = sum / real ( n , wp ) if ( iw > 0 ) sum = sum + 1.0_wp / real ( i * i - 2 * i , wp ) iw = - iw f = f + sum * sum end do end subroutine calfun end subroutine newuoa_test","tags":"","loc":"proc/newuoa_test.html"},{"title":"cobyla – PowellOpt","text":"public  subroutine cobyla(n, m, x, rhobeg, rhoend, iprint, maxfun, calcfc) This subroutine minimizes an objective function F(X) subject to M\ninequality constraints on X, where X is a vector of variables that has\nN components. The algorithm employs linear approximations to the\nobjective and constraint functions, the approximations being formed by\nlinear interpolation at N+1 points in the space of the variables.\nWe regard these interpolation points as vertices of a simplex. The\nparameter RHO controls the size of the simplex and it is reduced\nautomatically from RHOBEG to RHOEND. For each RHO the subroutine tries\nto achieve a good vector of variables for the current size, and then\nRHO is reduced until the value RHOEND is reached. Therefore RHOBEG and\nRHOEND should be set to reasonable initial changes to and the required\naccuracy in the variables respectively, but this accuracy should be\nviewed as a subject for experimentation because it is not guaranteed. The subroutine has an advantage over many of its competitors, however,\nwhich is that it treats each constraint individually when calculating\na change to the variables, instead of lumping the constraints together\ninto a single penalty function. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n number of variables integer, intent(in) :: m number of inequality constraints real(kind=wp), intent(inout), dimension(*) :: x Initial values of the variables must be set in X(1),X(2),...,X(N).\nOn return they will be changed to the solution. real(kind=wp), intent(in) :: rhobeg reasonable initial change to variables (see description of RHO) real(kind=wp), intent(in) :: rhoend required accuracy (see description of RHO) integer, intent(in) :: iprint IPRINT should be set to 0, 1, 2 or 3, which controls the amount of\nprinting during the calculation. Specifically, there is no output if\nIPRINT=0 and there is output only at the end of the calculation if\nIPRINT=1. Otherwise each new value of RHO and SIGMA is printed.\nFurther, the vector of variables and some function information are\ngiven either when RHO is reduced or when each new value of F(X) is\ncomputed in the cases IPRINT=2 or IPRINT=3 respectively. Here SIGMA\nis a penalty parameter, it being assumed that a change to X is an\nimprovement if it reduces the merit function\n    F(X)+SIGMA*MAX(0.0,-C1(X),-C2(X),...,-CM(X)),\nwhere C1,C2,...,CM denote the constraint functions that should become\nnonnegative eventually, at least to the precision of RHOEND. In the\nprinted output the displayed term that is multiplied by SIGMA is\ncalled MAXCV, which stands for 'MAXimum Constraint Violation'. integer, intent(inout) :: maxfun MAXFUN is an integer variable that must be set by the user to a\nlimit on the number of calls of CALCFC.\nThe value of MAXFUN will be altered to the number of calls\nof CALCFC that are made. procedure( func ) :: calcfc In order to define the objective and constraint functions, we require\na subroutine that has the name and arguments\n    SUBROUTINE CALCFC (N,M,X,F,CON)\n    DIMENSION X( ),CON( )\nThe values of N and M are fixed and have been defined already, while\nX is now the current vector of variables. The subroutine should return\nthe objective and constraint functions at X in F and CON(1),CON(2),\n...,CON(M). Note that we are trying to adjust X so that F(X) is as\nsmall as possible subject to the constraint functions being nonnegative. Calls proc~~cobyla~~CallsGraph proc~cobyla cobyla proc~cobylb cobylb proc~cobyla->proc~cobylb proc~trstlp trstlp proc~cobylb->proc~trstlp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cobyla~~CalledByGraph proc~cobyla cobyla proc~cobyla_test cobyla_test proc~cobyla_test->proc~cobyla Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cobyla ( n , m , x , rhobeg , rhoend , iprint , maxfun , calcfc ) implicit none integer , intent ( in ) :: n !! number of variables integer , intent ( in ) :: m !! number of inequality constraints real ( wp ), dimension ( * ), intent ( inout ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). !! On return they will be changed to the solution. real ( wp ), intent ( in ) :: rhobeg !! reasonable initial change to variables (see description of RHO) real ( wp ), intent ( in ) :: rhoend !! required accuracy (see description of RHO) integer , intent ( in ) :: iprint !! IPRINT should be set to 0, 1, 2 or 3, which controls the amount of !! printing during the calculation. Specifically, there is no output if !! IPRINT=0 and there is output only at the end of the calculation if !! IPRINT=1. Otherwise each new value of RHO and SIGMA is printed. !! Further, the vector of variables and some function information are !! given either when RHO is reduced or when each new value of F(X) is !! computed in the cases IPRINT=2 or IPRINT=3 respectively. Here SIGMA !! is a penalty parameter, it being assumed that a change to X is an !! improvement if it reduces the merit function !!     F(X)+SIGMA*MAX(0.0,-C1(X),-C2(X),...,-CM(X)), !! where C1,C2,...,CM denote the constraint functions that should become !! nonnegative eventually, at least to the precision of RHOEND. In the !! printed output the displayed term that is multiplied by SIGMA is !! called MAXCV, which stands for 'MAXimum Constraint Violation'. integer , intent ( inout ) :: maxfun !! MAXFUN is an integer variable that must be set by the user to a !! limit on the number of calls of CALCFC. !! The value of MAXFUN will be altered to the number of calls !! of CALCFC that are made. procedure ( func ) :: calcfc !! In order to define the objective and constraint functions, we require !! a subroutine that has the name and arguments !!     SUBROUTINE CALCFC (N,M,X,F,CON) !!     DIMENSION X(*),CON(*) !! The values of N and M are fixed and have been defined already, while !! X is now the current vector of variables. The subroutine should return !! the objective and constraint functions at X in F and CON(1),CON(2), !! ...,CON(M). Note that we are trying to adjust X so that F(X) is as !! small as possible subject to the constraint functions being nonnegative. integer , dimension (:), allocatable :: iact real ( wp ), dimension (:), allocatable :: w integer :: mpp , icon , isim , isimi , idatm , ia , ivsig , iveta , isigb , idx , iwork !W and IACT provide real and integer arrays that are used as working space. allocate ( w ( N * ( 3 * N + 2 * M + 11 ) + 4 * M + 6 )) allocate ( iact ( M + 1 )) ! Partition the working space array W to provide the storage that is needed ! for the main calculation. mpp = m + 2 icon = 1 isim = icon + mpp isimi = isim + n * n + n idatm = isimi + n * n ia = idatm + n * mpp + mpp ivsig = ia + m * n + n iveta = ivsig + n isigb = iveta + n idx = isigb + n iwork = idx + n call cobylb ( n , m , mpp , x , rhobeg , rhoend , iprint , maxfun , w ( icon ), w ( isim ), & w ( isimi ), w ( idatm ), w ( ia ), w ( ivsig ), w ( iveta ), w ( isigb ), w ( idx ), & w ( iwork ), iact , calcfc ) deallocate ( iact ) deallocate ( w ) end subroutine cobyla","tags":"","loc":"proc/cobyla.html"},{"title":"cobylb – PowellOpt","text":"private  subroutine cobylb(n, m, mpp, x, rhobeg, rhoend, iprint, maxfun, con, sim, simi, datmat, a, vsig, veta, sigbar, dx, w, iact, calcfc) Arguments Type Intent Optional Attributes Name integer :: n integer :: m integer :: mpp real :: x real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: con real :: sim real :: simi real :: datmat real :: a real :: vsig real :: veta real :: sigbar real :: dx real :: w integer :: iact procedure( func ) :: calcfc Calls proc~~cobylb~~CallsGraph proc~cobylb cobylb proc~trstlp trstlp proc~cobylb->proc~trstlp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cobylb~~CalledByGraph proc~cobylb cobylb proc~cobyla cobyla proc~cobyla->proc~cobylb proc~cobyla_test cobyla_test proc~cobyla_test->proc~cobyla Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cobylb ( n , m , mpp , x , rhobeg , rhoend , iprint , maxfun , con , sim , simi , & datmat , a , vsig , veta , sigbar , dx , w , iact , calcfc ) implicit real ( wp ) ( a - h , o - z ) dimension x ( * ), con ( * ), sim ( n , * ), simi ( n , * ), datmat ( mpp , * ), a ( n , * ), vsig ( * ),& veta ( * ), sigbar ( * ), dx ( * ), w ( * ), iact ( * ) procedure ( func ) :: calcfc ! !     Set the initial values of some parameters. The last column of SIM holds !     the optimal vertex of the current simplex, and the preceding N columns !     hold the displacements from the optimal vertex to the other vertices. !     Further, SIMI holds the inverse of the matrix that is contained in the !     first N columns of SIM. ! iptem = min ( n , 5 ) iptemp = iptem + 1 np = n + 1 mp = m + 1 alpha = 0.25_wp beta = 2.1_wp gamma = 0.5_wp delta = 1.1_wp rho = rhobeg parmu = 0.0_wp if ( iprint >= 2 ) print 10 , rho 10 format ( / 3 x , 'The initial value of RHO is' , 1 pe13 . 6 , 2 x ,& 'and PARMU is set to zero.' ) nfvals = 0 temp = 1.0_wp / rho do i = 1 , n sim ( i , np ) = x ( i ) do j = 1 , n sim ( i , j ) = 0.0_wp simi ( i , j ) = 0.0_wp end do sim ( i , i ) = rho simi ( i , i ) = temp end do jdrop = np ibrnch = 0 ! !     Make the next call of the user-supplied subroutine CALCFC. These !     instructions are also used for calling CALCFC during the iterations of !     the algorithm. ! 40 if ( nfvals >= maxfun . and . nfvals > 0 ) then if ( iprint >= 1 ) print 50 50 format ( / 3 x , 'Return from subroutine COBYLA because the ' ,& 'MAXFUN limit has been reached.' ) go to 600 end if nfvals = nfvals + 1 call calcfc ( n , m , x , f , con ) resmax = 0.0_wp if ( m > 0 ) then do k = 1 , m resmax = max ( resmax , - con ( k )) end do end if if ( nfvals == iprint - 1 . or . iprint == 3 ) then print 70 , nfvals , f , resmax , ( x ( i ), i = 1 , iptem ) 70 format ( / 3 x , 'NFVALS =' , i5 , 3 x , 'F =' , 1 pe13 . 6 , 4 x , 'MAXCV =' , 1 pe13 . 6 & & / 3 x , 'X =' , 1 pe13 . 6 , 1 p4e15 . 6 ) if ( iptem < n ) print 80 , ( x ( i ), i = iptemp , n ) 80 format ( 1 pe19 . 6 , 1 p4e15 . 6 ) end if con ( mp ) = f con ( mpp ) = resmax if ( ibrnch == 1 ) go to 440 ! !     Set the recently calculated function values in a column of DATMAT. This !     array has a column for each vertex of the current simplex, the entries of !     each column being the values of the constraint functions (if any) !     followed by the objective function and the greatest constraint violation !     at the vertex. ! do k = 1 , mpp datmat ( k , jdrop ) = con ( k ) end do if ( nfvals > np ) go to 130 ! !     Exchange the new vertex of the initial simplex with the optimal vertex if !     necessary. Then, if the initial simplex is not complete, pick its next !     vertex and calculate the function values there. ! if ( jdrop <= n ) then if ( datmat ( mp , np ) <= f ) then x ( jdrop ) = sim ( jdrop , np ) else sim ( jdrop , np ) = x ( jdrop ) do k = 1 , mpp datmat ( k , jdrop ) = datmat ( k , np ) datmat ( k , np ) = con ( k ) end do do k = 1 , jdrop sim ( jdrop , k ) = - rho temp = 0.0_wp do i = k , jdrop temp = temp - simi ( i , k ) end do simi ( jdrop , k ) = temp end do end if end if if ( nfvals <= n ) then jdrop = nfvals x ( jdrop ) = x ( jdrop ) + rho go to 40 end if 130 ibrnch = 1 ! !     Identify the optimal vertex of the current simplex. ! 140 phimin = datmat ( mp , np ) + parmu * datmat ( mpp , np ) nbest = np do j = 1 , n temp = datmat ( mp , j ) + parmu * datmat ( mpp , j ) if ( temp < phimin ) then nbest = j phimin = temp else if ( temp == phimin . and . parmu == 0.0_wp ) then if ( datmat ( mpp , j ) < datmat ( mpp , nbest )) nbest = j end if end do ! !     Switch the best vertex into pole position if it is not there already, !     and also update SIM, SIMI and DATMAT. ! if ( nbest <= n ) then do i = 1 , mpp temp = datmat ( i , np ) datmat ( i , np ) = datmat ( i , nbest ) datmat ( i , nbest ) = temp end do do i = 1 , n temp = sim ( i , nbest ) sim ( i , nbest ) = 0.0_wp sim ( i , np ) = sim ( i , np ) + temp tempa = 0.0_wp do k = 1 , n sim ( i , k ) = sim ( i , k ) - temp tempa = tempa - simi ( k , i ) end do simi ( nbest , i ) = tempa end do end if ! !     Make an error return if SIGI is a poor approximation to the inverse of !     the leading N by N submatrix of SIG. ! error = 0.0_wp do i = 1 , n do j = 1 , n temp = 0.0_wp if ( i == j ) temp = temp - 1.0_wp do k = 1 , n temp = temp + simi ( i , k ) * sim ( k , j ) end do error = max ( error , abs ( temp )) end do end do if ( error > 0.1_wp ) then if ( iprint >= 1 ) print 210 210 format ( / 3 x , 'Return from subroutine COBYLA because ' ,& 'rounding errors are becoming damaging.' ) go to 600 end if ! !     Calculate the coefficients of the linear approximations to the objective !     and constraint functions, placing minus the objective function gradient !     after the constraint gradients in the array A. The vector W is used for !     working space. ! do k = 1 , mp con ( k ) = - datmat ( k , np ) do j = 1 , n w ( j ) = datmat ( k , j ) + con ( k ) end do do i = 1 , n temp = 0.0_wp do j = 1 , n temp = temp + w ( j ) * simi ( j , i ) end do if ( k == mp ) temp = - temp a ( i , k ) = temp end do end do ! !     Calculate the values of sigma and eta, and set IFLAG=0 if the current !     simplex is not acceptable. ! iflag = 1 parsig = alpha * rho pareta = beta * rho do j = 1 , n wsig = 0.0_wp weta = 0.0_wp do i = 1 , n wsig = wsig + simi ( j , i ) ** 2 weta = weta + sim ( i , j ) ** 2 end do vsig ( j ) = 1.0_wp / sqrt ( wsig ) veta ( j ) = sqrt ( weta ) if ( vsig ( j ) < parsig . or . veta ( j ) > pareta ) iflag = 0 end do ! !     If a new vertex is needed to improve acceptability, then decide which !     vertex to drop from the simplex. ! if ( ibrnch == 1 . or . iflag == 1 ) go to 370 jdrop = 0 temp = pareta do j = 1 , n if ( veta ( j ) > temp ) then jdrop = j temp = veta ( j ) end if end do if ( jdrop == 0 ) then do j = 1 , n if ( vsig ( j ) < temp ) then jdrop = j temp = vsig ( j ) end if end do end if ! !     Calculate the step to the new vertex and its sign. ! temp = gamma * rho * vsig ( jdrop ) do i = 1 , n dx ( i ) = temp * simi ( jdrop , i ) end do cvmaxp = 0.0_wp cvmaxm = 0.0_wp do k = 1 , mp sum = 0.0_wp do i = 1 , n sum = sum + a ( i , k ) * dx ( i ) end do if ( k < mp ) then temp = datmat ( k , np ) cvmaxp = max ( cvmaxp , - sum - temp ) cvmaxm = max ( cvmaxm , sum - temp ) end if end do dxsign = 1.0_wp if ( parmu * ( cvmaxp - cvmaxm ) > sum + sum ) dxsign = - 1.0_wp ! !     Update the elements of SIM and SIMI, and set the next X. ! temp = 0.0_wp do i = 1 , n dx ( i ) = dxsign * dx ( i ) sim ( i , jdrop ) = dx ( i ) temp = temp + simi ( jdrop , i ) * dx ( i ) end do do i = 1 , n simi ( jdrop , i ) = simi ( jdrop , i ) / temp end do do j = 1 , n if ( j /= jdrop ) then temp = 0.0_wp do i = 1 , n temp = temp + simi ( j , i ) * dx ( i ) end do do i = 1 , n simi ( j , i ) = simi ( j , i ) - temp * simi ( jdrop , i ) end do end if x ( j ) = sim ( j , np ) + dx ( j ) end do go to 40 ! !     Calculate DX=x(*)-x(0). Branch if the length of DX is less than 0.5*RHO. ! 370 iz = 1 izdota = iz + n * n ivmc = izdota + n isdirn = ivmc + mp idxnew = isdirn + n ivmd = idxnew + n call trstlp ( n , m , a , con , rho , dx , ifull , iact , w ( iz ), w ( izdota ), w ( ivmc ), & & w ( isdirn ), w ( idxnew ), w ( ivmd )) if ( ifull == 0 ) then temp = 0.0_wp do i = 1 , n temp = temp + dx ( i ) ** 2 end do if ( temp < 0.25_wp * rho * rho ) then ibrnch = 1 go to 550 end if end if ! !     Predict the change to F and the new maximum constraint violation if the !     variables are altered from x(0) to x(0)+DX. ! resnew = 0.0_wp con ( mp ) = 0.0_wp do k = 1 , mp sum = con ( k ) do i = 1 , n sum = sum - a ( i , k ) * dx ( i ) end do if ( k < mp ) resnew = max ( resnew , sum ) end do ! !     Increase PARMU if necessary and branch back if this change alters the !     optimal vertex. Otherwise PREREM and PREREC will be set to the predicted !     reductions in the merit function and the maximum constraint violation !     respectively. ! barmu = 0.0_wp prerec = datmat ( mpp , np ) - resnew if ( prerec > 0.0_wp ) barmu = sum / prerec if ( parmu < 1.5_wp * barmu ) then parmu = 2.0_wp * barmu if ( iprint >= 2 ) print 410 , parmu 410 format ( / 3 x , 'Increase in PARMU to' , 1 pe13 . 6 ) phi = datmat ( mp , np ) + parmu * datmat ( mpp , np ) do j = 1 , n temp = datmat ( mp , j ) + parmu * datmat ( mpp , j ) if ( temp < phi ) go to 140 if ( temp == phi . and . parmu == 0.0_wp ) then if ( datmat ( mpp , j ) < datmat ( mpp , np )) go to 140 end if end do end if prerem = parmu * prerec - sum ! !     Calculate the constraint and objective functions at x(*). Then find the !     actual reduction in the merit function. ! do i = 1 , n x ( i ) = sim ( i , np ) + dx ( i ) end do ibrnch = 1 go to 40 440 vmold = datmat ( mp , np ) + parmu * datmat ( mpp , np ) vmnew = f + parmu * resmax trured = vmold - vmnew if ( parmu == 0.0_wp . and . f == datmat ( mp , np )) then prerem = prerec trured = datmat ( mpp , np ) - resmax end if ! !     Begin the operations that decide whether x(*) should replace one of the !     vertices of the current simplex, the change being mandatory if TRURED is !     positive. Firstly, JDROP is set to the index of the vertex that is to be !     replaced. ! ratio = 0.0_wp if ( trured <= 0.0_wp ) ratio = 1.0_wp jdrop = 0 do j = 1 , n temp = 0.0_wp do i = 1 , n temp = temp + simi ( j , i ) * dx ( i ) end do temp = abs ( temp ) if ( temp > ratio ) then jdrop = j ratio = temp end if sigbar ( j ) = temp * vsig ( j ) end do ! !     Calculate the value of ell. ! edgmax = delta * rho l = 0 do j = 1 , n if ( sigbar ( j ) >= parsig . or . sigbar ( j ) >= vsig ( j )) then temp = veta ( j ) if ( trured > 0.0_wp ) then temp = 0.0_wp do i = 1 , n temp = temp + ( dx ( i ) - sim ( i , j )) ** 2 end do temp = sqrt ( temp ) end if if ( temp > edgmax ) then l = j edgmax = temp end if end if end do if ( l > 0 ) jdrop = l if ( jdrop == 0 ) go to 550 ! !     Revise the simplex by updating the elements of SIM, SIMI and DATMAT. ! temp = 0.0_wp do i = 1 , n sim ( i , jdrop ) = dx ( i ) temp = temp + simi ( jdrop , i ) * dx ( i ) end do do i = 1 , n simi ( jdrop , i ) = simi ( jdrop , i ) / temp end do do j = 1 , n if ( j /= jdrop ) then temp = 0.0_wp do i = 1 , n temp = temp + simi ( j , i ) * dx ( i ) end do do i = 1 , n simi ( j , i ) = simi ( j , i ) - temp * simi ( jdrop , i ) end do end if end do do k = 1 , mpp datmat ( k , jdrop ) = con ( k ) end do ! !     Branch back for further iterations with the current RHO. ! if ( trured > 0.0_wp . and . trured >= 0.1_wp * prerem ) go to 140 550 if ( iflag == 0 ) then ibrnch = 0 go to 140 end if ! !     Otherwise reduce RHO if it is not at its least value and reset PARMU. ! if ( rho > rhoend ) then rho = 0.5_wp * rho if ( rho <= 1.5_wp * rhoend ) rho = rhoend if ( parmu > 0.0_wp ) then denom = 0.0_wp do k = 1 , mp cmin = datmat ( k , np ) cmax = cmin do i = 1 , n cmin = min ( cmin , datmat ( k , i )) cmax = max ( cmax , datmat ( k , i )) end do if ( k <= m . and . cmin < 0.5_wp * cmax ) then temp = max ( cmax , 0.0_wp ) - cmin if ( denom <= 0.0_wp ) then denom = temp else denom = min ( denom , temp ) end if end if end do if ( denom == 0.0_wp ) then parmu = 0.0_wp else if ( cmax - cmin < parmu * denom ) then parmu = ( cmax - cmin ) / denom end if end if if ( iprint >= 2 ) print 580 , rho , parmu 580 format ( / 3 x , 'Reduction in RHO to' , 1 pe13 . 6 , '  and PARMU =' , 1 pe13 . 6 ) if ( iprint == 2 ) then print 70 , nfvals , datmat ( mp , np ), datmat ( mpp , np ), ( sim ( i , np ), i = 1 , & & iptem ) if ( iptem < n ) print 80 , ( x ( i ), i = iptemp , n ) end if go to 140 end if ! !     Return the best calculated values of the variables. ! if ( iprint >= 1 ) print 590 590 format ( / 3 x , 'Normal return from subroutine COBYLA' ) if ( ifull == 1 ) go to 620 600 do i = 1 , n x ( i ) = sim ( i , np ) end do f = datmat ( mp , np ) resmax = datmat ( mpp , np ) 620 if ( iprint >= 1 ) then print 70 , nfvals , f , resmax , ( x ( i ), i = 1 , iptem ) if ( iptem < n ) print 80 , ( x ( i ), i = iptemp , n ) end if maxfun = nfvals end subroutine cobylb","tags":"","loc":"proc/cobylb.html"},{"title":"trstlp – PowellOpt","text":"private  subroutine trstlp(n, m, a, b, rho, dx, ifull, iact, z, zdota, vmultc, sdirn, dxnew, vmultd) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: a real :: b real :: rho real :: dx integer :: ifull integer :: iact real :: z real :: zdota real :: vmultc real :: sdirn real :: dxnew real :: vmultd Called by proc~~trstlp~~CalledByGraph proc~trstlp trstlp proc~cobylb cobylb proc~cobylb->proc~trstlp proc~cobyla cobyla proc~cobyla->proc~cobylb proc~cobyla_test cobyla_test proc~cobyla_test->proc~cobyla Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine trstlp ( n , m , a , b , rho , dx , ifull , iact , z , zdota , vmultc , sdirn , dxnew , & vmultd ) implicit real ( wp ) ( a - h , o - z ) dimension a ( n , * ), b ( * ), dx ( * ), iact ( * ), z ( n , * ), zdota ( * ), vmultc ( * ), & sdirn ( * ), dxnew ( * ), vmultd ( * ) ! !     This subroutine calculates an N-component vector DX by applying the !     following two stages. In the first stage, DX is set to the shortest !     vector that minimizes the greatest violation of the constraints !       A(1,K)*DX(1)+A(2,K)*DX(2)+...+A(N,K)*DX(N) .GE. B(K), K=2,3,...,M, !     subject to the Euclidean length of DX being at most RHO. If its length is !     strictly less than RHO, then we use the resultant freedom in DX to !     minimize the objective function !              -A(1,M+1)*DX(1)-A(2,M+1)*DX(2)-...-A(N,M+1)*DX(N) !     subject to no increase in any greatest constraint violation. This !     notation allows the gradient of the objective function to be regarded as !     the gradient of a constraint. Therefore the two stages are distinguished !     by MCON .EQ. M and MCON .GT. M respectively. It is possible that a !     degeneracy may prevent DX from attaining the target length RHO. Then the !     value IFULL=0 would be set, but usually IFULL=1 on return. ! !     In general NACT is the number of constraints in the active set and !     IACT(1),...,IACT(NACT) are their indices, while the remainder of IACT !     contains a permutation of the remaining constraint indices. Further, Z is !     an orthogonal matrix whose first NACT columns can be regarded as the !     result of Gram-Schmidt applied to the active constraint gradients. For !     J=1,2,...,NACT, the number ZDOTA(J) is the scalar product of the J-th !     column of Z with the gradient of the J-th active constraint. DX is the !     current vector of variables and here the residuals of the active !     constraints should be zero. Further, the active constraints have !     nonnegative Lagrange multipliers that are held at the beginning of !     VMULTC. The remainder of this vector holds the residuals of the inactive !     constraints at DX, the ordering of the components of VMULTC being in !     agreement with the permutation of the indices of the constraints that is !     in IACT. All these residuals are nonnegative, which is achieved by the !     shift RESMAX that makes the least residual zero. ! !     Initialize Z and some other variables. The value of RESMAX will be !     appropriate to DX=0, while ICON will be the index of a most violated !     constraint if RESMAX is positive. Usually during the first stage the !     vector SDIRN gives a search direction that reduces all the active !     constraint violations by one simultaneously. ! ifull = 1 mcon = m nact = 0 resmax = 0.0_wp do i = 1 , n do j = 1 , n z ( i , j ) = 0.0_wp end do z ( i , i ) = 1.0_wp dx ( i ) = 0.0_wp end do if ( m >= 1 ) then do k = 1 , m if ( b ( k ) > resmax ) then resmax = b ( k ) icon = k end if end do do k = 1 , m iact ( k ) = k vmultc ( k ) = resmax - b ( k ) end do end if if ( resmax == 0.0_wp ) go to 480 do i = 1 , n sdirn ( i ) = 0.0_wp end do ! !     End the current stage of the calculation if 3 consecutive iterations !     have either failed to reduce the best calculated value of the objective !     function or to increase the number of active constraints since the best !     value was calculated. This strategy prevents cycling, but there is a !     remote possibility that it will cause premature termination. ! 60 optold = 0.0_wp icount = 0 70 if ( mcon == m ) then optnew = resmax else optnew = 0.0_wp do i = 1 , n optnew = optnew - dx ( i ) * a ( i , mcon ) end do end if if ( icount == 0 . or . optnew < optold ) then optold = optnew nactx = nact icount = 3 else if ( nact > nactx ) then nactx = nact icount = 3 else icount = icount - 1 if ( icount == 0 ) go to 490 end if ! !     If ICON exceeds NACT, then we add the constraint with index IACT(ICON) to !     the active set. Apply Givens rotations so that the last N-NACT-1 columns !     of Z are orthogonal to the gradient of the new constraint, a scalar !     product being set to zero if its nonzero value could be due to computer !     rounding errors. The array DXNEW is used for working space. ! if ( icon <= nact ) go to 260 kk = iact ( icon ) do i = 1 , n dxnew ( i ) = a ( i , kk ) end do tot = 0.0_wp k = n 100 if ( k > nact ) then sp = 0.0_wp spabs = 0.0_wp do i = 1 , n temp = z ( i , k ) * dxnew ( i ) sp = sp + temp spabs = spabs + abs ( temp ) end do acca = spabs + 0.1_wp * abs ( sp ) accb = spabs + 0.2_wp * abs ( sp ) if ( spabs >= acca . or . acca >= accb ) sp = 0.0_wp if ( tot == 0.0_wp ) then tot = sp else kp = k + 1 temp = sqrt ( sp * sp + tot * tot ) alpha = sp / temp beta = tot / temp tot = temp do i = 1 , n temp = alpha * z ( i , k ) + beta * z ( i , kp ) z ( i , kp ) = alpha * z ( i , kp ) - beta * z ( i , k ) z ( i , k ) = temp end do end if k = k - 1 go to 100 end if ! !     Add the new constraint if this can be done without a deletion from the !     active set. ! if ( tot /= 0.0_wp ) then nact = nact + 1 zdota ( nact ) = tot vmultc ( icon ) = vmultc ( nact ) vmultc ( nact ) = 0.0_wp go to 210 end if ! !     The next instruction is reached if a deletion has to be made from the !     active set in order to make room for the new active constraint, because !     the new constraint gradient is a linear combination of the gradients of !     the old active constraints. Set the elements of VMULTD to the multipliers !     of the linear combination. Further, set IOUT to the index of the !     constraint to be deleted, but branch if no suitable index can be found. ! ratio = - 1.0_wp k = nact 130 zdotv = 0.0_wp zdvabs = 0.0_wp do i = 1 , n temp = z ( i , k ) * dxnew ( i ) zdotv = zdotv + temp zdvabs = zdvabs + abs ( temp ) end do acca = zdvabs + 0.1_wp * abs ( zdotv ) accb = zdvabs + 0.2_wp * abs ( zdotv ) if ( zdvabs < acca . and . acca < accb ) then temp = zdotv / zdota ( k ) if ( temp > 0.0_wp . and . iact ( k ) <= m ) then tempa = vmultc ( k ) / temp if ( ratio < 0.0_wp . or . tempa < ratio ) then ratio = tempa iout = k end if end if if ( k >= 2 ) then kw = iact ( k ) do i = 1 , n dxnew ( i ) = dxnew ( i ) - temp * a ( i , kw ) end do end if vmultd ( k ) = temp else vmultd ( k ) = 0.0_wp end if k = k - 1 if ( k > 0 ) go to 130 if ( ratio < 0.0_wp ) go to 490 ! !     Revise the Lagrange multipliers and reorder the active constraints so !     that the one to be replaced is at the end of the list. Also calculate the !     new value of ZDOTA(NACT) and branch if it is not acceptable. ! do k = 1 , nact vmultc ( k ) = max ( 0.0_wp , vmultc ( k ) - ratio * vmultd ( k )) end do if ( icon < nact ) then isave = iact ( icon ) vsave = vmultc ( icon ) k = icon 170 kp = k + 1 kw = iact ( kp ) sp = 0.0_wp do i = 1 , n sp = sp + z ( i , k ) * a ( i , kw ) end do temp = sqrt ( sp * sp + zdota ( kp ) ** 2 ) alpha = zdota ( kp ) / temp beta = sp / temp zdota ( kp ) = alpha * zdota ( k ) zdota ( k ) = temp do i = 1 , n temp = alpha * z ( i , kp ) + beta * z ( i , k ) z ( i , kp ) = alpha * z ( i , k ) - beta * z ( i , kp ) z ( i , k ) = temp end do iact ( k ) = kw vmultc ( k ) = vmultc ( kp ) k = kp if ( k < nact ) go to 170 iact ( k ) = isave vmultc ( k ) = vsave end if temp = 0.0_wp do i = 1 , n temp = temp + z ( i , nact ) * a ( i , kk ) end do if ( temp == 0.0_wp ) go to 490 zdota ( nact ) = temp vmultc ( icon ) = 0.0_wp vmultc ( nact ) = ratio ! !     Update IACT and ensure that the objective function continues to be !     treated as the last active constraint when MCON>M. ! 210 iact ( icon ) = iact ( nact ) iact ( nact ) = kk if ( mcon > m . and . kk /= mcon ) then k = nact - 1 sp = 0.0_wp do i = 1 , n sp = sp + z ( i , k ) * a ( i , kk ) end do temp = sqrt ( sp * sp + zdota ( nact ) ** 2 ) alpha = zdota ( nact ) / temp beta = sp / temp zdota ( nact ) = alpha * zdota ( k ) zdota ( k ) = temp do i = 1 , n temp = alpha * z ( i , nact ) + beta * z ( i , k ) z ( i , nact ) = alpha * z ( i , k ) - beta * z ( i , nact ) z ( i , k ) = temp end do iact ( nact ) = iact ( k ) iact ( k ) = kk temp = vmultc ( k ) vmultc ( k ) = vmultc ( nact ) vmultc ( nact ) = temp end if ! !     If stage one is in progress, then set SDIRN to the direction of the next !     change to the current vector of variables. ! if ( mcon > m ) go to 320 kk = iact ( nact ) temp = 0.0_wp do i = 1 , n temp = temp + sdirn ( i ) * a ( i , kk ) end do temp = temp - 1.0_wp temp = temp / zdota ( nact ) do i = 1 , n sdirn ( i ) = sdirn ( i ) - temp * z ( i , nact ) end do go to 340 ! !     Delete the constraint that has the index IACT(ICON) from the active set. ! 260 if ( icon < nact ) then isave = iact ( icon ) vsave = vmultc ( icon ) k = icon 270 kp = k + 1 kk = iact ( kp ) sp = 0.0_wp do i = 1 , n sp = sp + z ( i , k ) * a ( i , kk ) end do temp = sqrt ( sp * sp + zdota ( kp ) ** 2 ) alpha = zdota ( kp ) / temp beta = sp / temp zdota ( kp ) = alpha * zdota ( k ) zdota ( k ) = temp do i = 1 , n temp = alpha * z ( i , kp ) + beta * z ( i , k ) z ( i , kp ) = alpha * z ( i , k ) - beta * z ( i , kp ) z ( i , k ) = temp end do iact ( k ) = kk vmultc ( k ) = vmultc ( kp ) k = kp if ( k < nact ) go to 270 iact ( k ) = isave vmultc ( k ) = vsave end if nact = nact - 1 ! !     If stage one is in progress, then set SDIRN to the direction of the next !     change to the current vector of variables. ! if ( mcon > m ) go to 320 temp = 0.0_wp do i = 1 , n temp = temp + sdirn ( i ) * z ( i , nact + 1 ) end do do i = 1 , n sdirn ( i ) = sdirn ( i ) - temp * z ( i , nact + 1 ) end do go to 340 ! !     Pick the next search direction of stage two. ! 320 temp = 1.0_wp / zdota ( nact ) do i = 1 , n sdirn ( i ) = temp * z ( i , nact ) end do ! !     Calculate the step to the boundary of the trust region or take the step !     that reduces RESMAX to zero. The two statements below that include the !     factor 1.0E-6 prevent some harmless underflows that occurred in a test !     calculation. Further, we skip the step if it could be zero within a !     reasonable tolerance for computer rounding errors. ! 340 dd = rho * rho sd = 0.0_wp ss = 0.0_wp do i = 1 , n if ( abs ( dx ( i )) >= 1.0e-6_wp * rho ) dd = dd - dx ( i ) ** 2 sd = sd + dx ( i ) * sdirn ( i ) ss = ss + sdirn ( i ) ** 2 end do if ( dd <= 0.0_wp ) go to 490 temp = sqrt ( ss * dd ) if ( abs ( sd ) >= 1.0e-6_wp * temp ) temp = sqrt ( ss * dd + sd * sd ) stpful = dd / ( temp + sd ) step = stpful if ( mcon == m ) then acca = step + 0.1_wp * resmax accb = step + 0.2_wp * resmax if ( step >= acca . or . acca >= accb ) go to 480 step = min ( step , resmax ) end if ! !     Set DXNEW to the new variables if STEP is the steplength, and reduce !     RESMAX to the corresponding maximum residual if stage one is being done. !     Because DXNEW will be changed during the calculation of some Lagrange !     multipliers, it will be restored to the following value later. ! do i = 1 , n dxnew ( i ) = dx ( i ) + step * sdirn ( i ) end do if ( mcon == m ) then resold = resmax resmax = 0.0_wp do k = 1 , nact kk = iact ( k ) temp = b ( kk ) do i = 1 , n temp = temp - a ( i , kk ) * dxnew ( i ) end do resmax = max ( resmax , temp ) end do end if ! !     Set VMULTD to the VMULTC vector that would occur if DX became DXNEW. A !     device is included to force VMULTD(K)=0.0 if deviations from this value !     can be attributed to computer rounding errors. First calculate the new !     Lagrange multipliers. ! k = nact 390 zdotw = 0.0_wp zdwabs = 0.0_wp do i = 1 , n temp = z ( i , k ) * dxnew ( i ) zdotw = zdotw + temp zdwabs = zdwabs + abs ( temp ) end do acca = zdwabs + 0.1_wp * abs ( zdotw ) accb = zdwabs + 0.2_wp * abs ( zdotw ) if ( zdwabs >= acca . or . acca >= accb ) zdotw = 0.0_wp vmultd ( k ) = zdotw / zdota ( k ) if ( k >= 2 ) then kk = iact ( k ) do i = 1 , n dxnew ( i ) = dxnew ( i ) - vmultd ( k ) * a ( i , kk ) end do k = k - 1 go to 390 end if if ( mcon > m ) vmultd ( nact ) = max ( 0.0_wp , vmultd ( nact )) ! !     Complete VMULTC by finding the new constraint residuals. ! do i = 1 , n dxnew ( i ) = dx ( i ) + step * sdirn ( i ) end do if ( mcon > nact ) then kl = nact + 1 do k = kl , mcon kk = iact ( k ) sum = resmax - b ( kk ) sumabs = resmax + abs ( b ( kk )) do i = 1 , n temp = a ( i , kk ) * dxnew ( i ) sum = sum + temp sumabs = sumabs + abs ( temp ) end do acca = sumabs + 0.1_wp * abs ( sum ) accb = sumabs + 0.2_wp * abs ( sum ) if ( sumabs >= acca . or . acca >= accb ) sum = 0.0_wp vmultd ( k ) = sum end do end if ! !     Calculate the fraction of the step from DX to DXNEW that will be taken. ! ratio = 1.0_wp icon = 0 do k = 1 , mcon if ( vmultd ( k ) < 0.0_wp ) then temp = vmultc ( k ) / ( vmultc ( k ) - vmultd ( k )) if ( temp < ratio ) then ratio = temp icon = k end if end if end do ! !     Update DX, VMULTC and RESMAX. ! temp = 1.0_wp - ratio do i = 1 , n dx ( i ) = temp * dx ( i ) + ratio * dxnew ( i ) end do do k = 1 , mcon vmultc ( k ) = max ( 0.0_wp , temp * vmultc ( k ) + ratio * vmultd ( k )) end do if ( mcon == m ) resmax = resold + ratio * ( resmax - resold ) ! !     If the full step is not acceptable then begin another iteration. !     Otherwise switch to stage two or end the calculation. ! if ( icon > 0 ) go to 70 if ( step == stpful ) return 480 mcon = m + 1 icon = mcon iact ( mcon ) = mcon vmultc ( mcon ) = 0.0_wp go to 60 ! !     We employ any freedom that may be available to reduce the objective !     function before returning a DX whose length is less than RHO. ! 490 if ( mcon == m ) go to 480 ifull = 0 end subroutine trstlp","tags":"","loc":"proc/trstlp.html"},{"title":"cobyla_test – PowellOpt","text":"public  subroutine cobyla_test() Test routine for cobyla . From: Report DAMTP 1992/NA5. Arguments None Calls proc~~cobyla_test~~CallsGraph proc~cobyla_test cobyla_test proc~cobyla cobyla proc~cobyla_test->proc~cobyla proc~cobylb cobylb proc~cobyla->proc~cobylb proc~trstlp trstlp proc~cobylb->proc~trstlp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cobyla_test () implicit none real ( wp ), dimension ( 10 ) :: x , xopt integer :: nprob , n , m , i , icase , iprint , maxfun real ( wp ) :: rhobeg , rhoend , temp , tempa , tempb , tempc , tempd do nprob = 1 , 10 if ( nprob == 1 ) then ! !     minimization of a simple quadratic function of two variables. ! print 10 10 format ( / 7 x , 'Output from test problem 1 (Simple quadratic)' ) n = 2 m = 0 xopt ( 1 ) = - 1.0_wp xopt ( 2 ) = 0.0_wp else if ( nprob == 2 ) then ! !     Easy two dimensional minimization in unit circle. ! print 20 20 format ( / 7 x , 'Output from test problem 2 (2D unit circle ' ,& 'calculation)' ) n = 2 m = 1 xopt ( 1 ) = sqrt ( 0.5_wp ) xopt ( 2 ) = - xopt ( 1 ) else if ( nprob == 3 ) then ! !     Easy three dimensional minimization in ellipsoid. ! print 30 30 format ( / 7 x , 'Output from test problem 3 (3D ellipsoid ' ,& 'calculation)' ) n = 3 m = 1 xopt ( 1 ) = 1.0_wp / sqrt ( 3.0_wp ) xopt ( 2 ) = 1.0_wp / sqrt ( 6.0_wp ) xopt ( 3 ) = - 1.0_wp / 3.0_wp else if ( nprob == 4 ) then ! !     Weak version of Rosenbrock's problem. ! print 40 40 format ( / 7 x , 'Output from test problem 4 (Weak Rosenbrock)' ) n = 2 m = 0 xopt ( 1 ) = - 1.0_wp xopt ( 2 ) = 1.0_wp else if ( nprob == 5 ) then ! !     Intermediate version of Rosenbrock's problem. ! print 50 50 format ( / 7 x , 'Output from test problem 5 (Intermediate ' , 'Rosenbrock)' ) n = 2 m = 0 xopt ( 1 ) = - 1.0_wp xopt ( 2 ) = 1.0_wp else if ( nprob == 6 ) then ! !     This problem is taken from Fletcher's book Practical Methods of !     Optimization and has the equation number (9.1.15). ! print 60 60 format ( / 7 x , 'Output from test problem 6 (Equation ' ,& '(9.1.15) in Fletcher)' ) n = 2 m = 2 xopt ( 1 ) = sqrt ( 0.5_wp ) xopt ( 2 ) = xopt ( 1 ) else if ( nprob == 7 ) then ! !     This problem is taken from Fletcher's book Practical Methods of !     Optimization and has the equation number (14.4.2). ! print 70 70 format ( / 7 x , 'Output from test problem 7 (Equation ' ,& '(14.4.2) in Fletcher)' ) n = 3 m = 3 xopt ( 1 ) = 0.0_wp xopt ( 2 ) = - 3.0_wp xopt ( 3 ) = - 3.0_wp else if ( nprob == 8 ) then ! !     This problem is taken from page 66 of Hock and Schittkowski's book Test !     Examples for Nonlinear Programming Codes. It is their test problem Number !     43, and has the name Rosen-Suzuki. ! print 80 80 format ( / 7 x , 'Output from test problem 8 (Rosen-Suzuki)' ) n = 4 m = 3 xopt ( 1 ) = 0.0_wp xopt ( 2 ) = 1.0_wp xopt ( 3 ) = 2.0_wp xopt ( 4 ) = - 1.0_wp else if ( nprob == 9 ) then ! !     This problem is taken from page 111 of Hock and Schittkowski's !     book Test Examples for Nonlinear Programming Codes. It is their !     test problem Number 100. ! print 90 90 format ( / 7 x , 'Output from test problem 9 (Hock and ' ,& 'Schittkowski 100)' ) n = 7 m = 4 xopt ( 1 ) = 2.330499_wp xopt ( 2 ) = 1.951372_wp xopt ( 3 ) = - 0.4775414_wp xopt ( 4 ) = 4.365726_wp xopt ( 5 ) = - 0.624487_wp xopt ( 6 ) = 1.038131_wp xopt ( 7 ) = 1.594227_wp else if ( nprob == 10 ) then ! !     This problem is taken from page 415 of Luenberger's book Applied !     Nonlinear Programming. It is to maximize the area of a hexagon of !     unit diameter. ! print 100 100 format ( / 7 x , 'Output from test problem 10 (Hexagon area)' ) n = 9 m = 14 end if do icase = 1 , 2 do i = 1 , n x ( i ) = 1.0_wp end do rhobeg = 0.5_wp rhoend = 0.001_wp if ( icase == 2 ) rhoend = 0.0001_wp iprint = 1 maxfun = 2000 call cobyla ( n , m , x , rhobeg , rhoend , iprint , maxfun , calcfc ) if ( nprob == 10 ) then tempa = x ( 1 ) + x ( 3 ) + x ( 5 ) + x ( 7 ) tempb = x ( 2 ) + x ( 4 ) + x ( 6 ) + x ( 8 ) tempc = 0.5_wp / sqrt ( tempa * tempa + tempb * tempb ) tempd = tempc * sqrt ( 3.0_wp ) xopt ( 1 ) = tempd * tempa + tempc * tempb xopt ( 2 ) = tempd * tempb - tempc * tempa xopt ( 3 ) = tempd * tempa - tempc * tempb xopt ( 4 ) = tempd * tempb + tempc * tempa do i = 1 , 4 xopt ( i + 4 ) = xopt ( i ) end do xopt ( 9 ) = 0.0_wp end if temp = 0.0_wp do i = 1 , n temp = temp + ( x ( i ) - xopt ( i )) ** 2 end do print 150 , sqrt ( temp ) 150 format ( / 5 x , 'Least squares error in variables =' , 1 pe16 . 6 ) end do print 170 170 format ( 2 x , '----------------------------------------------' ,& '--------------------' ) end do contains subroutine calcfc ( n , m , x , f , con ) implicit none integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( * ), intent ( in ) :: x real ( wp ), intent ( out ) :: f real ( wp ), dimension ( * ), intent ( out ) :: con if ( nprob == 1 ) then ! !     Test problem 1 (Simple quadratic) ! f = 1 0.0_wp * ( x ( 1 ) + 1.0_wp ) ** 2 + x ( 2 ) ** 2 else if ( nprob == 2 ) then ! !    Test problem 2 (2D unit circle calculation) ! f = x ( 1 ) * x ( 2 ) con ( 1 ) = 1.0_wp - x ( 1 ) ** 2 - x ( 2 ) ** 2 else if ( nprob == 3 ) then ! !     Test problem 3 (3D ellipsoid calculation) ! f = x ( 1 ) * x ( 2 ) * x ( 3 ) con ( 1 ) = 1.0_wp - x ( 1 ) ** 2 - 2.0_wp * x ( 2 ) ** 2 - 3.0_wp * x ( 3 ) ** 2 else if ( nprob == 4 ) then ! !     Test problem 4 (Weak Rosenbrock) ! f = ( x ( 1 ) ** 2 - x ( 2 )) ** 2 + ( 1.0_wp + x ( 1 )) ** 2 else if ( nprob == 5 ) then ! !     Test problem 5 (Intermediate Rosenbrock) ! f = 1 0.0_wp * ( x ( 1 ) ** 2 - x ( 2 )) ** 2 + ( 1.0_wp + x ( 1 )) ** 2 else if ( nprob == 6 ) then ! !     Test problem 6 (Equation (9.1.15) in Fletcher's book) ! f = - x ( 1 ) - x ( 2 ) con ( 1 ) = x ( 2 ) - x ( 1 ) ** 2 con ( 2 ) = 1.0_wp - x ( 1 ) ** 2 - x ( 2 ) ** 2 else if ( nprob == 7 ) then ! !     Test problem 7 (Equation (14.4.2) in Fletcher's book) ! f = x ( 3 ) con ( 1 ) = 5.0_wp * x ( 1 ) - x ( 2 ) + x ( 3 ) con ( 2 ) = x ( 3 ) - x ( 1 ) ** 2 - x ( 2 ) ** 2 - 4.0_wp * x ( 2 ) con ( 3 ) = x ( 3 ) - 5.0_wp * x ( 1 ) - x ( 2 ) else if ( nprob == 8 ) then ! !     Test problem 8 (Rosen-Suzuki) ! f = x ( 1 ) ** 2 + x ( 2 ) ** 2 + 2.0_wp * x ( 3 ) ** 2 + x ( 4 ) ** 2 - 5.0_wp * & & x ( 1 ) - 5.0_wp * x ( 2 ) - 2 1.0_wp * x ( 3 ) + 7.0_wp * x ( 4 ) con ( 1 ) = 8.0_wp - x ( 1 ) ** 2 - x ( 2 ) ** 2 - x ( 3 ) ** 2 - x ( 4 ) ** 2 - x & & ( 1 ) + x ( 2 ) - x ( 3 ) + x ( 4 ) con ( 2 ) = 1 0.0_wp - x ( 1 ) ** 2 - 2.0_wp * x ( 2 ) ** 2 - x ( 3 ) ** 2 - & & 2.0_wp * x ( 4 ) ** 2 + x ( 1 ) + x ( 4 ) con ( 3 ) = 5.0_wp - 2.0_wp * x ( 1 ) ** 2 - x ( 2 ) ** 2 - x ( 3 ) ** 2 - 2.0_wp & & * x ( 1 ) + x ( 2 ) + x ( 4 ) else if ( nprob == 9 ) then ! !     Test problem 9 (Hock and Schittkowski 100) ! f = ( x ( 1 ) - 1 0.0_wp ) ** 2 + 5.0_wp * ( x ( 2 ) - 1 2.0_wp ) ** 2 + x ( 3 ) ** 4 + & & 3.0_wp * ( x ( 4 ) - 1 1.0_wp ) ** 2 + 1 0.0_wp * x ( 5 ) ** 6 + 7.0_wp * x ( 6 ) ** & & 2 + x ( 7 ) ** 4 - 4.0_wp * x ( 6 ) * x ( 7 ) - 1 0.0_wp * x ( 6 ) - 8.0_wp * x & & ( 7 ) con ( 1 ) = 12 7.0_wp - 2.0_wp * x ( 1 ) ** 2 - 3.0_wp * x ( 2 ) ** 4 - x ( 3 ) - & & 4.0_wp * x ( 4 ) ** 2 - 5.0_wp * x ( 5 ) con ( 2 ) = 28 2.0_wp - 7.0_wp * x ( 1 ) - 3.0_wp * x ( 2 ) - 1 0.0_wp * x ( 3 ) ** & & 2 - x ( 4 ) + x ( 5 ) con ( 3 ) = 19 6.0_wp - 2 3.0_wp * x ( 1 ) - x ( 2 ) ** 2 - 6.0_wp * x ( 6 ) ** 2 + & & 8.0_wp * x ( 7 ) con ( 4 ) = - 4.0_wp * x ( 1 ) ** 2 - x ( 2 ) ** 2 + 3.0_wp * x ( 1 ) * x ( 2 ) - & & 2.0_wp * x ( 3 ) ** 2 - 5.0_wp * x ( 6 ) + 1 1.0_wp * x ( 7 ) else if ( nprob == 10 ) then ! !     Test problem 10 (Hexagon area) ! f = - 0.5_wp * & ( x ( 1 ) * x ( 4 ) - x ( 2 ) * x ( 3 ) + x ( 3 ) * x ( 9 ) - x ( 5 ) * x ( 9 ) + x ( 5 ) * x ( 8 ) - x ( 6 ) * x ( 7 )) con ( 1 ) = 1.0_wp - x ( 3 ) ** 2 - x ( 4 ) ** 2 con ( 2 ) = 1.0_wp - x ( 9 ) ** 2 con ( 3 ) = 1.0_wp - x ( 5 ) ** 2 - x ( 6 ) ** 2 con ( 4 ) = 1.0_wp - x ( 1 ) ** 2 - ( x ( 2 ) - x ( 9 )) ** 2 con ( 5 ) = 1.0_wp - ( x ( 1 ) - x ( 5 )) ** 2 - ( x ( 2 ) - x ( 6 )) ** 2 con ( 6 ) = 1.0_wp - ( x ( 1 ) - x ( 7 )) ** 2 - ( x ( 2 ) - x ( 8 )) ** 2 con ( 7 ) = 1.0_wp - ( x ( 3 ) - x ( 5 )) ** 2 - ( x ( 4 ) - x ( 6 )) ** 2 con ( 8 ) = 1.0_wp - ( x ( 3 ) - x ( 7 )) ** 2 - ( x ( 4 ) - x ( 8 )) ** 2 con ( 9 ) = 1.0_wp - x ( 7 ) ** 2 - ( x ( 8 ) - x ( 9 )) ** 2 con ( 10 ) = x ( 1 ) * x ( 4 ) - x ( 2 ) * x ( 3 ) con ( 11 ) = x ( 3 ) * x ( 9 ) con ( 12 ) = - x ( 5 ) * x ( 9 ) con ( 13 ) = x ( 5 ) * x ( 8 ) - x ( 6 ) * x ( 7 ) con ( 14 ) = x ( 9 ) end if end subroutine calcfc end subroutine cobyla_test","tags":"","loc":"proc/cobyla_test.html"},{"title":"lincoa – PowellOpt","text":"public  subroutine lincoa(n, npt, m, a, ia, b, x, rhobeg, rhoend, iprint, maxfun, calfun) This subroutine seeks the least value of a function of many variables,\n  subject to general linear inequality constraints, by a trust region\n  method that forms quadratic models by interpolation. LINCOA solves the following optimization problem: Minimize F(X(1),X(2),...X(N)) subject to:\n   A * X <= B Usually there\n  is much freedom in each new model after satisfying the interpolation\n  conditions, which is taken up by minimizing the Frobenius norm of\n  the change to the second derivative matrix of the model. One new\n  function value is calculated on each iteration, usually at a point\n  where the current model predicts a reduction in the least value so\n  far of the objective function subject to the linear constraints.\n  Alternatively, a new vector of variables may be chosen to replace\n  an interpolation point that may be too far away for reliability, and\n  then the new point does not have to satisfy the linear constraints. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the number of variables. must be at least 2. integer, intent(in) :: npt the number of interpolation conditions, which is\nrequired to be in the interval [N+2,(N+1)(N+2)/2]. Typical choices\nof the author are NPT=N+6 and NPT=2*N+1. Larger values tend to be\nhighly inefficent when the number of variables is substantial, due\nto the amount of work and extra difficulty of adjusting more points. integer, intent(in) :: m the number of linear inequality constraints. real(kind=wp), intent(in), dimension(ia,*) :: a a matrix whose columns are the constraint gradients, which are\nrequired to be nonzero. integer, intent(in) :: ia the first dimension of the array A, which must be at least N. real(kind=wp), intent(in), dimension(*) :: b the vector of right hand sides of the constraints, the J-th\nconstraint being that the scalar product of A(.,J) with X(.) is at\nmost B(J). The initial vector X(.) is made feasible by increasing\nthe value of B(J) if necessary. real(kind=wp), intent(inout), dimension(*) :: x the vector of variables. Initial values of X(1),X(2),...,X(N)\nmust be supplied. If they do not satisfy the constraints, then B\nis increased as mentioned above. X contains on return the variables\nthat have given the least calculated F subject to the constraints. real(kind=wp), intent(in) :: rhobeg RHOBEG and RHOEND must be set to the initial and final values of a\ntrust region radius, so both must be positive with RHOEND<=RHOBEG.\nTypically, RHOBEG should be about one tenth of the greatest expected\nchange to a variable, and RHOEND should indicate the accuracy that\nis required in the final values of the variables. real(kind=wp), intent(in) :: rhoend RHOBEG and RHOEND must be set to the initial and final values of a\ntrust region radius, so both must be positive with RHOEND<=RHOBEG.\nTypically, RHOBEG should be about one tenth of the greatest expected\nchange to a variable, and RHOEND should indicate the accuracy that\nis required in the final values of the variables. integer, intent(in) :: iprint The value of IPRINT should be set to 0, 1, 2 or 3, which controls the\namount of printing. Specifically, there is no output if IPRINT=0 and\nthere is output only at the return if IPRINT=1. Otherwise, the best\nfeasible vector of variables so far and the corresponding value of\nthe objective function are printed whenever RHO is reduced, where\nRHO is the current lower bound on the trust region radius. Further,\neach new value of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun an upper bound on the number of calls of CALFUN,\nits value being at least NPT+1. procedure( func ) :: calfun It must set\nF to the value of the objective function for the variables X(1),\nX(2),...,X(N). The value of the argument F is positive when CALFUN\nis called if and only if the current X satisfies the constraints Calls proc~~lincoa~~CallsGraph proc~lincoa lincoa proc~lincob lincob proc~lincoa->proc~lincob proc~prelim prelim proc~lincob->proc~prelim proc~qmstep qmstep proc~lincob->proc~qmstep proc~trstep trstep proc~lincob->proc~trstep proc~update~2 update proc~lincob->proc~update~2 proc~prelim->proc~update~2 proc~getact getact proc~trstep->proc~getact Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lincoa~~CalledByGraph proc~lincoa lincoa proc~lincoa_test lincoa_test proc~lincoa_test->proc~lincoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lincoa ( n , npt , m , a , ia , b , x , rhobeg , rhoend , iprint , maxfun , calfun ) implicit none integer , intent ( in ) :: n !! the number of variables. must be at least 2. integer , intent ( in ) :: npt !! the number of interpolation conditions, which is !! required to be in the interval [N+2,(N+1)(N+2)/2]. Typical choices !! of the author are NPT=N+6 and NPT=2*N+1. Larger values tend to be !! highly inefficent when the number of variables is substantial, due !! to the amount of work and extra difficulty of adjusting more points. integer , intent ( in ) :: m !! the number of linear inequality constraints. integer , intent ( in ) :: ia !! the first dimension of the array A, which must be at least N. real ( wp ), dimension ( ia , * ), intent ( in ) :: a !! a matrix whose columns are the constraint gradients, which are !! required to be nonzero. real ( wp ), dimension ( * ), intent ( in ) :: b !! the vector of right hand sides of the constraints, the J-th !! constraint being that the scalar product of A(.,J) with X(.) is at !! most B(J). The initial vector X(.) is made feasible by increasing !! the value of B(J) if necessary. real ( wp ), dimension ( * ), intent ( inout ) :: x !! the vector of variables. Initial values of X(1),X(2),...,X(N) !! must be supplied. If they do not satisfy the constraints, then B !! is increased as mentioned above. X contains on return the variables !! that have given the least calculated F subject to the constraints. real ( wp ), intent ( in ) :: rhobeg !! RHOBEG and RHOEND must be set to the initial and final values of a !! trust region radius, so both must be positive with RHOEND<=RHOBEG. !! Typically, RHOBEG should be about one tenth of the greatest expected !! change to a variable, and RHOEND should indicate the accuracy that !! is required in the final values of the variables. real ( wp ), intent ( in ) :: rhoend !! RHOBEG and RHOEND must be set to the initial and final values of a !! trust region radius, so both must be positive with RHOEND<=RHOBEG. !! Typically, RHOBEG should be about one tenth of the greatest expected !! change to a variable, and RHOEND should indicate the accuracy that !! is required in the final values of the variables. integer , intent ( in ) :: iprint !! The value of IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, the best !! feasible vector of variables so far and the corresponding value of !! the objective function are printed whenever RHO is reduced, where !! RHO is the current lower bound on the trust region radius. Further, !! each new value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! an upper bound on the number of calls of CALFUN, !! its value being at least NPT+1. procedure ( func ) :: calfun !! It must set !! F to the value of the objective function for the variables X(1), !! X(2),...,X(N). The value of the argument F is positive when CALFUN !! is called if and only if the current X satisfies the constraints real ( wp ), parameter :: zero = 0.0_wp real ( wp ), dimension (:), allocatable :: w integer , dimension ( n ) :: iact !to avoid type mismatch error - JW real ( wp ) :: smallx , sum , temp integer :: np , nptm , iamat , ib , iflag , i , iac , ibmat , ifv , igo , ihq , ipq , ipqw ,& iqf , irc , isp , istp , iw , ixb , ixn , ixo , ixp , ixs , irf , izmat , j , ndim !     W is an array used for working space. Its length must be at least !       M*(2+N) + NPT*(4+N+NPT) + N*(9+3*N) + MAX [ M+3*N, 2*M+N, 2*NPT ]. !       On return, W(1) is set to the final value of F, and W(2) is set to !       the total number of function evaluations plus 0.5. allocate ( w ( M * ( 2 + N ) + NPT * ( 4 + N + NPT ) + N * ( 9 + 3 * N ) + MAX ( M + 3 * N , 2 * M + N , 2 * NPT ))) ! !     Check that N, NPT and MAXFUN are acceptable. ! smallx = 1.0e-6_wp * rhoend np = n + 1 nptm = npt - np if ( n <= 1 ) then print 10 10 format ( / 4 x , 'Return from LINCOA because N is less than 2.' ) return end if if ( npt < n + 2 . or . npt > (( n + 2 ) * np ) / 2 ) then print 20 20 format ( / 4 x , 'Return from LINCOA because NPT is not in' ,& ' the required interval.' ) return end if if ( maxfun <= npt ) then print 30 30 format ( / 4 x , 'Return from LINCOA because MAXFUN is less' , ' than NPT+1.' ) return end if ! !     Normalize the constraints, and copy the resultant constraint matrix !       and right hand sides into working space, after increasing the right !       hand sides if necessary so that the starting point is feasible. ! iamat = max ( m + 3 * n , 2 * m + n , 2 * npt ) + 1 ib = iamat + m * n iflag = 0 if ( m > 0 ) then iw = iamat - 1 do j = 1 , m sum = zero temp = zero do i = 1 , n sum = sum + a ( i , j ) * x ( i ) temp = temp + a ( i , j ) ** 2 end do if ( temp == zero ) then print 50 50 format ( / 4 x , 'Return from LINCOA because the gradient of' ,& ' a constraint is zero.' ) return end if temp = sqrt ( temp ) if ( sum - b ( j ) > smallx * temp ) iflag = 1 w ( ib + j - 1 ) = max ( b ( j ), sum ) / temp do i = 1 , n iw = iw + 1 w ( iw ) = a ( i , j ) / temp end do end do end if if ( iflag == 1 ) then if ( iprint > 0 ) print 70 70 format ( / 4 x , 'LINCOA has made the initial X feasible by' ,& ' increasing part(s) of B.' ) end if ! !     Partition the working space array, so that different parts of it can be !     treated separately by the subroutine that performs the main calculation. ! ndim = npt + n ixb = ib + m ixp = ixb + n ifv = ixp + n * npt ixs = ifv + npt ixo = ixs + n igo = ixo + n ihq = igo + n ipq = ihq + ( n * np ) / 2 ibmat = ipq + npt izmat = ibmat + ndim * n istp = izmat + npt * nptm isp = istp + n ixn = isp + npt + npt iac = ixn + n irc = iac + n iqf = irc + m irf = iqf + n * n ipqw = irf + ( n * np ) / 2 ! !     The above settings provide a partition of W for subroutine LINCOB. ! call lincob ( n , npt , m , w ( iamat ), w ( ib ), x , rhobeg , rhoend , iprint , maxfun , & w ( ixb ), w ( ixp ), w ( ifv ), w ( ixs ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), & w ( ibmat ), w ( izmat ), ndim , w ( istp ), w ( isp ), w ( ixn ), iact , w ( irc ), & w ( iqf ), w ( irf ), w ( ipqw ), w , calfun ) deallocate ( w ) end subroutine lincoa","tags":"","loc":"proc/lincoa.html"},{"title":"lincob – PowellOpt","text":"private  subroutine lincob(n, npt, m, amat, b, x, rhobeg, rhoend, iprint, maxfun, xbase, xpt, fval, xsav, xopt, gopt, hq, pq, bmat, zmat, ndim, step, sp, xnew, iact, rescon, qfac, rfac, pqw, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt integer :: m real :: amat real :: b real :: x real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xsav real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: step real :: sp real :: xnew integer :: iact real :: rescon real :: qfac real :: rfac real :: pqw real :: w procedure( func ) :: calfun Calls proc~~lincob~~CallsGraph proc~lincob lincob proc~prelim prelim proc~lincob->proc~prelim proc~qmstep qmstep proc~lincob->proc~qmstep proc~trstep trstep proc~lincob->proc~trstep proc~update~2 update proc~lincob->proc~update~2 proc~prelim->proc~update~2 proc~getact getact proc~trstep->proc~getact Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lincob~~CalledByGraph proc~lincob lincob proc~lincoa lincoa proc~lincoa->proc~lincob proc~lincoa_test lincoa_test proc~lincoa_test->proc~lincoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lincob ( n , npt , m , amat , b , x , rhobeg , rhoend , iprint , maxfun , xbase , xpt , & fval , xsav , xopt , gopt , hq , pq , bmat , zmat , ndim , step , sp , xnew , & iact , rescon , qfac , rfac , pqw , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension amat ( n , * ), b ( * ), x ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xsav ( * ), & xopt ( * ), gopt ( * ), hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), & step ( * ), sp ( * ), xnew ( * ), iact ( * ), rescon ( * ), qfac ( n , * ), rfac ( * ), & pqw ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, M, X, RHOBEG, RHOEND, IPRINT and MAXFUN are !       identical to the corresponding arguments in SUBROUTINE LINCOA. !     AMAT is a matrix whose columns are the constraint gradients, scaled !       so that they have unit length. !     B contains on entry the right hand sides of the constraints, scaled !       as above, but later B is modified for variables relative to XBASE. !     XBASE holds a shift of origin that should reduce the contributions !       from rounding errors to values of the model and Lagrange functions. !     XPT contains the interpolation point coordinates relative to XBASE. !     FVAL holds the values of F at the interpolation points. !     XSAV holds the best feasible vector of variables so far, without any !       shift of origin. !     XOPT is set to XSAV-XBASE, which is the displacement from XBASE of !       the feasible vector of variables that provides the least calculated !       F so far, this vector being the current trust region centre. !     GOPT holds the gradient of the quadratic model at XSAV = XBASE+XOPT. !     HQ holds the explicit second derivatives of the quadratic model. !     PQ contains the parameters of the implicit second derivatives of the !       quadratic model. !     BMAT holds the last N columns of the big inverse matrix H. !     ZMAT holds the factorization of the leading NPT by NPT submatrix !       of H, this factorization being ZMAT times Diag(DZ) times ZMAT&#94;T, !       where the elements of DZ are plus or minus one, as specified by IDZ. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     STEP is employed for trial steps from XOPT. It is also used for working !       space when XBASE is shifted and in PRELIM. !     SP is reserved for the scalar products XOPT&#94;T XPT(K,.), K=1,2,...,NPT, !       followed by STEP&#94;T XPT(K,.), K=1,2,...,NPT. !     XNEW is the displacement from XBASE of the vector of variables for !       the current calculation of F, except that SUBROUTINE TRSTEP uses it !       for working space. !     IACT is an integer array for the indices of the active constraints. !     RESCON holds useful information about the constraint residuals. Every !       nonnegative RESCON(J) is the residual of the J-th constraint at the !       current trust region centre. Otherwise, if RESCON(J) is negative, the !       J-th constraint holds as a strict inequality at the trust region !       centre, its residual being at least |RESCON(J)|; further, the value !       of |RESCON(J)| is at least the current trust region radius DELTA. !     QFAC is the orthogonal part of the QR factorization of the matrix of !       active constraint gradients, these gradients being ordered in !       accordance with IACT. When NACT is less than N, columns are added !       to QFAC to complete an N by N orthogonal matrix, which is important !       for keeping calculated steps sufficiently close to the boundaries !       of the active constraints. !     RFAC is the upper triangular part of this QR factorization, beginning !       with the first diagonal element, followed by the two elements in the !       upper triangular part of the second column and so on. !     PQW is used for working space, mainly for storing second derivative !       coefficients of quadratic functions. Its length is NPT+N. !     The array W is also used for working space. The required number of !       elements, namely MAX[M+3*N,2*M+N,2*NPT], is set in LINCOA. ! !     Set some constants. ! real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: tenth = 0.1_wp real ( wp ), parameter :: zero = 0.0_wp np = n + 1 nh = ( n * np ) / 2 nptm = npt - np ! !     Set the elements of XBASE, XPT, FVAL, XSAV, XOPT, GOPT, HQ, PQ, BMAT, !       ZMAT and SP for the first iteration. An important feature is that, !       if the interpolation point XPT(K,.) is not feasible, where K is any !       integer from [1,NPT], then a change is made to XPT(K,.) if necessary !       so that the constraint violation is at least 0.2*RHOBEG. Also KOPT !       is set so that XPT(KOPT,.) is the initial trust region centre. ! call prelim ( n , npt , m , amat , b , x , rhobeg , iprint , xbase , xpt , fval , xsav , xopt , & gopt , kopt , hq , pq , bmat , zmat , idz , ndim , sp , rescon , step , pqw , w , & calfun ) ! !     Begin the iterative procedure. ! nf = npt fopt = fval ( kopt ) rho = rhobeg delta = rho ifeas = 0 nact = 0 itest = 3 10 knew = 0 nvala = 0 nvalb = 0 ! !     Shift XBASE if XOPT may be too far from XBASE. First make the changes !       to BMAT that do not depend on ZMAT. ! 20 fsave = fopt xoptsq = zero do i = 1 , n xoptsq = xoptsq + xopt ( i ) ** 2 end do if ( xoptsq >= 1.0e4_wp * delta * delta ) then qoptsq = 0.25_wp * xoptsq do k = 1 , npt sum = zero do i = 1 , n sum = sum + xpt ( k , i ) * xopt ( i ) end do sum = sum - half * xoptsq w ( npt + k ) = sum sp ( k ) = zero do i = 1 , n xpt ( k , i ) = xpt ( k , i ) - half * xopt ( i ) step ( i ) = bmat ( k , i ) w ( i ) = sum * xpt ( k , i ) + qoptsq * xopt ( i ) ip = npt + i do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + step ( i ) * w ( j ) + w ( i ) * step ( j ) end do end do end do ! !     Then the revisions of BMAT that depend on ZMAT are calculated. ! do k = 1 , nptm sumz = zero do i = 1 , npt sumz = sumz + zmat ( i , k ) w ( i ) = w ( npt + i ) * zmat ( i , k ) end do do j = 1 , n sum = qoptsq * sumz * xopt ( j ) do i = 1 , npt sum = sum + w ( i ) * xpt ( i , j ) end do step ( j ) = sum if ( k < idz ) sum = - sum do i = 1 , npt bmat ( i , j ) = bmat ( i , j ) + sum * zmat ( i , k ) end do end do do i = 1 , n ip = i + npt temp = step ( i ) if ( k < idz ) temp = - temp do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + temp * step ( j ) end do end do end do ! !     Update the right hand sides of the constraints. ! if ( m > 0 ) then do j = 1 , m temp = zero do i = 1 , n temp = temp + amat ( i , j ) * xopt ( i ) end do b ( j ) = b ( j ) - temp end do end if ! !     The following instructions complete the shift of XBASE, including the !       changes to the parameters of the quadratic model. ! ih = 0 do j = 1 , n w ( j ) = zero do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) xpt ( k , j ) = xpt ( k , j ) - half * xopt ( j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + xopt ( i ) * w ( j ) bmat ( npt + i , j ) = bmat ( npt + j , i ) end do end do do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) xopt ( j ) = zero xpt ( kopt , j ) = zero end do end if ! !     In the case KNEW=0, generate the next trust region step by calling !       TRSTEP, where SNORM is the current trust region radius initially. !       The final value of SNORM is the length of the calculated step, !       except that SNORM is zero on return if the projected gradient is !       unsuitable for starting the conjugate gradient iterations. ! delsav = delta ksave = knew if ( knew == 0 ) then snorm = delta do i = 1 , n xnew ( i ) = gopt ( i ) end do call trstep ( n , npt , m , amat , b , xpt , hq , pq , nact , iact , rescon , qfac , rfac , & snorm , step , xnew , w , w ( m + 1 ), pqw , pqw ( np ), w ( m + np )) ! !     A trust region step is applied whenever its length, namely SNORM, is at !       least HALF*DELTA. It is also applied if its length is at least 0.1999 !       times DELTA and if a line search of TRSTEP has caused a change to the !       active set. Otherwise there is a branch below to label 530 or 560. ! temp = half * delta if ( xnew ( 1 ) >= half ) temp = 0.1999_wp * delta if ( snorm <= temp ) then delta = half * delta if ( delta <= 1.4_wp * rho ) delta = rho nvala = nvala + 1 nvalb = nvalb + 1 temp = snorm / rho if ( delsav > rho ) temp = one if ( temp >= half ) nvala = zero if ( temp >= tenth ) nvalb = zero if ( delsav > rho ) go to 530 if ( nvala < 5 . and . nvalb < 3 ) go to 530 if ( snorm > zero ) ksave = - 1 go to 560 end if nvala = zero nvalb = zero ! !     Alternatively, KNEW is positive. Then the model step is calculated !       within a trust region of radius DEL, after setting the gradient at !       XBASE and the second derivative parameters of the KNEW-th Lagrange !       function in W(1) to W(N) and in PQW(1) to PQW(NPT), respectively. ! else del = max ( tenth * delta , rho ) do i = 1 , n w ( i ) = bmat ( knew , i ) end do do k = 1 , npt pqw ( k ) = zero end do do j = 1 , nptm temp = zmat ( knew , j ) if ( j < idz ) temp = - temp do k = 1 , npt pqw ( k ) = pqw ( k ) + temp * zmat ( k , j ) end do end do call qmstep ( n , npt , m , amat , b , xpt , xopt , nact , iact , rescon , qfac , kopt , & knew , del , step , w , pqw , w ( np ), w ( np + m ), ifeas ) end if ! !     Set VQUAD to the change to the quadratic model when the move STEP is !       made from XOPT. If STEP is a trust region step, then VQUAD should be !       negative. If it is nonnegative due to rounding errors in this case, !       there is a branch to label 530 to try to improve the model. ! vquad = zero ih = 0 do j = 1 , n vquad = vquad + step ( j ) * gopt ( j ) do i = 1 , j ih = ih + 1 temp = step ( i ) * step ( j ) if ( i == j ) temp = half * temp vquad = vquad + temp * hq ( ih ) end do end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * step ( j ) sp ( npt + k ) = temp end do vquad = vquad + half * pq ( k ) * temp * temp end do if ( ksave == 0 . and . vquad >= zero ) go to 530 ! !     Calculate the next value of the objective function. The difference !       between the actual new value of F and the value predicted by the !       model is recorded in DIFF. ! 220 nf = nf + 1 if ( nf > maxfun ) then nf = nf - 1 if ( iprint > 0 ) print 230 230 format ( / 4 x , 'Return from LINCOA because CALFUN has been' ,& ' called MAXFUN times.' ) go to 600 end if xdiff = zero do i = 1 , n xnew ( i ) = xopt ( i ) + step ( i ) x ( i ) = xbase ( i ) + xnew ( i ) xdiff = xdiff + ( x ( i ) - xsav ( i )) ** 2 end do xdiff = sqrt ( xdiff ) if ( ksave ==- 1 ) xdiff = rho if ( xdiff <= tenth * rho . or . xdiff >= delta + delta ) then ifeas = 0 if ( iprint > 0 ) print 250 250 format ( / 4 x , 'Return from LINCOA because rounding errors' ,& ' prevent reasonable changes to X.' ) go to 600 end if if ( ksave <= 0 ) ifeas = 1 f = real ( ifeas , wp ) call calfun ( n , x , f ) if ( iprint == 3 ) then print 260 , nf , f , ( x ( i ), i = 1 , n ) 260 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( ksave ==- 1 ) go to 600 diff = f - fopt - vquad ! !     If X is feasible, then set DFFALT to the difference between the new !       value of F and the value predicted by the alternative model. ! if ( ifeas == 1 . and . itest < 3 ) then do k = 1 , npt pqw ( k ) = zero w ( k ) = fval ( k ) - fval ( kopt ) end do do j = 1 , nptm sum = zero do i = 1 , npt sum = sum + w ( i ) * zmat ( i , j ) end do if ( j < idz ) sum = - sum do k = 1 , npt pqw ( k ) = pqw ( k ) + sum * zmat ( k , j ) end do end do vqalt = zero do k = 1 , npt sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * step ( j ) end do vqalt = vqalt + sum * w ( k ) vqalt = vqalt + pqw ( k ) * sp ( npt + k ) * ( half * sp ( npt + k ) + sp ( k )) end do dffalt = f - fopt - vqalt end if if ( itest == 3 ) then dffalt = diff itest = 0 end if ! !     Pick the next value of DELTA after a trust region step. ! if ( ksave == 0 ) then ratio = ( f - fopt ) / vquad if ( ratio <= tenth ) then delta = half * delta else if ( ratio <= 0.7_wp ) then delta = max ( half * delta , snorm ) else temp = sqrt ( 2.0_wp ) * delta delta = max ( half * delta , snorm + snorm ) delta = min ( delta , temp ) end if if ( delta <= 1.4_wp * rho ) delta = rho end if ! !     Update BMAT, ZMAT and IDZ, so that the KNEW-th interpolation point !       can be moved. If STEP is a trust region step, then KNEW is zero at !       present, but a positive value is picked by subroutine UPDATE. ! call update ( n , npt , xpt , bmat , zmat , idz , ndim , sp , step , kopt , knew , pqw , w ) if ( knew == 0 ) then if ( iprint > 0 ) print 320 320 format ( / 4 x , & 'Return from LINCOA because the denominator of the updating formula is zero.' ) go to 600 end if ! !     If ITEST is increased to 3, then the next quadratic model is the !       one whose second derivative matrix is least subject to the new !       interpolation conditions. Otherwise the new model is constructed !       by the symmetric Broyden method in the usual way. ! if ( ifeas == 1 ) then itest = itest + 1 if ( abs ( dffalt ) >= tenth * abs ( diff )) itest = 0 end if ! !     Update the second derivatives of the model by the symmetric Broyden !       method, using PQW for the second derivative parameters of the new !       KNEW-th Lagrange function. The contribution from the old parameter !       PQ(KNEW) is included in the second derivative matrix HQ. W is used !       later for the gradient of the new KNEW-th Lagrange function. ! if ( itest < 3 ) then do k = 1 , npt pqw ( k ) = zero end do do j = 1 , nptm temp = zmat ( knew , j ) if ( temp /= zero ) then if ( j < idz ) temp = - temp do k = 1 , npt pqw ( k ) = pqw ( k ) + temp * zmat ( k , j ) end do end if end do ih = 0 do i = 1 , n w ( i ) = bmat ( knew , i ) temp = pq ( knew ) * xpt ( knew , i ) do j = 1 , i ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * xpt ( knew , j ) end do end do pq ( knew ) = zero do k = 1 , npt pq ( k ) = pq ( k ) + diff * pqw ( k ) end do end if ! !     Include the new interpolation point with the corresponding updates of !       SP. Also make the changes of the symmetric Broyden method to GOPT at !       the old XOPT if ITEST is less than 3. ! fval ( knew ) = f sp ( knew ) = sp ( kopt ) + sp ( npt + kopt ) ssq = zero do i = 1 , n xpt ( knew , i ) = xnew ( i ) ssq = ssq + step ( i ) ** 2 end do sp ( npt + knew ) = sp ( npt + kopt ) + ssq if ( itest < 3 ) then do k = 1 , npt temp = pqw ( k ) * sp ( k ) do i = 1 , n w ( i ) = w ( i ) + temp * xpt ( k , i ) end do end do do i = 1 , n gopt ( i ) = gopt ( i ) + diff * w ( i ) end do end if ! !     Update FOPT, XSAV, XOPT, KOPT, RESCON and SP if the new F is the !       least calculated value so far with a feasible vector of variables. ! if ( f < fopt . and . ifeas == 1 ) then fopt = f do j = 1 , n xsav ( j ) = x ( j ) xopt ( j ) = xnew ( j ) end do kopt = knew snorm = sqrt ( ssq ) do j = 1 , m if ( rescon ( j ) >= delta + snorm ) then rescon ( j ) = snorm - rescon ( j ) else rescon ( j ) = rescon ( j ) + snorm if ( rescon ( j ) + delta > zero ) then temp = b ( j ) do i = 1 , n temp = temp - xopt ( i ) * amat ( i , j ) end do temp = max ( temp , zero ) if ( temp >= delta ) temp = - temp rescon ( j ) = temp end if end if end do do k = 1 , npt sp ( k ) = sp ( k ) + sp ( npt + k ) end do ! !     Also revise GOPT when symmetric Broyden updating is applied. ! if ( itest < 3 ) then ih = 0 do j = 1 , n do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * step ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * step ( j ) end do end do do k = 1 , npt temp = pq ( k ) * sp ( npt + k ) do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if end if ! !     Replace the current model by the least Frobenius norm interpolant if !       this interpolant gives substantial reductions in the predictions !       of values of F at feasible points. ! if ( itest == 3 ) then do k = 1 , npt pq ( k ) = zero w ( k ) = fval ( k ) - fval ( kopt ) end do do j = 1 , nptm sum = zero do i = 1 , npt sum = sum + w ( i ) * zmat ( i , j ) end do if ( j < idz ) sum = - sum do k = 1 , npt pq ( k ) = pq ( k ) + sum * zmat ( k , j ) end do end do do j = 1 , n gopt ( j ) = zero do i = 1 , npt gopt ( j ) = gopt ( j ) + w ( i ) * bmat ( i , j ) end do end do do k = 1 , npt temp = pq ( k ) * sp ( k ) do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do do ih = 1 , nh hq ( ih ) = zero end do end if ! !     If a trust region step has provided a sufficient decrease in F, then !       branch for another trust region calculation. Every iteration that !       takes a model step is followed by an attempt to take a trust region !       step. ! knew = 0 if ( ksave > 0 ) go to 20 if ( ratio >= tenth ) go to 20 ! !     Alternatively, find out if the interpolation points are close enough !       to the best point so far. ! 530 distsq = max ( delta * delta , 4.0_wp * rho * rho ) do k = 1 , npt sum = zero do j = 1 , n sum = sum + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( sum > distsq ) then knew = k distsq = sum end if end do ! !     If KNEW is positive, then branch back for the next iteration, which !       will generate a \"model step\". Otherwise, if the current iteration !       has reduced F, or if DELTA was above its lower bound when the last !       trust region step was calculated, then try a \"trust region\" step !       instead. ! if ( knew > 0 ) go to 20 knew = 0 if ( fopt < fsave ) go to 20 if ( delsav > rho ) go to 20 ! !     The calculations with the current value of RHO are complete. !       Pick the next value of RHO. ! 560 if ( rho > rhoend ) then delta = half * rho if ( rho > 25 0.0_wp * rhoend ) then rho = tenth * rho else if ( rho <= 1 6.0_wp * rhoend ) then rho = rhoend else rho = sqrt ( rho * rhoend ) end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) print 570 570 format ( 5 x ) print 580 , rho , nf 580 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 590 , fopt , ( xbase ( i ) + xopt ( i ), i = 1 , n ) 590 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if go to 10 end if ! !     Return from the calculation, after branching to label 220 for another !       Newton-Raphson step if it has not been tried before. ! if ( ksave ==- 1 ) go to 220 600 if ( fopt <= f . or . ifeas == 0 ) then do i = 1 , n x ( i ) = xsav ( i ) end do f = fopt end if if ( iprint >= 1 ) then print 620 , nf 620 format ( / 4 x , 'At the return from LINCOA' , 5 x ,& 'Number of function values =' , i6 ) print 590 , f , ( x ( i ), i = 1 , n ) end if w ( 1 ) = f w ( 2 ) = real ( nf , wp ) + half end subroutine lincob","tags":"","loc":"proc/lincob.html"},{"title":"getact – PowellOpt","text":"private  subroutine getact(n, m, amat, b, nact, iact, qfac, rfac, snorm, resnew, resact, g, dw, vlam, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: amat real :: b integer :: nact integer :: iact real :: qfac real :: rfac real :: snorm real :: resnew real :: resact real :: g real :: dw real :: vlam real :: w Called by proc~~getact~~CalledByGraph proc~getact getact proc~trstep trstep proc~trstep->proc~getact proc~lincob lincob proc~lincob->proc~trstep proc~lincoa lincoa proc~lincoa->proc~lincob proc~lincoa_test lincoa_test proc~lincoa_test->proc~lincoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine getact ( n , m , amat , b , nact , iact , qfac , rfac , snorm , resnew , resact , g , & dw , vlam , w ) implicit real ( wp ) ( a - h , o - z ) dimension amat ( n , * ), b ( * ), iact ( * ), qfac ( n , * ), rfac ( * ), resnew ( * ), & resact ( * ), g ( * ), dw ( * ), vlam ( * ), w ( * ) ! !     N, M, AMAT, B, NACT, IACT, QFAC and RFAC are the same as the terms !       with these names in SUBROUTINE LINCOB. The current values must be !       set on entry. NACT, IACT, QFAC and RFAC are kept up to date when !       GETACT changes the current active set. !     SNORM, RESNEW, RESACT, G and DW are the same as the terms with these !       names in SUBROUTINE TRSTEP. The elements of RESNEW and RESACT are !       also kept up to date. !     VLAM and W are used for working space, the vector VLAM being reserved !       for the Lagrange multipliers of the calculation. Their lengths must !       be at least N. !     The main purpose of GETACT is to pick the current active set. It is !       defined by the property that the projection of -G into the space !       orthogonal to the active constraint normals is as large as possible, !       subject to this projected steepest descent direction moving no closer !       to the boundary of every constraint whose current residual is at most !       0.2*SNORM. On return, the settings in NACT, IACT, QFAC and RFAC are !       all appropriate to this choice of active set. !     Occasionally this projected direction is zero, and then the final value !       of W(1) is set to zero. Otherwise, the direction itself is returned !       in DW, and W(1) is set to the square of the length of the direction. ! !     Set some constants and a temporary VLAM. ! real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: tiny = 1.0e-60_wp real ( wp ), parameter :: zero = 0.0_wp tdel = 0.2_wp * snorm ddsav = zero do i = 1 , n ddsav = ddsav + g ( i ) ** 2 vlam ( i ) = zero end do ddsav = ddsav + ddsav ! !     Set the initial QFAC to the identity matrix in the case NACT=0. ! if ( nact == 0 ) then do i = 1 , n do j = 1 , n qfac ( i , j ) = zero end do qfac ( i , i ) = one end do go to 100 end if ! !     Remove any constraints from the initial active set whose residuals !       exceed TDEL. ! iflag = 1 ic = nact 40 if ( resact ( ic ) > tdel ) go to 800 50 ic = ic - 1 if ( ic > 0 ) go to 40 ! !     Remove any constraints from the initial active set whose Lagrange !       multipliers are nonnegative, and set the surviving multipliers. ! iflag = 2 60 if ( nact == 0 ) go to 100 ic = nact 70 temp = zero do i = 1 , n temp = temp + qfac ( i , ic ) * g ( i ) end do idiag = ( ic * ic + ic ) / 2 if ( ic < nact ) then jw = idiag + ic do j = ic + 1 , nact temp = temp - rfac ( jw ) * vlam ( j ) jw = jw + j end do end if if ( temp >= zero ) go to 800 vlam ( ic ) = temp / rfac ( idiag ) ic = ic - 1 if ( ic > 0 ) go to 70 ! !     Set the new search direction D. Terminate if the 2-norm of D is zero !       or does not decrease, or if NACT=N holds. The situation NACT=N !       occurs for sufficiently large SNORM if the origin is in the convex !       hull of the constraint gradients. ! 100 if ( nact == n ) go to 290 do j = nact + 1 , n w ( j ) = zero do i = 1 , n w ( j ) = w ( j ) + qfac ( i , j ) * g ( i ) end do end do dd = zero do i = 1 , n dw ( i ) = zero do j = nact + 1 , n dw ( i ) = dw ( i ) - w ( j ) * qfac ( i , j ) end do dd = dd + dw ( i ) ** 2 end do if ( dd >= ddsav ) go to 290 if ( dd == zero ) go to 300 ddsav = dd dnorm = sqrt ( dd ) ! !     Pick the next integer L or terminate, a positive value of L being !       the index of the most violated constraint. The purpose of CTOL !       below is to estimate whether a positive value of VIOLMX may be !       due to computer rounding errors. ! l = 0 if ( m > 0 ) then test = dnorm / snorm violmx = zero do j = 1 , m if ( resnew ( j ) > zero . and . resnew ( j ) <= tdel ) then sum = zero do i = 1 , n sum = sum + amat ( i , j ) * dw ( i ) end do if ( sum > test * resnew ( j )) then if ( sum > violmx ) then l = j violmx = sum end if end if end if end do ctol = zero temp = 0.01_wp * dnorm if ( violmx > zero . and . violmx < temp ) then if ( nact > 0 ) then do k = 1 , nact j = iact ( k ) sum = zero do i = 1 , n sum = sum + dw ( i ) * amat ( i , j ) end do ctol = max ( ctol , abs ( sum )) end do end if end if end if w ( 1 ) = one if ( l == 0 ) go to 300 if ( violmx <= 1 0.0_wp * ctol ) go to 300 ! !     Apply Givens rotations to the last (N-NACT) columns of QFAC so that !       the first (NACT+1) columns of QFAC are the ones required for the !       addition of the L-th constraint, and add the appropriate column !       to RFAC. ! nactp = nact + 1 idiag = ( nactp * nactp - nactp ) / 2 rdiag = zero do j = n , 1 , - 1 sprod = zero do i = 1 , n sprod = sprod + qfac ( i , j ) * amat ( i , l ) end do if ( j <= nact ) then rfac ( idiag + j ) = sprod else if ( abs ( rdiag ) <= 1.0e-20_wp * abs ( sprod )) then rdiag = sprod else temp = sqrt ( sprod * sprod + rdiag * rdiag ) cosv = sprod / temp sinv = rdiag / temp rdiag = temp do i = 1 , n temp = cosv * qfac ( i , j ) + sinv * qfac ( i , j + 1 ) qfac ( i , j + 1 ) = - sinv * qfac ( i , j ) + cosv * qfac ( i , j + 1 ) qfac ( i , j ) = temp end do end if end if end do if ( rdiag < zero ) then do i = 1 , n qfac ( i , nactp ) = - qfac ( i , nactp ) end do end if rfac ( idiag + nactp ) = abs ( rdiag ) nact = nactp iact ( nact ) = l resact ( nact ) = resnew ( l ) vlam ( nact ) = zero resnew ( l ) = zero ! !     Set the components of the vector VMU in W. ! 220 w ( nact ) = one / rfac (( nact * nact + nact ) / 2 ) ** 2 if ( nact > 1 ) then do i = nact - 1 , 1 , - 1 idiag = ( i * i + i ) / 2 jw = idiag + i sum = zero do j = i + 1 , nact sum = sum - rfac ( jw ) * w ( j ) jw = jw + j end do w ( i ) = sum / rfac ( idiag ) end do end if ! !     Calculate the multiple of VMU to subtract from VLAM, and update VLAM. ! vmult = violmx ic = 0 j = 1 250 if ( j < nact ) then if ( vlam ( j ) >= vmult * w ( j )) then ic = j vmult = vlam ( j ) / w ( j ) end if j = j + 1 go to 250 end if do j = 1 , nact vlam ( j ) = vlam ( j ) - vmult * w ( j ) end do if ( ic > 0 ) vlam ( ic ) = zero violmx = max ( violmx - vmult , zero ) if ( ic == 0 ) violmx = zero ! !     Reduce the active set if necessary, so that all components of the !       new VLAM are negative, with resetting of the residuals of the !       constraints that become inactive. ! iflag = 3 ic = nact 270 if ( vlam ( ic ) < zero ) go to 280 resnew ( iact ( ic )) = max ( resact ( ic ), tiny ) go to 800 280 ic = ic - 1 if ( ic > 0 ) go to 270 ! !     Calculate the next VMU if VIOLMX is positive. Return if NACT=N holds, !       as then the active constraints imply D=0. Otherwise, go to label !       100, to calculate the new D and to test for termination. ! if ( violmx > zero ) go to 220 if ( nact < n ) go to 100 290 dd = zero 300 w ( 1 ) = dd return ! !     These instructions rearrange the active constraints so that the new !       value of IACT(NACT) is the old value of IACT(IC). A sequence of !       Givens rotations is applied to the current QFAC and RFAC. Then NACT !       is reduced by one. ! 800 resnew ( iact ( ic )) = max ( resact ( ic ), tiny ) jc = ic 810 if ( jc < nact ) then jcp = jc + 1 idiag = jc * jcp / 2 jw = idiag + jcp temp = sqrt ( rfac ( jw - 1 ) ** 2 + rfac ( jw ) ** 2 ) cval = rfac ( jw ) / temp sval = rfac ( jw - 1 ) / temp rfac ( jw - 1 ) = sval * rfac ( idiag ) rfac ( jw ) = cval * rfac ( idiag ) rfac ( idiag ) = temp if ( jcp < nact ) then do j = jcp + 1 , nact temp = sval * rfac ( jw + jc ) + cval * rfac ( jw + jcp ) rfac ( jw + jcp ) = cval * rfac ( jw + jc ) - sval * rfac ( jw + jcp ) rfac ( jw + jc ) = temp jw = jw + j end do end if jdiag = idiag - jc do i = 1 , n if ( i < jc ) then temp = rfac ( idiag + i ) rfac ( idiag + i ) = rfac ( jdiag + i ) rfac ( jdiag + i ) = temp end if temp = sval * qfac ( i , jc ) + cval * qfac ( i , jcp ) qfac ( i , jcp ) = cval * qfac ( i , jc ) - sval * qfac ( i , jcp ) qfac ( i , jc ) = temp end do iact ( jc ) = iact ( jcp ) resact ( jc ) = resact ( jcp ) vlam ( jc ) = vlam ( jcp ) jc = jcp go to 810 end if nact = nact - 1 go to ( 50 , 60 , 280 ), iflag end subroutine getact","tags":"","loc":"proc/getact.html"},{"title":"prelim – PowellOpt","text":"private  subroutine prelim(n, npt, m, amat, b, x, rhobeg, iprint, xbase, xpt, fval, xsav, xopt, gopt, kopt, hq, pq, bmat, zmat, idz, ndim, sp, rescon, step, pqw, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt integer :: m real :: amat real :: b real :: x real :: rhobeg integer :: iprint real :: xbase real :: xpt real :: fval real :: xsav real :: xopt real :: gopt integer :: kopt real :: hq real :: pq real :: bmat real :: zmat integer :: idz integer :: ndim real :: sp real :: rescon real :: step real :: pqw real :: w procedure( func ) :: calfun Calls proc~~prelim~~CallsGraph proc~prelim prelim proc~update~2 update proc~prelim->proc~update~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~prelim~~CalledByGraph proc~prelim prelim proc~lincob lincob proc~lincob->proc~prelim proc~lincoa lincoa proc~lincoa->proc~lincob proc~lincoa_test lincoa_test proc~lincoa_test->proc~lincoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine prelim ( n , npt , m , amat , b , x , rhobeg , iprint , xbase , xpt , fval , xsav , & xopt , gopt , kopt , hq , pq , bmat , zmat , idz , ndim , sp , rescon , step , pqw , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension amat ( n , * ), b ( * ), x ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xsav ( * ),& xopt ( * ), gopt ( * ), hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sp ( * ), rescon ( * ),& step ( * ), pqw ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, M, AMAT, B, X, RHOBEG, IPRINT, XBASE, XPT, FVAL, !       XSAV, XOPT, GOPT, HQ, PQ, BMAT, ZMAT, NDIM, SP and RESCON are the !       same as the corresponding arguments in SUBROUTINE LINCOB. !     KOPT is set to the integer such that XPT(KOPT,.) is the initial trust !       region centre. !     IDZ is going to be set to one, so that every element of Diag(DZ) is !       one in the product ZMAT times Diag(DZ) times ZMAT&#94;T, which is the !       factorization of the leading NPT by NPT submatrix of H. !     STEP, PQW and W are used for working space, the arrays STEP and PQW !       being taken from LINCOB. The length of W must be at least N+NPT. ! !     SUBROUTINE PRELIM provides the elements of XBASE, XPT, BMAT and ZMAT !       for the first iteration, an important feature being that, if any of !       of the columns of XPT is an infeasible point, then the largest of !       the constraint violations there is at least 0.2*RHOBEG. It also sets !       the initial elements of FVAL, XOPT, GOPT, HQ, PQ, SP and RESCON. ! !     Set some constants. ! real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: zero = 0.0_wp nptm = npt - n - 1 rhosq = rhobeg * rhobeg recip = one / rhosq reciq = sqrt ( half ) / rhosq test = 0.2_wp * rhobeg idz = 1 kbase = 1 ! !     Set the initial elements of XPT, BMAT, SP and ZMAT to zero. ! do j = 1 , n xbase ( j ) = x ( j ) do k = 1 , npt xpt ( k , j ) = zero end do do i = 1 , ndim bmat ( i , j ) = zero end do end do do k = 1 , npt sp ( k ) = zero do j = 1 , npt - n - 1 zmat ( k , j ) = zero end do end do ! !     Set the nonzero coordinates of XPT(K,.), K=1,2,...,min[2*N+1,NPT], !       but they may be altered later to make a constraint violation !       sufficiently large. The initial nonzero elements of BMAT and of !       the first min[N,NPT-N-1] columns of ZMAT are set also. ! do j = 1 , n xpt ( j + 1 , j ) = rhobeg if ( j < npt - n ) then jp = n + j + 1 xpt ( jp , j ) = - rhobeg bmat ( j + 1 , j ) = half / rhobeg bmat ( jp , j ) = - half / rhobeg zmat ( 1 , j ) = - reciq - reciq zmat ( j + 1 , j ) = reciq zmat ( jp , j ) = reciq else bmat ( 1 , j ) = - one / rhobeg bmat ( j + 1 , j ) = one / rhobeg bmat ( npt + j , j ) = - half * rhosq end if end do ! !     Set the remaining initial nonzero elements of XPT and ZMAT when the !       number of interpolation points exceeds 2*N+1. ! if ( npt > 2 * n + 1 ) then do k = n + 1 , npt - n - 1 itemp = ( k - 1 ) / n ipt = k - itemp * n jpt = ipt + itemp if ( jpt > n ) jpt = jpt - n xpt ( n + k + 1 , ipt ) = rhobeg xpt ( n + k + 1 , jpt ) = rhobeg zmat ( 1 , k ) = recip zmat ( ipt + 1 , k ) = - recip zmat ( jpt + 1 , k ) = - recip zmat ( n + k + 1 , k ) = recip end do end if ! !     Update the constraint right hand sides to allow for the shift XBASE. ! if ( m > 0 ) then do j = 1 , m temp = zero do i = 1 , n temp = temp + amat ( i , j ) * xbase ( i ) end do b ( j ) = b ( j ) - temp end do end if ! !     Go through the initial points, shifting every infeasible point if !       necessary so that its constraint violation is at least 0.2*RHOBEG. ! do nf = 1 , npt feas = one bigv = zero j = 0 80 j = j + 1 if ( j <= m . and . nf >= 2 ) then resid = - b ( j ) do i = 1 , n resid = resid + xpt ( nf , i ) * amat ( i , j ) end do if ( resid <= bigv ) go to 80 bigv = resid jsav = j if ( resid <= test ) then feas = - one go to 80 end if feas = zero end if if ( feas < zero ) then do i = 1 , n step ( i ) = xpt ( nf , i ) + ( test - bigv ) * amat ( i , jsav ) end do do k = 1 , npt sp ( npt + k ) = zero do j = 1 , n sp ( npt + k ) = sp ( npt + k ) + xpt ( k , j ) * step ( j ) end do end do call update ( n , npt , xpt , bmat , zmat , idz , ndim , sp , step , kbase , nf , pqw , w ) do i = 1 , n xpt ( nf , i ) = step ( i ) end do end if ! !     Calculate the objective function at the current interpolation point, !       and set KOPT to the index of the first trust region centre. ! do j = 1 , n x ( j ) = xbase ( j ) + xpt ( nf , j ) end do f = feas call calfun ( n , x , f ) if ( iprint == 3 ) then print 140 , nf , f , ( x ( i ), i = 1 , n ) 140 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( nf == 1 ) then kopt = 1 else if ( f < fval ( kopt ) . and . feas > zero ) then kopt = nf end if fval ( nf ) = f end do ! !     Set PQ for the first quadratic model. ! do j = 1 , nptm w ( j ) = zero do k = 1 , npt w ( j ) = w ( j ) + zmat ( k , j ) * fval ( k ) end do end do do k = 1 , npt pq ( k ) = zero do j = 1 , nptm pq ( k ) = pq ( k ) + zmat ( k , j ) * w ( j ) end do end do ! !     Set XOPT, SP, GOPT and HQ for the first quadratic model. ! do j = 1 , n xopt ( j ) = xpt ( kopt , j ) xsav ( j ) = xbase ( j ) + xopt ( j ) gopt ( j ) = zero end do do k = 1 , npt sp ( k ) = zero do j = 1 , n sp ( k ) = sp ( k ) + xpt ( k , j ) * xopt ( j ) end do temp = pq ( k ) * sp ( k ) do j = 1 , n gopt ( j ) = gopt ( j ) + fval ( k ) * bmat ( k , j ) + temp * xpt ( k , j ) end do end do do i = 1 , ( n * n + n ) / 2 hq ( i ) = zero end do ! !     Set the initial elements of RESCON. ! do j = 1 , m temp = b ( j ) do i = 1 , n temp = temp - xopt ( i ) * amat ( i , j ) end do temp = max ( temp , zero ) if ( temp >= rhobeg ) temp = - temp rescon ( j ) = temp end do end subroutine prelim","tags":"","loc":"proc/prelim.html"},{"title":"qmstep – PowellOpt","text":"private  subroutine qmstep(n, npt, m, amat, b, xpt, xopt, nact, iact, rescon, qfac, kopt, knew, del, step, gl, pqw, rstat, w, ifeas) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt integer :: m real :: amat real :: b real :: xpt real :: xopt integer :: nact integer :: iact real :: rescon real :: qfac integer :: kopt integer :: knew real :: del real :: step real :: gl real :: pqw real :: rstat real :: w integer :: ifeas Called by proc~~qmstep~~CalledByGraph proc~qmstep qmstep proc~lincob lincob proc~lincob->proc~qmstep proc~lincoa lincoa proc~lincoa->proc~lincob proc~lincoa_test lincoa_test proc~lincoa_test->proc~lincoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine qmstep ( n , npt , m , amat , b , xpt , xopt , nact , iact , rescon , qfac , kopt , & knew , del , step , gl , pqw , rstat , w , ifeas ) implicit real ( wp ) ( a - h , o - z ) dimension amat ( n , * ), b ( * ), xpt ( npt , * ), xopt ( * ), iact ( * ), rescon ( * ), & qfac ( n , * ), step ( * ), gl ( * ), pqw ( * ), rstat ( * ), w ( * ) ! !     N, NPT, M, AMAT, B, XPT, XOPT, NACT, IACT, RESCON, QFAC, KOPT are the !       same as the terms with these names in SUBROUTINE LINCOB. !     KNEW is the index of the interpolation point that is going to be moved. !     DEL is the current restriction on the length of STEP, which is never !       greater than the current trust region radius DELTA. !     STEP will be set to the required step from XOPT to the new point. !     GL must be set on entry to the gradient of LFUNC at XBASE, where LFUNC !       is the KNEW-th Lagrange function. It is used also for some other !       gradients of LFUNC. !     PQW provides the second derivative parameters of LFUNC. !     RSTAT and W are used for working space. Their lengths must be at least !       M and N, respectively. RSTAT(J) is set to -1.0, 0.0, or 1.0 if the !       J-th constraint is irrelevant, active, or both inactive and relevant, !       respectively. !     IFEAS will be set to 0 or 1 if XOPT+STEP is infeasible or feasible. ! !     STEP is chosen to provide a relatively large value of the modulus of !       LFUNC(XOPT+STEP), subject to ||STEP|| .LE. DEL. A projected STEP is !       calculated too, within the trust region, that does not alter the !       residuals of the active constraints. The projected step is preferred !       if its value of | LFUNC(XOPT+STEP) | is at least one fifth of the !       original one, but the greatest violation of a linear constraint must !       be at least 0.2*DEL, in order to keep the interpolation points apart. !       The remedy when the maximum constraint violation is too small is to !       restore the original step, which is perturbed if necessary so that !       its maximum constraint violation becomes 0.2*DEL. ! !     Set some constants. ! real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: tenth = 0.1_wp real ( wp ), parameter :: zero = 0.0_wp test = 0.2_wp * del ! !     Replace GL by the gradient of LFUNC at the trust region centre, and !       set the elements of RSTAT. ! do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = pqw ( k ) * temp do i = 1 , n gl ( i ) = gl ( i ) + temp * xpt ( k , i ) end do end do if ( m > 0 ) then do j = 1 , m rstat ( j ) = one if ( abs ( rescon ( j )) >= del ) rstat ( j ) = - one end do do k = 1 , nact rstat ( iact ( k )) = zero end do end if ! !     Find the greatest modulus of LFUNC on a line through XOPT and !       another interpolation point within the trust region. ! iflag = 0 vbig = zero do k = 1 , npt if ( k == kopt ) cycle ss = zero sp = zero do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) ss = ss + temp * temp sp = sp + gl ( i ) * temp end do stp = - del / sqrt ( ss ) if ( k == knew ) then if ( sp * ( sp - one ) < zero ) stp = - stp vlag = abs ( stp * sp ) + stp * stp * abs ( sp - one ) else vlag = abs ( stp * ( one - stp ) * sp ) end if if ( vlag > vbig ) then ksav = k stpsav = stp vbig = vlag end if end do ! !     Set STEP to the move that gives the greatest modulus calculated above. !       This move may be replaced by a steepest ascent step from XOPT. ! gg = zero do i = 1 , n gg = gg + gl ( i ) ** 2 step ( i ) = stpsav * ( xpt ( ksav , i ) - xopt ( i )) end do vgrad = del * sqrt ( gg ) if ( vgrad <= tenth * vbig ) go to 220 ! !     Make the replacement if it provides a larger value of VBIG. ! ghg = zero do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * gl ( j ) end do ghg = ghg + pqw ( k ) * temp * temp end do vnew = vgrad + abs ( half * del * del * ghg / gg ) if ( vnew > vbig ) then vbig = vnew stp = del / sqrt ( gg ) if ( ghg < zero ) stp = - stp do i = 1 , n step ( i ) = stp * gl ( i ) end do end if if ( nact == 0 . or . nact == n ) go to 220 ! !     Overwrite GL by its projection. Then set VNEW to the greatest !       value of |LFUNC| on the projected gradient from XOPT subject to !       the trust region bound. If VNEW is sufficiently large, then STEP !       may be changed to a move along the projected gradient. ! do k = nact + 1 , n w ( k ) = zero do i = 1 , n w ( k ) = w ( k ) + gl ( i ) * qfac ( i , k ) end do end do gg = zero do i = 1 , n gl ( i ) = zero do k = nact + 1 , n gl ( i ) = gl ( i ) + qfac ( i , k ) * w ( k ) end do gg = gg + gl ( i ) ** 2 end do vgrad = del * sqrt ( gg ) if ( vgrad <= tenth * vbig ) go to 220 ghg = zero do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * gl ( j ) end do ghg = ghg + pqw ( k ) * temp * temp end do vnew = vgrad + abs ( half * del * del * ghg / gg ) ! !     Set W to the possible move along the projected gradient. ! stp = del / sqrt ( gg ) if ( ghg < zero ) stp = - stp ww = zero do i = 1 , n w ( i ) = stp * gl ( i ) ww = ww + w ( i ) ** 2 end do ! !     Set STEP to W if W gives a sufficiently large value of the modulus !       of the Lagrange function, and if W either preserves feasibility !       or gives a constraint violation of at least 0.2*DEL. The purpose !       of CTOL below is to provide a check on feasibility that includes !       a tolerance for contributions from computer rounding errors. ! if ( vnew / vbig >= 0.2_wp ) then ifeas = 1 bigv = zero j = 0 170 j = j + 1 if ( j <= m ) then if ( rstat ( j ) == one ) then temp = - rescon ( j ) do i = 1 , n temp = temp + w ( i ) * amat ( i , j ) end do bigv = max ( bigv , temp ) end if if ( bigv < test ) go to 170 ifeas = 0 end if ctol = zero temp = 0.01_wp * sqrt ( ww ) if ( bigv > zero . and . bigv < temp ) then do k = 1 , nact j = iact ( k ) sum = zero do i = 1 , n sum = sum + w ( i ) * amat ( i , j ) end do ctol = max ( ctol , abs ( sum )) end do end if if ( bigv <= 1 0.0_wp * ctol . or . bigv >= test ) then do i = 1 , n step ( i ) = w ( i ) end do return end if end if ! !     Calculate the greatest constraint violation at XOPT+STEP with STEP at !       its original value. Modify STEP if this violation is unacceptable. ! 220 ifeas = 1 bigv = zero resmax = zero j = 0 230 j = j + 1 if ( j <= m ) then if ( rstat ( j ) < zero ) go to 230 temp = - rescon ( j ) do i = 1 , n temp = temp + step ( i ) * amat ( i , j ) end do resmax = max ( resmax , temp ) if ( temp < test ) then if ( temp <= bigv ) go to 230 bigv = temp jsav = j ifeas = - 1 go to 230 end if ifeas = 0 end if if ( ifeas ==- 1 ) then do i = 1 , n step ( i ) = step ( i ) + ( test - bigv ) * amat ( i , jsav ) end do ifeas = 0 end if ! !     Return the calculated STEP and the value of IFEAS. ! end subroutine qmstep","tags":"","loc":"proc/qmstep.html"},{"title":"trstep – PowellOpt","text":"private  subroutine trstep(n, npt, m, amat, b, xpt, hq, pq, nact, iact, rescon, qfac, rfac, snorm, step, g, resnew, resact, d, dw, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt integer :: m real :: amat real :: b real :: xpt real :: hq real :: pq integer :: nact integer :: iact real :: rescon real :: qfac real :: rfac real :: snorm real :: step real :: g real :: resnew real :: resact real :: d real :: dw real :: w Calls proc~~trstep~~CallsGraph proc~trstep trstep proc~getact getact proc~trstep->proc~getact Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~trstep~~CalledByGraph proc~trstep trstep proc~lincob lincob proc~lincob->proc~trstep proc~lincoa lincoa proc~lincoa->proc~lincob proc~lincoa_test lincoa_test proc~lincoa_test->proc~lincoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine trstep ( n , npt , m , amat , b , xpt , hq , pq , nact , iact , rescon , qfac , rfac , & snorm , step , g , resnew , resact , d , dw , w ) implicit real ( wp ) ( a - h , o - z ) dimension amat ( n , * ), b ( * ), xpt ( npt , * ), hq ( * ), pq ( * ), iact ( * ), rescon ( * ), & qfac ( n , * ), rfac ( * ), step ( * ), g ( * ), resnew ( * ), resact ( * ), d ( * ), dw ( * ), w & ( * ) ! !     N, NPT, M, AMAT, B, XPT, HQ, PQ, NACT, IACT, RESCON, QFAC and RFAC !       are the same as the terms with these names in LINCOB. If RESCON(J) !       is negative, then |RESCON(J)| must be no less than the trust region !       radius, so that the J-th constraint can be ignored. !     SNORM is set to the trust region radius DELTA initially. On the !       return, however, it is the length of the calculated STEP, which is !       set to zero if the constraints do not allow a long enough step. !     STEP is the total calculated step so far from the trust region centre, !       its final value being given by the sequence of CG iterations, which !       terminate if the trust region boundary is reached. !     G must be set on entry to the gradient of the quadratic model at the !       trust region centre. It is used as working space, however, and is !       always the gradient of the model at the current STEP, except that !       on return the value of G(1) is set to ONE instead of to ZERO if !       and only if GETACT is called more than once. !     RESNEW, RESACT, D, DW and W are used for working space. A negative !       value of RESNEW(J) indicates that the J-th constraint does not !       restrict the CG steps of the current trust region calculation, a !       zero value of RESNEW(J) indicates that the J-th constraint is active, !       and otherwise RESNEW(J) is set to the greater of TINY and the actual !       residual of the J-th constraint for the current STEP. RESACT holds !       the residuals of the active constraints, which may be positive. !       D is the search direction of each line search. DW is either another !       search direction or the change in gradient along D. The length of W !       must be at least MAX[M,2*N]. ! !     Set some numbers for the conjugate gradient iterations. ! real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: tiny = 1.0e-60_wp real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: ctest = 0.01_wp snsq = snorm * snorm ! !     Set the initial elements of RESNEW, RESACT and STEP. ! if ( m > 0 ) then do j = 1 , m resnew ( j ) = rescon ( j ) if ( rescon ( j ) >= snorm ) then resnew ( j ) = - one else if ( rescon ( j ) >= zero ) then resnew ( j ) = max ( resnew ( j ), tiny ) end if end do if ( nact > 0 ) then do k = 1 , nact resact ( k ) = rescon ( iact ( k )) resnew ( iact ( k )) = zero end do end if end if do i = 1 , n step ( i ) = zero end do ss = zero reduct = zero ncall = 0 ! !     GETACT picks the active set for the current STEP. It also sets DW to !       the vector closest to -G that is orthogonal to the normals of the !       active constraints. DW is scaled to have length 0.2*SNORM, as then !       a move of DW from STEP is allowed by the linear constraints. ! 40 ncall = ncall + 1 call getact ( n , m , amat , b , nact , iact , qfac , rfac , snorm , resnew , resact , g , dw , & w , w ( n + 1 )) if ( w ( n + 1 ) == zero ) go to 320 scale = 0.2_wp * snorm / sqrt ( w ( n + 1 )) do i = 1 , n dw ( i ) = scale * dw ( i ) end do ! !     If the modulus of the residual of an active constraint is substantial, !       then set D to the shortest move from STEP to the boundaries of the !       active constraints. ! resmax = zero if ( nact > 0 ) then do k = 1 , nact resmax = max ( resmax , resact ( k )) end do end if gamma = zero if ( resmax > 1.0e-4_wp * snorm ) then ir = 0 do k = 1 , nact temp = resact ( k ) if ( k >= 2 ) then do i = 1 , k - 1 ir = ir + 1 temp = temp - rfac ( ir ) * w ( i ) end do end if ir = ir + 1 w ( k ) = temp / rfac ( ir ) end do do i = 1 , n d ( i ) = zero do k = 1 , nact d ( i ) = d ( i ) + w ( k ) * qfac ( i , k ) end do end do ! !     The vector D that has just been calculated is also the shortest move !       from STEP+DW to the boundaries of the active constraints. Set GAMMA !       to the greatest steplength of this move that satisfies the trust !       region bound. ! rhs = snsq ds = zero dd = zero do i = 1 , n sum = step ( i ) + dw ( i ) rhs = rhs - sum * sum ds = ds + d ( i ) * sum dd = dd + d ( i ) ** 2 end do if ( rhs > zero ) then temp = sqrt ( ds * ds + dd * rhs ) if ( ds <= zero ) then gamma = ( temp - ds ) / dd else gamma = rhs / ( temp + ds ) end if end if ! !     Reduce the steplength GAMMA if necessary so that the move along D !       also satisfies the linear constraints. ! j = 0 110 if ( gamma > zero ) then j = j + 1 if ( resnew ( j ) > zero ) then ad = zero adw = zero do i = 1 , n ad = ad + amat ( i , j ) * d ( i ) adw = adw + amat ( i , j ) * dw ( i ) end do if ( ad > zero ) then temp = max (( resnew ( j ) - adw ) / ad , zero ) gamma = min ( gamma , temp ) end if end if if ( j < m ) go to 110 end if gamma = min ( gamma , one ) end if ! !     Set the next direction for seeking a reduction in the model function !       subject to the trust region bound and the linear constraints. ! if ( gamma <= zero ) then do i = 1 , n d ( i ) = dw ( i ) end do icount = nact else do i = 1 , n d ( i ) = dw ( i ) + gamma * d ( i ) end do icount = nact - 1 end if alpbd = one ! !     Set ALPHA to the steplength from STEP along D to the trust region !       boundary. Return if the first derivative term of this step is !       sufficiently small or if no further progress is possible. ! 150 icount = icount + 1 rhs = snsq - ss if ( rhs <= zero ) go to 320 dg = zero ds = zero dd = zero do i = 1 , n dg = dg + d ( i ) * g ( i ) ds = ds + d ( i ) * step ( i ) dd = dd + d ( i ) ** 2 end do if ( dg >= zero ) go to 320 temp = sqrt ( rhs * dd + ds * ds ) if ( ds <= zero ) then alpha = ( temp - ds ) / dd else alpha = rhs / ( temp + ds ) end if if ( - alpha * dg <= ctest * reduct ) go to 320 ! !     Set DW to the change in gradient along D. ! ih = 0 do j = 1 , n dw ( j ) = zero do i = 1 , j ih = ih + 1 if ( i < j ) dw ( j ) = dw ( j ) + hq ( ih ) * d ( i ) dw ( i ) = dw ( i ) + hq ( ih ) * d ( j ) end do end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * d ( j ) end do temp = pq ( k ) * temp do i = 1 , n dw ( i ) = dw ( i ) + temp * xpt ( k , i ) end do end do ! !     Set DGD to the curvature of the model along D. Then reduce ALPHA if !       necessary to the value that minimizes the model. ! dgd = zero do i = 1 , n dgd = dgd + d ( i ) * dw ( i ) end do alpht = alpha if ( dg + alpha * dgd > zero ) then alpha = - dg / dgd end if ! !     Make a further reduction in ALPHA if necessary to preserve feasibility, !       and put some scalar products of D with constraint gradients in W. ! alphm = alpha jsav = 0 if ( m > 0 ) then do j = 1 , m ad = zero if ( resnew ( j ) > zero ) then do i = 1 , n ad = ad + amat ( i , j ) * d ( i ) end do if ( alpha * ad > resnew ( j )) then alpha = resnew ( j ) / ad jsav = j end if end if w ( j ) = ad end do end if alpha = max ( alpha , alpbd ) alpha = min ( alpha , alphm ) if ( icount == nact ) alpha = min ( alpha , one ) ! !     Update STEP, G, RESNEW, RESACT and REDUCT. ! ss = zero do i = 1 , n step ( i ) = step ( i ) + alpha * d ( i ) ss = ss + step ( i ) ** 2 g ( i ) = g ( i ) + alpha * dw ( i ) end do if ( m > 0 ) then do j = 1 , m if ( resnew ( j ) > zero ) then resnew ( j ) = max ( resnew ( j ) - alpha * w ( j ), tiny ) end if end do end if if ( icount == nact . and . nact > 0 ) then do k = 1 , nact resact ( k ) = ( one - gamma ) * resact ( k ) end do end if reduct = reduct - alpha * ( dg + half * alpha * dgd ) ! !     Test for termination. Branch to label 40 if there is a new active !       constraint and if the distance from STEP to the trust region !       boundary is at least 0.2*SNORM. ! if ( alpha == alpht ) go to 320 temp = - alphm * ( dg + half * alphm * dgd ) if ( temp <= ctest * reduct ) go to 320 if ( jsav > 0 ) then if ( ss <= 0.64_wp * snsq ) go to 40 go to 320 end if if ( icount == n ) go to 320 ! !     Calculate the next search direction, which is conjugate to the !       previous one except in the case ICOUNT=NACT. ! if ( nact > 0 ) then do j = nact + 1 , n w ( j ) = zero do i = 1 , n w ( j ) = w ( j ) + g ( i ) * qfac ( i , j ) end do end do do i = 1 , n temp = zero do j = nact + 1 , n temp = temp + qfac ( i , j ) * w ( j ) end do w ( n + i ) = temp end do else do i = 1 , n w ( n + i ) = g ( i ) end do end if if ( icount == nact ) then beta = zero else wgd = zero do i = 1 , n wgd = wgd + w ( n + i ) * dw ( i ) end do beta = wgd / dgd end if do i = 1 , n d ( i ) = - w ( n + i ) + beta * d ( i ) end do alpbd = zero go to 150 ! !     Return from the subroutine. ! 320 snorm = zero if ( reduct > zero ) snorm = sqrt ( ss ) g ( 1 ) = zero if ( ncall > 1 ) g ( 1 ) = one end subroutine trstep","tags":"","loc":"proc/trstep.html"},{"title":"update – PowellOpt","text":"private  subroutine update(n, npt, xpt, bmat, zmat, idz, ndim, sp, step, kopt, knew, vlag, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: bmat real :: zmat integer :: idz integer :: ndim real :: sp real :: step integer :: kopt integer :: knew real :: vlag real :: w Called by proc~~update~2~~CalledByGraph proc~update~2 update proc~lincob lincob proc~lincob->proc~update~2 proc~prelim prelim proc~lincob->proc~prelim proc~prelim->proc~update~2 proc~lincoa lincoa proc~lincoa->proc~lincob proc~lincoa_test lincoa_test proc~lincoa_test->proc~lincoa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update ( n , npt , xpt , bmat , zmat , idz , ndim , sp , step , kopt , knew , vlag , w ) implicit real ( wp ) ( a - h , o - z ) dimension xpt ( npt , * ), bmat ( ndim , * ), zmat ( npt , * ), sp ( * ), step ( * ), vlag ( * ), & w ( * ) ! !     The arguments N, NPT, XPT, BMAT, ZMAT, IDZ, NDIM ,SP and STEP are !       identical to the corresponding arguments in SUBROUTINE LINCOB. !     KOPT is such that XPT(KOPT,.) is the current trust region centre. !     KNEW on exit is usually positive, and then it is the index of an !       interpolation point to be moved to the position XPT(KOPT,.)+STEP(.). !       It is set on entry either to its final value or to 0. In the latter !       case, the final value of KNEW is chosen to maximize the denominator !       of the matrix updating formula times a weighting factor. !     VLAG and W are used for working space, the first NPT+N elements of !       both of these vectors being required. ! !     The arrays BMAT and ZMAT with IDZ are updated, the new matrices being !       the ones that are suitable after the shift of the KNEW-th point to !       the new position XPT(KOPT,.)+STEP(.). A return with KNEW set to zero !       occurs if the calculation fails due to a zero denominator in the !       updating formula, which should never happen. ! !     Set some constants. ! real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: zero = 0.0_wp nptm = npt - n - 1 ! !     Calculate VLAG and BETA for the current choice of STEP. The first NPT !       elements of VLAG are set to the values of the Lagrange functions at !       XPT(KOPT,.)+STEP(.). The first NPT components of W_check are held !       in W, where W_check is defined in a paper on the updating method. ! do k = 1 , npt w ( k ) = sp ( npt + k ) * ( half * sp ( npt + k ) + sp ( k )) sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * step ( j ) end do vlag ( k ) = sum end do beta = zero do k = 1 , nptm sum = zero do i = 1 , npt sum = sum + zmat ( i , k ) * w ( i ) end do if ( k < idz ) then beta = beta + sum * sum sum = - sum else beta = beta - sum * sum end if do i = 1 , npt vlag ( i ) = vlag ( i ) + sum * zmat ( i , k ) end do end do bsum = zero dx = zero ssq = zero do j = 1 , n sum = zero do i = 1 , npt sum = sum + w ( i ) * bmat ( i , j ) end do bsum = bsum + sum * step ( j ) jp = npt + j do k = 1 , n sum = sum + bmat ( jp , k ) * step ( k ) end do vlag ( jp ) = sum bsum = bsum + sum * step ( j ) dx = dx + step ( j ) * xpt ( kopt , j ) ssq = ssq + step ( j ) ** 2 end do beta = dx * dx + ssq * ( sp ( kopt ) + dx + dx + half * ssq ) + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     If KNEW is zero initially, then pick the index of the interpolation !       point to be deleted, by maximizing the absolute value of the !       denominator of the updating formula times a weighting factor. ! if ( knew == 0 ) then denmax = zero do k = 1 , npt hdiag = zero do j = 1 , nptm temp = one if ( j < idz ) temp = - one hdiag = hdiag + temp * zmat ( k , j ) ** 2 end do denabs = abs ( beta * hdiag + vlag ( k ) ** 2 ) distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xpt ( kopt , j )) ** 2 end do temp = denabs * distsq * distsq if ( temp > denmax ) then denmax = temp knew = k end if end do end if ! !     Apply the rotations that put zeros in the KNEW-th row of ZMAT. ! jl = 1 if ( nptm >= 2 ) then do j = 2 , nptm if ( j == idz ) then jl = idz else if ( zmat ( knew , j ) /= zero ) then temp = sqrt ( zmat ( knew , jl ) ** 2 + zmat ( knew , j ) ** 2 ) tempa = zmat ( knew , jl ) / temp tempb = zmat ( knew , j ) / temp do i = 1 , npt temp = tempa * zmat ( i , jl ) + tempb * zmat ( i , j ) zmat ( i , j ) = tempa * zmat ( i , j ) - tempb * zmat ( i , jl ) zmat ( i , jl ) = temp end do zmat ( knew , j ) = zero end if end do end if ! !     Put the first NPT components of the KNEW-th column of the Z Z&#94;T matrix !       into W, and calculate the parameters of the updating formula. ! tempa = zmat ( knew , 1 ) if ( idz >= 2 ) tempa = - tempa if ( jl > 1 ) tempb = zmat ( knew , jl ) do i = 1 , npt w ( i ) = tempa * zmat ( i , 1 ) if ( jl > 1 ) w ( i ) = w ( i ) + tempb * zmat ( i , jl ) end do alpha = w ( knew ) tau = vlag ( knew ) tausq = tau * tau denom = alpha * beta + tausq vlag ( knew ) = vlag ( knew ) - one if ( denom == zero ) then knew = 0 return end if sqrtdn = sqrt ( abs ( denom )) ! !     Complete the updating of ZMAT when there is only one nonzero element !       in the KNEW-th row of the new matrix ZMAT. IFLAG is set to one when !       the value of IDZ is going to be reduced. ! iflag = 0 if ( jl == 1 ) then tempa = tau / sqrtdn tempb = zmat ( knew , 1 ) / sqrtdn do i = 1 , npt zmat ( i , 1 ) = tempa * zmat ( i , 1 ) - tempb * vlag ( i ) end do if ( denom < zero ) then if ( idz == 1 ) then idz = 2 else iflag = 1 end if end if else ! !     Complete the updating of ZMAT in the alternative case. ! ja = 1 if ( beta >= zero ) ja = jl jb = jl + 1 - ja temp = zmat ( knew , jb ) / denom tempa = temp * beta tempb = temp * tau temp = zmat ( knew , ja ) scala = one / sqrt ( abs ( beta ) * temp * temp + tausq ) scalb = scala * sqrtdn do i = 1 , npt zmat ( i , ja ) = scala * ( tau * zmat ( i , ja ) - temp * vlag ( i )) zmat ( i , jb ) = scalb * ( zmat ( i , jb ) - tempa * w ( i ) - tempb * vlag ( i )) end do if ( denom <= zero ) then if ( beta < zero ) then idz = idz + 1 else iflag = 1 end if end if end if ! !     Reduce IDZ when the diagonal part of the ZMAT times Diag(DZ) times !       ZMAT&#94;T factorization gains another positive element. Then exchange !       the first and IDZ-th columns of ZMAT. ! if ( iflag == 1 ) then idz = idz - 1 do i = 1 , npt temp = zmat ( i , 1 ) zmat ( i , 1 ) = zmat ( i , idz ) zmat ( i , idz ) = temp end do end if ! !     Finally, update the matrix BMAT. ! do j = 1 , n jp = npt + j w ( jp ) = bmat ( knew , j ) tempa = ( alpha * vlag ( jp ) - tau * w ( jp )) / denom tempb = ( - beta * w ( jp ) - tau * vlag ( jp )) / denom do i = 1 , jp bmat ( i , j ) = bmat ( i , j ) + tempa * vlag ( i ) + tempb * w ( i ) if ( i > npt ) bmat ( jp , i - npt ) = bmat ( i , j ) end do end do end subroutine update","tags":"","loc":"proc/update~2.html"},{"title":"lincoa_test – PowellOpt","text":"public  subroutine lincoa_test() Test problem for lincoa . Calculate the tetrahedron of least volume that encloses the points (XP(J),YP(J),ZP(J)), J=1,2,...,NP . Our method requires the origin\n  to be strictly inside the convex hull of these points. There are\n  twelve variables that define the four faces of each tetrahedron\n  that is considered. Each face has the form ALPHA*X+BETA*Y+GAMMA*Z=1 ,\n  the variables X(3K-2) , X(3K-1) and X(3K) being the values of ALPHA , BETA and GAMMA for the K-th face, K=1,2,3,4. Let the set T contain\n  all points in three dimensions that can be reached from the origin\n  without crossing a face. Because the volume of T may be infinite,\n  the objective function is the smaller of FMAX and the volume of T,\n  where FMAX is set to an upper bound on the final volume initially.\n  There are 4*NP linear constraints on the variables, namely that each\n  of the given points (XP(J),YP(J),ZP(J)) shall be in T. Let XS = min\n  XP(J) , YS = min YP(J) , ZS = min ZP(J) and SS = max XP(J)+YP(J)+ZP(J) ,\n  where J runs from 1 to NP. The initial values of the variables are X(1)=1/XS , X(5)=1/YS , X(9)=1/ZS , X(2)=X(3)=X(4)=X(6)=X(7)=X(8)=0 and X(10)=X(11)=X(12)=1/SS , which satisfy the linear constraints,\n  and which provide the bound FMAX=(SS-XS-YS-ZS)**3/6 . Other details\n  of the test calculation are given below, including the choice of\n  the data points (XP(J),YP(J),ZP(J)), J=1,2,...,NP . The smaller final\n  value of the objective function in the case NPT=35 shows that the\n  problem has local minima. Arguments None Calls proc~~lincoa_test~~CallsGraph proc~lincoa_test lincoa_test proc~lincoa lincoa proc~lincoa_test->proc~lincoa proc~lincob lincob proc~lincoa->proc~lincob proc~prelim prelim proc~lincob->proc~prelim proc~qmstep qmstep proc~lincob->proc~qmstep proc~trstep trstep proc~lincob->proc~trstep proc~update~2 update proc~lincob->proc~update~2 proc~prelim->proc~update~2 proc~getact getact proc~trstep->proc~getact Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lincoa_test () implicit none real ( wp ) :: xp ( 50 ), yp ( 50 ), zp ( 50 ), a ( 12 , 200 ), b ( 200 ), x ( 12 ) integer :: ia , n , np , j , iw , iprint , jcase , k , i , maxfun , npt , m real ( wp ) :: sumx , sumy , sumz , theta , fmax , rhobeg , rhoend , ss , xs , ys , zs ! !     Set some constants. ! real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: two = 2.0_wp real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: pi = 4.0_wp * atan ( one ) ia = 12 n = 12 ! !     Set the data points. ! np = 50 sumx = zero sumy = zero sumz = zero do j = 1 , np theta = real ( j - 1 , wp ) * pi / real ( np - 1 , wp ) xp ( j ) = cos ( theta ) * cos ( two * theta ) sumx = sumx + xp ( j ) yp ( j ) = sin ( theta ) * cos ( two * theta ) sumy = sumy + yp ( j ) zp ( j ) = sin ( two * theta ) sumz = sumz + zp ( j ) end do sumx = sumx / real ( np , wp ) sumy = sumy / real ( np , wp ) sumz = sumz / real ( np , wp ) do j = 1 , np xp ( j ) = xp ( j ) - sumx yp ( j ) = yp ( j ) - sumy zp ( j ) = zp ( j ) - sumz end do ! !     Set the linear constraints. ! m = 4 * np do k = 1 , m b ( k ) = one do i = 1 , n a ( i , k ) = zero end do end do do j = 1 , np do i = 1 , 4 k = 4 * j + i - 4 iw = 3 * i a ( iw - 2 , k ) = xp ( j ) a ( iw - 1 , k ) = yp ( j ) a ( iw , k ) = zp ( j ) end do end do ! !     Set the initial vector of variables. The JCASE=1,6 loop gives six !       different choices of NPT when LINCOA is called. ! xs = zero ys = zero zs = zero ss = zero do j = 1 , np xs = min ( xs , xp ( j )) ys = min ( ys , yp ( j )) zs = min ( zs , zp ( j )) ss = max ( ss , xp ( j ) + yp ( j ) + zp ( j )) end do fmax = ( ss - xs - ys - zs ) ** 3 / 6.0_wp do jcase = 1 , 6 do i = 2 , 8 x ( i ) = zero end do x ( 1 ) = one / xs x ( 5 ) = one / ys x ( 9 ) = one / zs x ( 10 ) = one / ss x ( 11 ) = one / ss x ( 12 ) = one / ss ! !     Call of LINCOA, which provides the printing given at the end of this !       note. ! npt = 5 * jcase + 10 rhobeg = 1.0_wp rhoend = 1.0e-6_wp iprint = 1 maxfun = 10000 print 70 , npt , rhoend 70 format ( / / 4 x , 'Output from LINCOA with  NPT =' , i4 , '  and  RHOEND =' , 1 & & pd12 . 4 ) call lincoa ( n , npt , m , a , ia , b , x , rhobeg , rhoend , iprint , maxfun , calfun ) end do contains subroutine calfun ( n , x , f ) implicit none integer :: n real ( wp ) :: x ( * ) real ( wp ) :: f real ( wp ) :: v12 , v13 , v14 , v23 , v24 , v34 , del1 , del2 , del3 , del4 , temp f = fmax v12 = x ( 1 ) * x ( 5 ) - x ( 4 ) * x ( 2 ) v13 = x ( 1 ) * x ( 8 ) - x ( 7 ) * x ( 2 ) v14 = x ( 1 ) * x ( 11 ) - x ( 10 ) * x ( 2 ) v23 = x ( 4 ) * x ( 8 ) - x ( 7 ) * x ( 5 ) v24 = x ( 4 ) * x ( 11 ) - x ( 10 ) * x ( 5 ) v34 = x ( 7 ) * x ( 11 ) - x ( 10 ) * x ( 8 ) del1 = v23 * x ( 12 ) - v24 * x ( 9 ) + v34 * x ( 6 ) if ( del1 <= zero ) return del2 = - v34 * x ( 3 ) - v13 * x ( 12 ) + v14 * x ( 9 ) if ( del2 <= zero ) return del3 = - v14 * x ( 6 ) + v24 * x ( 3 ) + v12 * x ( 12 ) if ( del3 <= zero ) return del4 = - v12 * x ( 9 ) + v13 * x ( 6 ) - v23 * x ( 3 ) if ( del4 <= zero ) return temp = ( del1 + del2 + del3 + del4 ) ** 3 / ( del1 * del2 * del3 * del4 ) f = min ( temp / 6.0_wp , fmax ) end subroutine calfun end subroutine lincoa_test","tags":"","loc":"proc/lincoa_test.html"},{"title":"uobyqa – PowellOpt","text":"public  subroutine uobyqa(n, x, rhobeg, rhoend, iprint, maxfun, calfun) This subroutine seeks the least value of a function of many variables,\nby a trust region method that forms quadratic models by interpolation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the number of variables and must be at least two real(kind=wp), intent(inout), dimension(*) :: x Initial values of the variables must be set in X(1),X(2),...,X(N). They\nwill be changed to the values that give the least calculated F. real(kind=wp), intent(in) :: rhobeg RHOBEG and RHOEND must be set to the initial and final values of a trust\nregion radius, so both must be positive with RHOEND<=RHOBEG. Typically\nRHOBEG should be about one tenth of the greatest expected change to a\nvariable, and RHOEND should indicate the accuracy that is required in\nthe final values of the variables. real(kind=wp), intent(in) :: rhoend RHOBEG and RHOEND must be set to the initial and final values of a trust\nregion radius, so both must be positive with RHOEND<=RHOBEG. Typically\nRHOBEG should be about one tenth of the greatest expected change to a\nvariable, and RHOEND should indicate the accuracy that is required in\nthe final values of the variables. integer, intent(in) :: iprint The value of IPRINT should be set to 0, 1, 2 or 3, which controls the\namount of printing. Specifically, there is no output if IPRINT=0 and\nthere is output only at the return if IPRINT=1. Otherwise, each new\nvalue of RHO is printed, with the best vector of variables so far and\nthe corresponding value of the objective function. Further, each new\nvalue of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun upper bound on the number of calls of CALFUN. procedure( func ) :: calfun It must set F to the value of the objective\nfunction for the variables X(1),X(2),...,X(N). Calls proc~~uobyqa~~CallsGraph proc~uobyqa uobyqa proc~uobyqb uobyqb proc~uobyqa->proc~uobyqb proc~lagmax lagmax proc~uobyqb->proc~lagmax proc~trstep~2 trstep proc~uobyqb->proc~trstep~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~uobyqa~~CalledByGraph proc~uobyqa uobyqa proc~uobyqa_test uobyqa_test proc~uobyqa_test->proc~uobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine uobyqa ( n , x , rhobeg , rhoend , iprint , maxfun , calfun ) implicit none integer , intent ( in ) :: n !! the number of variables and must be at least two real ( wp ), intent ( inout ), dimension ( * ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). They !! will be changed to the values that give the least calculated F. real ( wp ), intent ( in ) :: rhobeg !! RHOBEG and RHOEND must be set to the initial and final values of a trust !! region radius, so both must be positive with RHOEND<=RHOBEG. Typically !! RHOBEG should be about one tenth of the greatest expected change to a !! variable, and RHOEND should indicate the accuracy that is required in !! the final values of the variables. real ( wp ), intent ( in ) :: rhoend !! RHOBEG and RHOEND must be set to the initial and final values of a trust !! region radius, so both must be positive with RHOEND<=RHOBEG. Typically !! RHOBEG should be about one tenth of the greatest expected change to a !! variable, and RHOEND should indicate the accuracy that is required in !! the final values of the variables. integer , intent ( in ) :: iprint !! The value of IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, each new !! value of RHO is printed, with the best vector of variables so far and !! the corresponding value of the objective function. Further, each new !! value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! upper bound on the number of calls of CALFUN. procedure ( func ) :: calfun !! It must set F to the value of the objective !! function for the variables X(1),X(2),...,X(N). real ( wp ), dimension (:), allocatable :: w integer :: npt , ixb , ixo , ixn , ixp , ipq , ipl , ih , ig , id , ivl , iw ! Partition the working space array, so that different parts of it can be ! treated separately by the subroutine that performs the main calculation. npt = ( n * n + 3 * n + 2 ) / 2 ixb = 1 ixo = ixb + n ixn = ixo + n ixp = ixn + n ipq = ixp + n * npt ipl = ipq + npt - 1 ih = ipl + ( npt - 1 ) * npt ig = ih + n * n id = ig + n ivl = ih iw = id + n ! The array W will be used for working space allocate ( w (( N ** 4 + 8 * N ** 3 + 23 * N ** 2 + 42 * N + max ( 2 * N ** 2 + 4 , 18 * N )) / 4 )) call uobyqb ( n , x , rhobeg , rhoend , iprint , maxfun , npt , w ( ixb ), w ( ixo ), w ( ixn ), & w ( ixp ), w ( ipq ), w ( ipl ), w ( ih ), w ( ig ), w ( id ), w ( ivl ), w ( iw ), calfun ) deallocate ( w ) end subroutine uobyqa","tags":"","loc":"proc/uobyqa.html"},{"title":"uobyqb – PowellOpt","text":"private  subroutine uobyqb(n, x, rhobeg, rhoend, iprint, maxfun, npt, xbase, xopt, xnew, xpt, pq, pl, h, g, d, vlag, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n real :: x real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun integer :: npt real :: xbase real :: xopt real :: xnew real :: xpt real :: pq real :: pl real :: h real :: g real :: d real :: vlag real :: w procedure( func ) :: calfun Calls proc~~uobyqb~~CallsGraph proc~uobyqb uobyqb proc~lagmax lagmax proc~uobyqb->proc~lagmax proc~trstep~2 trstep proc~uobyqb->proc~trstep~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~uobyqb~~CalledByGraph proc~uobyqb uobyqb proc~uobyqa uobyqa proc~uobyqa->proc~uobyqb proc~uobyqa_test uobyqa_test proc~uobyqa_test->proc~uobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine uobyqb ( n , x , rhobeg , rhoend , iprint , maxfun , npt , xbase , xopt , xnew , xpt , & pq , pl , h , g , d , vlag , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension x ( * ), xbase ( * ), xopt ( * ), xnew ( * ), xpt ( npt , * ), pq ( * ), pl ( npt , * ), & h ( n , * ), g ( * ), d ( * ), vlag ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, X, RHOBEG, RHOEND, IPRINT and MAXFUN are identical to !       the corresponding arguments in SUBROUTINE UOBYQA. !     NPT is set by UOBYQA to (N*N+3*N+2)/2 for the above dimension statement. !     XBASE will contain a shift of origin that reduces the contributions from !       rounding errors to values of the model and Lagrange functions. !     XOPT will be set to the displacement from XBASE of the vector of !       variables that provides the least calculated F so far. !     XNEW will be set to the displacement from XBASE of the vector of !       variables for the current calculation of F. !     XPT will contain the interpolation point coordinates relative to XBASE. !     PQ will contain the parameters of the quadratic model. !     PL will contain the parameters of the Lagrange functions. !     H will provide the second derivatives that TRSTEP and LAGMAX require. !     G will provide the first derivatives that TRSTEP and LAGMAX require. !     D is reserved for trial steps from XOPT, except that it will contain !       diagonal second derivatives during the initialization procedure. !     VLAG will contain the values of the Lagrange functions at a new point X. !     The array W will be used for working space. Its length must be at least !     max [ 6*N, ( N**2 + 3*N + 2 ) / 2 ]. ! !     Set some constants. ! tol = 0.01_wp nnp = n + n + 1 nptm = npt - 1 nftest = max ( maxfun , 1 ) ! !     Initialization. NF is the number of function calculations so far. ! rho = rhobeg rhosq = rho * rho nf = 0 do i = 1 , n xbase ( i ) = x ( i ) do k = 1 , npt xpt ( k , i ) = zero end do end do do k = 1 , npt do j = 1 , nptm pl ( k , j ) = zero end do end do ! !     The branch to label 120 obtains a new value of the objective function !     and then there is a branch back to label 50, because the new function !     value is needed to form the initial quadratic model. The least function !     value so far and its index are noted below. ! 30 do i = 1 , n x ( i ) = xbase ( i ) + xpt ( nf + 1 , i ) end do go to 120 50 if ( nf == 1 ) then fopt = f kopt = nf fbase = f j = 0 jswitch = - 1 ih = n else if ( f < fopt ) then fopt = f kopt = nf end if end if ! !     Form the gradient and diagonal second derivatives of the initial !     quadratic model and Lagrange functions. ! if ( nf <= nnp ) then jswitch = - jswitch if ( jswitch > 0 ) then if ( j >= 1 ) then ih = ih + j if ( w ( j ) < zero ) then d ( j ) = ( fsave + f - two * fbase ) / rhosq pq ( j ) = ( fsave - f ) / ( two * rho ) pl ( 1 , ih ) = - two / rhosq pl ( nf - 1 , j ) = half / rho pl ( nf - 1 , ih ) = one / rhosq else pq ( j ) = ( 4.0_wp * fsave - 3.0_wp * fbase - f ) / ( two * rho ) d ( j ) = ( fbase + f - two * fsave ) / rhosq pl ( 1 , j ) = - 1.5_wp / rho pl ( 1 , ih ) = one / rhosq pl ( nf - 1 , j ) = two / rho pl ( nf - 1 , ih ) = - two / rhosq end if pq ( ih ) = d ( j ) pl ( nf , j ) = - half / rho pl ( nf , ih ) = one / rhosq end if ! !     Pick the shift from XBASE to the next initial interpolation point !     that provides diagonal second derivatives. ! if ( j < n ) then j = j + 1 xpt ( nf + 1 , j ) = rho end if else fsave = f if ( f < fbase ) then w ( j ) = rho xpt ( nf + 1 , j ) = two * rho else w ( j ) = - rho xpt ( nf + 1 , j ) = - rho end if end if if ( nf < nnp ) go to 30 ! !     Form the off-diagonal second derivatives of the initial quadratic model. ! ih = n ip = 1 iq = 2 end if ih = ih + 1 if ( nf > nnp ) then temp = one / ( w ( ip ) * w ( iq )) tempa = f - fbase - w ( ip ) * pq ( ip ) - w ( iq ) * pq ( iq ) pq ( ih ) = ( tempa - half * rhosq * ( d ( ip ) + d ( iq ))) * temp pl ( 1 , ih ) = temp iw = ip + ip if ( w ( ip ) < zero ) iw = iw + 1 pl ( iw , ih ) = - temp iw = iq + iq if ( w ( iq ) < zero ) iw = iw + 1 pl ( iw , ih ) = - temp pl ( nf , ih ) = temp ! !     Pick the shift from XBASE to the next initial interpolation point !     that provides off-diagonal second derivatives. ! ip = ip + 1 end if if ( ip == iq ) then ih = ih + 1 ip = 1 iq = iq + 1 end if if ( nf < npt ) then xpt ( nf + 1 , ip ) = w ( ip ) xpt ( nf + 1 , iq ) = w ( iq ) go to 30 end if ! !     Set parameters to begin the iterations for the current RHO. ! sixthm = zero delta = rho 60 tworsq = ( two * rho ) ** 2 rhosq = rho * rho ! !     Form the gradient of the quadratic model at the trust region centre. ! 70 knew = 0 ih = n do j = 1 , n xopt ( j ) = xpt ( kopt , j ) g ( j ) = pq ( j ) do i = 1 , j ih = ih + 1 g ( i ) = g ( i ) + pq ( ih ) * xopt ( j ) if ( i < j ) g ( j ) = g ( j ) + pq ( ih ) * xopt ( i ) h ( i , j ) = pq ( ih ) end do end do ! !     Generate the next trust region step and test its length. Set KNEW !     to -1 if the purpose of the next F will be to improve conditioning, !     and also calculate a lower bound on the Hessian term of the model Q. ! call trstep ( n , g , h , delta , tol , d , w ( 1 ), w ( n + 1 ), w ( 2 * n + 1 ), w ( 3 * n + 1 ), w ( 4 * n + 1 ), & w ( 5 * n + 1 ), evalue ) temp = zero do i = 1 , n temp = temp + d ( i ) ** 2 end do dnorm = min ( delta , sqrt ( temp )) errtol = - one if ( dnorm < half * rho ) then knew = - 1 errtol = half * evalue * rho * rho if ( nf <= npt + 9 ) errtol = zero go to 290 end if ! !     Calculate the next value of the objective function. ! 100 do i = 1 , n xnew ( i ) = xopt ( i ) + d ( i ) x ( i ) = xbase ( i ) + xnew ( i ) end do 120 if ( nf >= nftest ) then if ( iprint > 0 ) print 130 130 format ( / 4 x , 'Return from UOBYQA because CALFUN has been' ,& ' called MAXFUN times' ) go to 420 end if nf = nf + 1 call calfun ( n , x , f ) if ( iprint == 3 ) then print 140 , nf , f , ( x ( i ), i = 1 , n ) 140 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( nf <= npt ) go to 50 if ( knew ==- 1 ) go to 420 ! !     Use the quadratic model to predict the change in F due to the step D, !     and find the values of the Lagrange functions at the new point. ! vquad = zero ih = n do j = 1 , n w ( j ) = d ( j ) vquad = vquad + w ( j ) * pq ( j ) do i = 1 , j ih = ih + 1 w ( ih ) = d ( i ) * xnew ( j ) + d ( j ) * xopt ( i ) if ( i == j ) w ( ih ) = half * w ( ih ) vquad = vquad + w ( ih ) * pq ( ih ) end do end do do k = 1 , npt temp = zero do j = 1 , nptm temp = temp + w ( j ) * pl ( k , j ) end do vlag ( k ) = temp end do vlag ( kopt ) = vlag ( kopt ) + one ! !     Update SIXTHM, which is a lower bound on one sixth of the greatest !     third derivative of F. ! diff = f - fopt - vquad sum = zero do k = 1 , npt temp = zero do i = 1 , n temp = temp + ( xpt ( k , i ) - xnew ( i )) ** 2 end do temp = sqrt ( temp ) sum = sum + abs ( temp * temp * temp * vlag ( k )) end do sixthm = max ( sixthm , abs ( diff ) / sum ) ! !     Update FOPT and XOPT if the new F is the least value of the objective !     function so far. Then branch if D is not a trust region step. ! fsave = fopt if ( f < fopt ) then fopt = f do i = 1 , n xopt ( i ) = xnew ( i ) end do end if ksave = knew if ( knew > 0 ) go to 240 ! !     Pick the next value of DELTA after a trust region step. ! if ( vquad >= zero ) then if ( iprint > 0 ) print 210 210 format ( / 4 x , 'Return from UOBYQA because a trust' ,& ' region step has failed to reduce Q' ) go to 420 end if ratio = ( f - fsave ) / vquad if ( ratio <= 0.1_wp ) then delta = half * dnorm else if ( ratio <= 0.7_wp ) then delta = max ( half * delta , dnorm ) else delta = max ( delta , 1.25_wp * dnorm , dnorm + rho ) end if if ( delta <= 1.5_wp * rho ) delta = rho ! !     Set KNEW to the index of the next interpolation point to be deleted. ! ktemp = 0 detrat = zero if ( f >= fsave ) then ktemp = kopt detrat = one end if do k = 1 , npt sum = zero do i = 1 , n sum = sum + ( xpt ( k , i ) - xopt ( i )) ** 2 end do temp = abs ( vlag ( k )) if ( sum > rhosq ) temp = temp * ( sum / rhosq ) ** 1.5_wp if ( temp > detrat . and . k /= ktemp ) then detrat = temp ddknew = sum knew = k end if end do if ( knew == 0 ) go to 290 ! !     Replace the interpolation point that has index KNEW by the point XNEW, !     and also update the Lagrange functions and the quadratic model. ! 240 do i = 1 , n xpt ( knew , i ) = xnew ( i ) end do temp = one / vlag ( knew ) do j = 1 , nptm pl ( knew , j ) = temp * pl ( knew , j ) pq ( j ) = pq ( j ) + diff * pl ( knew , j ) end do do k = 1 , npt if ( k /= knew ) then temp = vlag ( k ) do j = 1 , nptm pl ( k , j ) = pl ( k , j ) - temp * pl ( knew , j ) end do end if end do ! !     Update KOPT if F is the least calculated value of the objective !     function. Then branch for another trust region calculation. The !     case KSAVE>0 indicates that a model step has just been taken. ! if ( f < fsave ) then kopt = knew go to 70 end if if ( ksave > 0 ) go to 70 if ( dnorm > two * rho ) go to 70 if ( ddknew > tworsq ) go to 70 ! !     Alternatively, find out if the interpolation points are close !     enough to the best point so far. ! 290 do k = 1 , npt w ( k ) = zero do i = 1 , n w ( k ) = w ( k ) + ( xpt ( k , i ) - xopt ( i )) ** 2 end do end do 310 knew = - 1 distest = tworsq do k = 1 , npt if ( w ( k ) > distest ) then knew = k distest = w ( k ) end if end do ! !     If a point is sufficiently far away, then set the gradient and Hessian !     of its Lagrange function at the centre of the trust region, and find !     half the sum of squares of components of the Hessian. ! if ( knew > 0 ) then ih = n sumh = zero do j = 1 , n g ( j ) = pl ( knew , j ) do i = 1 , j ih = ih + 1 temp = pl ( knew , ih ) g ( j ) = g ( j ) + temp * xopt ( i ) if ( i < j ) then g ( i ) = g ( i ) + temp * xopt ( j ) sumh = sumh + temp * temp end if h ( i , j ) = temp end do sumh = sumh + half * temp * temp end do ! !     If ERRTOL is positive, test whether to replace the interpolation point !     with index KNEW, using a bound on the maximum modulus of its Lagrange !     function in the trust region. ! if ( errtol > zero ) then w ( knew ) = zero sumg = zero do i = 1 , n sumg = sumg + g ( i ) ** 2 end do estim = rho * ( sqrt ( sumg ) + rho * sqrt ( half * sumh )) wmult = sixthm * distest ** 1.5_wp if ( wmult * estim <= errtol ) go to 310 end if ! !     If the KNEW-th point may be replaced, then pick a D that gives a large !     value of the modulus of its Lagrange function within the trust region. !     Here the vector XNEW is used as temporary working space. ! call lagmax ( n , g , h , rho , d , xnew , vmax ) if ( errtol > zero ) then if ( wmult * vmax <= errtol ) go to 310 end if go to 100 end if if ( dnorm > rho ) go to 70 ! !     Prepare to reduce RHO by shifting XBASE to the best point so far, !     and make the corresponding changes to the gradients of the Lagrange !     functions and the quadratic model. ! if ( rho > rhoend ) then ih = n do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) do k = 1 , npt xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) end do do i = 1 , j ih = ih + 1 pq ( i ) = pq ( i ) + pq ( ih ) * xopt ( j ) if ( i < j ) then pq ( j ) = pq ( j ) + pq ( ih ) * xopt ( i ) do k = 1 , npt pl ( k , j ) = pl ( k , j ) + pl ( k , ih ) * xopt ( i ) end do end if do k = 1 , npt pl ( k , i ) = pl ( k , i ) + pl ( k , ih ) * xopt ( j ) end do end do end do ! !     Pick the next values of RHO and DELTA. ! delta = half * rho ratio = rho / rhoend if ( ratio <= 1 6.0_wp ) then rho = rhoend else if ( ratio <= 25 0.0_wp ) then rho = sqrt ( ratio ) * rhoend else rho = 0.1_wp * rho end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) print 390 390 format ( 5 x ) print 400 , rho , nf 400 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 410 , fopt , ( xbase ( i ), i = 1 , n ) 410 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if go to 60 end if ! !     Return from the calculation, after another Newton-Raphson step, if !     it is too short to have been tried before. ! if ( errtol >= zero ) go to 100 420 if ( fopt <= f ) then do i = 1 , n x ( i ) = xbase ( i ) + xopt ( i ) end do f = fopt end if if ( iprint >= 1 ) then print 440 , nf 440 format ( / 4 x , 'At the return from UOBYQA' , 5 x ,& 'Number of function values =' , i6 ) print 410 , f , ( x ( i ), i = 1 , n ) end if end subroutine uobyqb","tags":"","loc":"proc/uobyqb.html"},{"title":"lagmax – PowellOpt","text":"private  subroutine lagmax(n, g, h, rho, d, v, vmax) Arguments Type Intent Optional Attributes Name integer :: n real :: g real :: h real :: rho real :: d real :: v real :: vmax Called by proc~~lagmax~~CalledByGraph proc~lagmax lagmax proc~uobyqb uobyqb proc~uobyqb->proc~lagmax proc~uobyqa uobyqa proc~uobyqa->proc~uobyqb proc~uobyqa_test uobyqa_test proc~uobyqa_test->proc~uobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lagmax ( n , g , h , rho , d , v , vmax ) implicit real ( wp ) ( a - h , o - z ) dimension g ( * ), h ( n , * ), d ( * ), v ( * ) ! !     N is the number of variables of a quadratic objective function, Q say. !     G is the gradient of Q at the origin. !     H is the symmetric Hessian matrix of Q. Only the upper triangular and !       diagonal parts need be set. !     RHO is the trust region radius, and has to be positive. !     D will be set to the calculated vector of variables. !     The array V will be used for working space. !     VMAX will be set to |Q(0)-Q(D)|. ! !     Calculating the D that maximizes |Q(0)-Q(D)| subject to ||D|| .LEQ. RHO !     requires of order N**3 operations, but sometimes it is adequate if !     |Q(0)-Q(D)| is within about 0.9 of its greatest possible value. This !     subroutine provides such a solution in only of order N**2 operations, !     where the claim of accuracy has been tested by numerical experiments. ! !     Preliminary calculations. ! ! !     Pick V such that ||HV|| / ||V|| is large. ! hmax = zero do i = 1 , n sum = zero do j = 1 , n h ( j , i ) = h ( i , j ) sum = sum + h ( i , j ) ** 2 end do if ( sum > hmax ) then hmax = sum k = i end if end do do j = 1 , n v ( j ) = h ( k , j ) end do ! !     Set D to a vector in the subspace spanned by V and HV that maximizes !     |(D,HD)|/(D,D), except that we set D=HV if V and HV are nearly parallel. !     The vector that has the name D at label 60 used to be the vector W. ! vsq = zero vhv = zero dsq = zero do i = 1 , n vsq = vsq + v ( i ) ** 2 d ( i ) = zero do j = 1 , n d ( i ) = d ( i ) + h ( i , j ) * v ( j ) end do vhv = vhv + v ( i ) * d ( i ) dsq = dsq + d ( i ) ** 2 end do if ( vhv * vhv <= 0.9999_wp * dsq * vsq ) then temp = vhv / vsq wsq = zero do i = 1 , n d ( i ) = d ( i ) - temp * v ( i ) wsq = wsq + d ( i ) ** 2 end do whw = zero ratio = sqrt ( wsq / vsq ) do i = 1 , n temp = zero do j = 1 , n temp = temp + h ( i , j ) * d ( j ) end do whw = whw + temp * d ( i ) v ( i ) = ratio * v ( i ) end do vhv = ratio * ratio * vhv vhw = ratio * wsq temp = half * ( whw - vhv ) temp = temp + sign ( sqrt ( temp ** 2 + vhw ** 2 ), whw + vhv ) do i = 1 , n d ( i ) = vhw * v ( i ) + temp * d ( i ) end do end if ! !     We now turn our attention to the subspace spanned by G and D. A multiple !     of the current D is returned if that choice seems to be adequate. ! gg = zero gd = zero dd = zero dhd = zero do i = 1 , n gg = gg + g ( i ) ** 2 gd = gd + g ( i ) * d ( i ) dd = dd + d ( i ) ** 2 sum = zero do j = 1 , n sum = sum + h ( i , j ) * d ( j ) end do dhd = dhd + sum * d ( i ) end do temp = gd / gg vv = zero scale = sign ( rho / sqrt ( dd ), gd * dhd ) do i = 1 , n v ( i ) = d ( i ) - temp * g ( i ) vv = vv + v ( i ) ** 2 d ( i ) = scale * d ( i ) end do gnorm = sqrt ( gg ) if ( gnorm * dd <= 0.5e-2_wp * rho * abs ( dhd ) . or . vv / dd <= 1.0e-4_wp ) then vmax = abs ( scale * ( gd + half * scale * dhd )) return end if ! !     G and V are now orthogonal in the subspace spanned by G and D. Hence !     we generate an orthonormal basis of this subspace such that (D,HV) is !     negligible or zero, where D and V will be the basis vectors. ! ghg = zero vhg = zero vhv = zero do i = 1 , n sum = zero sumv = zero do j = 1 , n sum = sum + h ( i , j ) * g ( j ) sumv = sumv + h ( i , j ) * v ( j ) end do ghg = ghg + sum * g ( i ) vhg = vhg + sumv * g ( i ) vhv = vhv + sumv * v ( i ) end do vnorm = sqrt ( vv ) ghg = ghg / gg vhg = vhg / ( vnorm * gnorm ) vhv = vhv / vv if ( abs ( vhg ) <= 0.01_wp * max ( abs ( ghg ), abs ( vhv ))) then vmu = ghg - vhv wcos = one wsin = zero else temp = half * ( ghg - vhv ) vmu = temp + sign ( sqrt ( temp ** 2 + vhg ** 2 ), temp ) temp = sqrt ( vmu ** 2 + vhg ** 2 ) wcos = vmu / temp wsin = vhg / temp end if tempa = wcos / gnorm tempb = wsin / vnorm tempc = wcos / vnorm tempd = wsin / gnorm do i = 1 , n d ( i ) = tempa * g ( i ) + tempb * v ( i ) v ( i ) = tempc * v ( i ) - tempd * g ( i ) end do ! !     The final D is a multiple of the current D, V, D+V or D-V. We make the !     choice from these possibilities that is optimal. ! dlin = wcos * gnorm / rho vlin = - wsin * gnorm / rho tempa = abs ( dlin ) + half * abs ( vmu + vhv ) tempb = abs ( vlin ) + half * abs ( ghg - vmu ) tempc = halfrt * ( abs ( dlin ) + abs ( vlin )) + 0.25_wp * abs ( ghg + vhv ) if ( tempa >= tempb . and . tempa >= tempc ) then tempd = sign ( rho , dlin * ( vmu + vhv )) tempv = zero else if ( tempb >= tempc ) then tempd = zero tempv = sign ( rho , vlin * ( ghg - vmu )) else tempd = sign ( halfrt * rho , dlin * ( ghg + vhv )) tempv = sign ( halfrt * rho , vlin * ( ghg + vhv )) end if do i = 1 , n d ( i ) = tempd * d ( i ) + tempv * v ( i ) end do vmax = rho * rho * max ( tempa , tempb , tempc ) end subroutine lagmax","tags":"","loc":"proc/lagmax.html"},{"title":"trstep – PowellOpt","text":"private  subroutine trstep(n, g, h, delta, tol, d, gg, td, tn, w, piv, z, evalue) Arguments Type Intent Optional Attributes Name integer :: n real :: g real :: h real :: delta real :: tol real :: d real :: gg real :: td real :: tn real :: w real :: piv real :: z real :: evalue Called by proc~~trstep~2~~CalledByGraph proc~trstep~2 trstep proc~uobyqb uobyqb proc~uobyqb->proc~trstep~2 proc~uobyqa uobyqa proc~uobyqa->proc~uobyqb proc~uobyqa_test uobyqa_test proc~uobyqa_test->proc~uobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine trstep ( n , g , h , delta , tol , d , gg , td , tn , w , piv , z , evalue ) implicit real ( wp ) ( a - h , o - z ) dimension g ( * ), h ( n , * ), d ( * ), gg ( * ), td ( * ), tn ( * ), w ( * ), piv ( * ), z ( * ) ! !     N is the number of variables of a quadratic objective function, Q say. !     G is the gradient of Q at the origin. !     H is the Hessian matrix of Q. Only the upper triangular and diagonal !       parts need be set. The lower triangular part is used to store the !       elements of a Householder similarity transformation. !     DELTA is the trust region radius, and has to be positive. !     TOL is the value of a tolerance from the open interval (0,1). !     D will be set to the calculated vector of variables. !     The arrays GG, TD, TN, W, PIV and Z will be used for working space. !     EVALUE will be set to the least eigenvalue of H if and only if D is a !     Newton-Raphson step. Then EVALUE will be positive, but otherwise it !     will be set to zero. ! !     Let MAXRED be the maximum of Q(0)-Q(D) subject to ||D|| .LEQ. DELTA, !     and let ACTRED be the value of Q(0)-Q(D) that is actually calculated. !     We take the view that any D is acceptable if it has the properties ! !             ||D|| .LEQ. DELTA  and  ACTRED .LEQ. (1-TOL)*MAXRED. ! !     The calculation of D is done by the method of Section 2 of the paper !     by MJDP in the 1997 Dundee Numerical Analysis Conference Proceedings, !     after transforming H to tridiagonal form. ! !     Initialization. ! delsq = delta * delta evalue = zero nm = n - 1 do i = 1 , n d ( i ) = zero td ( i ) = h ( i , i ) do j = 1 , i h ( i , j ) = h ( j , i ) end do end do ! !     Apply Householder transformations to obtain a tridiagonal matrix that !     is similar to H, and put the elements of the Householder vectors in !     the lower triangular part of H. Further, TD and TN will contain the !     diagonal and other nonzero elements of the tridiagonal matrix. ! do k = 1 , nm kp = k + 1 sum = zero if ( kp < n ) then kpp = kp + 1 do i = kpp , n sum = sum + h ( i , k ) ** 2 end do end if if ( sum == zero ) then tn ( k ) = h ( kp , k ) h ( kp , k ) = zero else temp = h ( kp , k ) tn ( k ) = sign ( sqrt ( sum + temp * temp ), temp ) h ( kp , k ) = - sum / ( temp + tn ( k )) temp = sqrt ( two / ( sum + h ( kp , k ) ** 2 )) do i = kp , n w ( i ) = temp * h ( i , k ) h ( i , k ) = w ( i ) z ( i ) = td ( i ) * w ( i ) end do wz = zero do j = kp , nm jp = j + 1 do i = jp , n z ( i ) = z ( i ) + h ( i , j ) * w ( j ) z ( j ) = z ( j ) + h ( i , j ) * w ( i ) end do wz = wz + w ( j ) * z ( j ) end do wz = wz + w ( n ) * z ( n ) do j = kp , n td ( j ) = td ( j ) + w ( j ) * ( wz * w ( j ) - two * z ( j )) if ( j < n ) then jp = j + 1 do i = jp , n h ( i , j ) = h ( i , j ) - w ( i ) * z ( j ) - w ( j ) * ( z ( i ) - wz * w ( i )) end do end if end do end if end do ! !     Form GG by applying the similarity transformation to G. ! gsq = zero do i = 1 , n gg ( i ) = g ( i ) gsq = gsq + g ( i ) ** 2 end do gnorm = sqrt ( gsq ) do k = 1 , nm kp = k + 1 sum = zero do i = kp , n sum = sum + gg ( i ) * h ( i , k ) end do do i = kp , n gg ( i ) = gg ( i ) - sum * h ( i , k ) end do end do ! !     Begin the trust region calculation with a tridiagonal matrix by !     calculating the norm of H. Then treat the case when H is zero. ! hnorm = abs ( td ( 1 )) + abs ( tn ( 1 )) tdmin = td ( 1 ) tn ( n ) = zero do i = 2 , n temp = abs ( tn ( i - 1 )) + abs ( td ( i )) + abs ( tn ( i )) hnorm = max ( hnorm , temp ) tdmin = min ( tdmin , td ( i )) end do if ( hnorm == zero ) then if ( gnorm == zero ) return scale = delta / gnorm do i = 1 , n d ( i ) = - scale * gg ( i ) end do go to 370 end if ! !     Set the initial values of PAR and its bounds. ! parl = max ( zero , - tdmin , gnorm / delta - hnorm ) parlest = parl par = parl paru = zero paruest = zero posdef = zero iterc = 0 ! !     Calculate the pivots of the Cholesky factorization of (H+PAR*I). ! 140 iterc = iterc + 1 ksav = 0 piv ( 1 ) = td ( 1 ) + par k = 1 150 if ( piv ( k ) > zero ) then piv ( k + 1 ) = td ( k + 1 ) + par - tn ( k ) ** 2 / piv ( k ) else if ( piv ( k ) < zero . or . tn ( k ) /= zero ) go to 160 ksav = k piv ( k + 1 ) = td ( k + 1 ) + par end if k = k + 1 if ( k < n ) go to 150 if ( piv ( k ) < zero ) go to 160 if ( piv ( k ) == zero ) ksav = k ! !     Branch if all the pivots are positive, allowing for the case when !     G is zero. ! if ( ksav == 0 . and . gsq > zero ) go to 230 if ( gsq == zero ) then if ( par == zero ) go to 370 paru = par paruest = par if ( ksav == 0 ) go to 190 end if k = ksav ! !     Set D to a direction of nonpositive curvature of the given tridiagonal !     matrix, and thus revise PARLEST. ! 160 d ( k ) = one if ( abs ( tn ( k )) <= abs ( piv ( k ))) then dsq = one dhd = piv ( k ) else temp = td ( k + 1 ) + par if ( temp <= abs ( piv ( k ))) then d ( k + 1 ) = sign ( one , - tn ( k )) dhd = piv ( k ) + temp - two * abs ( tn ( k )) else d ( k + 1 ) = - tn ( k ) / temp dhd = piv ( k ) + tn ( k ) * d ( k + 1 ) end if dsq = one + d ( k + 1 ) ** 2 end if 170 if ( k > 1 ) then k = k - 1 if ( tn ( k ) /= zero ) then d ( k ) = - tn ( k ) * d ( k + 1 ) / piv ( k ) dsq = dsq + d ( k ) ** 2 go to 170 end if do i = 1 , k d ( i ) = zero end do end if parl = par parlest = par - dhd / dsq ! !     Terminate with D set to a multiple of the current D if the following !     test suggests that it suitable to do so. ! 190 temp = paruest if ( gsq == zero ) temp = temp * ( one - tol ) if ( paruest > zero . and . parlest >= temp ) then dtg = zero do i = 1 , n dtg = dtg + d ( i ) * gg ( i ) end do scale = - sign ( delta / sqrt ( dsq ), dtg ) do i = 1 , n d ( i ) = scale * d ( i ) end do go to 370 end if ! !     Pick the value of PAR for the next iteration. ! 220 if ( paru == zero ) then par = two * parlest + gnorm / delta else par = 0.5_wp * ( parl + paru ) par = max ( par , parlest ) end if if ( paruest > zero ) par = min ( par , paruest ) go to 140 ! !     Calculate D for the current PAR in the positive definite case. ! 230 w ( 1 ) = - gg ( 1 ) / piv ( 1 ) do i = 2 , n w ( i ) = ( - gg ( i ) - tn ( i - 1 ) * w ( i - 1 )) / piv ( i ) end do d ( n ) = w ( n ) do i = nm , 1 , - 1 d ( i ) = w ( i ) - tn ( i ) * d ( i + 1 ) / piv ( i ) end do ! !     Branch if a Newton-Raphson step is acceptable. ! dsq = zero wsq = zero do i = 1 , n dsq = dsq + d ( i ) ** 2 wsq = wsq + piv ( i ) * w ( i ) ** 2 end do if ( par == zero . and . dsq <= delsq ) go to 320 ! !     Make the usual test for acceptability of a full trust region step. ! dnorm = sqrt ( dsq ) phi = one / dnorm - one / delta temp = tol * ( one + par * dsq / wsq ) - dsq * phi * phi if ( temp >= zero ) then scale = delta / dnorm do i = 1 , n d ( i ) = scale * d ( i ) end do go to 370 end if if ( iterc >= 2 . and . par <= parl ) go to 370 if ( paru > zero . and . par >= paru ) go to 370 ! !     Complete the iteration when PHI is negative. ! if ( phi < zero ) then parlest = par if ( posdef == one ) then if ( phi <= phil ) go to 370 slope = ( phi - phil ) / ( par - parl ) parlest = par - phi / slope end if slope = one / gnorm if ( paru > zero ) slope = ( phiu - phi ) / ( paru - par ) temp = par - phi / slope if ( paruest > zero ) temp = min ( temp , paruest ) paruest = temp posdef = one parl = par phil = phi go to 220 end if ! !     If required, calculate Z for the alternative test for convergence. ! if ( posdef == zero ) then w ( 1 ) = one / piv ( 1 ) do i = 2 , n temp = - tn ( i - 1 ) * w ( i - 1 ) w ( i ) = ( sign ( one , temp ) + temp ) / piv ( i ) end do z ( n ) = w ( n ) do i = nm , 1 , - 1 z ( i ) = w ( i ) - tn ( i ) * z ( i + 1 ) / piv ( i ) end do wwsq = zero zsq = zero dtz = zero do i = 1 , n wwsq = wwsq + piv ( i ) * w ( i ) ** 2 zsq = zsq + z ( i ) ** 2 dtz = dtz + d ( i ) * z ( i ) end do ! !     Apply the alternative test for convergence. ! tempa = abs ( delsq - dsq ) tempb = sqrt ( dtz * dtz + tempa * zsq ) gam = tempa / ( sign ( tempb , dtz ) + dtz ) temp = tol * ( wsq + par * delsq ) - gam * gam * wwsq if ( temp >= zero ) then do i = 1 , n d ( i ) = d ( i ) + gam * z ( i ) end do go to 370 end if parlest = max ( parlest , par - wwsq / zsq ) end if ! !     Complete the iteration when PHI is positive. ! slope = one / gnorm if ( paru > zero ) then if ( phi >= phiu ) go to 370 slope = ( phiu - phi ) / ( paru - par ) end if parlest = max ( parlest , par - phi / slope ) paruest = par if ( posdef == one ) then slope = ( phi - phil ) / ( par - parl ) paruest = par - phi / slope end if paru = par phiu = phi go to 220 ! !     Set EVALUE to the least eigenvalue of the second derivative matrix if !     D is a Newton-Raphson step. SHFMAX will be an upper bound on EVALUE. ! 320 shfmin = zero pivot = td ( 1 ) shfmax = pivot do k = 2 , n pivot = td ( k ) - tn ( k - 1 ) ** 2 / pivot shfmax = min ( shfmax , pivot ) end do ! !     Find EVALUE by a bisection method, but occasionally SHFMAX may be !     adjusted by the rule of false position. ! ksave = 0 340 shift = 0.5_wp * ( shfmin + shfmax ) k = 1 temp = td ( 1 ) - shift 350 if ( temp > zero ) then piv ( k ) = temp if ( k < n ) then temp = td ( k + 1 ) - shift - tn ( k ) ** 2 / temp k = k + 1 go to 350 end if shfmin = shift else if ( k < ksave ) go to 360 if ( k == ksave ) then if ( pivksv == zero ) go to 360 if ( piv ( k ) - temp < temp - pivksv ) then pivksv = temp shfmax = shift else pivksv = zero shfmax = ( shift * piv ( k ) - shfmin * temp ) / ( piv ( k ) - temp ) end if else ksave = k pivksv = temp shfmax = shift end if end if if ( shfmin <= 0.99_wp * shfmax ) go to 340 360 evalue = shfmin ! !     Apply the inverse Householder transformations to D. ! 370 nm = n - 1 do k = nm , 1 , - 1 kp = k + 1 sum = zero do i = kp , n sum = sum + d ( i ) * h ( i , k ) end do do i = kp , n d ( i ) = d ( i ) - sum * h ( i , k ) end do end do end subroutine trstep","tags":"","loc":"proc/trstep~2.html"},{"title":"uobyqa_test – PowellOpt","text":"public  subroutine uobyqa_test() The Chebyquad test problem (Fletcher, 1965) for N = 2,4,6,8. Arguments None Calls proc~~uobyqa_test~~CallsGraph proc~uobyqa_test uobyqa_test proc~uobyqa uobyqa proc~uobyqa_test->proc~uobyqa proc~uobyqb uobyqb proc~uobyqa->proc~uobyqb proc~lagmax lagmax proc~uobyqb->proc~lagmax proc~trstep~2 trstep proc~uobyqb->proc~trstep~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine uobyqa_test () implicit none real ( wp ) :: x ( 10 ) integer :: iprint , maxfun , i , n real ( wp ) :: rhoend , rhobeg iprint = 2 maxfun = 5000 rhoend = 1.0e-8_wp do n = 2 , 8 , 2 do i = 1 , n x ( i ) = real ( i , wp ) / real ( n + 1 , wp ) end do rhobeg = 0.2_wp * x ( 1 ) print 20 , n 20 format ( / / 5 x , '******************' / 5 x , 'Results with N =' , i2 , / 5 x ,& '******************' ) call uobyqa ( n , x , rhobeg , rhoend , iprint , maxfun , calfun ) end do contains subroutine calfun ( n , x , f ) implicit none integer :: n real ( wp ) :: x ( * ) real ( wp ) :: f real ( wp ) :: y ( 10 , 10 ) real ( wp ) :: sum integer :: j , i , iw , np do j = 1 , n y ( 1 , j ) = 1.0_wp y ( 2 , j ) = 2.0_wp * x ( j ) - 1.0_wp end do do i = 2 , n do j = 1 , n y ( i + 1 , j ) = 2.0_wp * y ( 2 , j ) * y ( i , j ) - y ( i - 1 , j ) end do end do f = 0.0_wp np = n + 1 iw = 1 do i = 1 , np sum = 0.0_wp do j = 1 , n sum = sum + y ( i , j ) end do sum = sum / real ( n , wp ) if ( iw > 0 ) sum = sum + 1.0_wp / real ( i * i - 2 * i , wp ) iw = - iw f = f + sum * sum end do end subroutine calfun end subroutine uobyqa_test","tags":"","loc":"proc/uobyqa_test.html"},{"title":"bobyqa – PowellOpt","text":"public  subroutine bobyqa(n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, calfun) This subroutine seeks the least value of a function of many variables,\nby applying a trust region method that forms quadratic models by\ninterpolation. There is usually some freedom in the interpolation\nconditions, which is taken up by minimizing the Frobenius norm of\nthe change to the second derivative of the model, beginning with the\nzero matrix. The values of the variables are constrained by upper and\nlower bounds. In addition to providing CALFUN, an initial vector of variables and\nthe lower and upper bounds, the user has to set the values of the parameters RHOBEG , RHOEND and NPT . After scaling the individual variables\nif necessary, so that the magnitudes of their expected changes are similar, RHOBEG is the initial steplength for changes to the variables, a reasonable choice\nbeing the mesh size of a coarse grid search. Further, RHOEND should be suitable for\na search on a very fine grid. Typically, the software calculates a vector\nof variables that is within distance 10*RHOEND of a local minimum. Another\nconsideration is that every trial vector of variables is forced to satisfy\nthe lower and upper bounds, but there has to be room to make a search in all\ndirections. Therefore an error return occurs if the difference between the\nbounds on any variable is less than 2*RHOBEG . The parameter NPT specifies\nthe number of interpolation conditions on each quadratic model, the value NPT=2*N+1 being recommended for a start, where N is the number of\nvariables. It is often worthwhile to try other choices too, but much larger values\ntend to be inefficient, because the amount of routine work of each iteration is\nof magnitude NPT**2 , and because the achievement of adequate accuracy in some\nmatrix calculations becomes more difficult. Some excellent numerical results\nhave been found in the case NPT=N+6 even with more than 100 variables. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n number of variables (must be at least two) integer, intent(in) :: npt number of interpolation conditions. Its value must be in\nthe interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not\nrecommended. real(kind=wp), intent(inout), dimension(:) :: x Initial values of the variables must be set in X(1),X(2),...,X(N). They\nwill be changed to the values that give the least calculated F. real(kind=wp), intent(in), dimension(:) :: xl lower bounds on x. The construction of quadratic models\nrequires XL(I) to be strictly less than XU(I) for each I. Further,\nthe contribution to a model from changes to the I-th variable is\ndamaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=wp), intent(in), dimension(:) :: xu upper bounds on x. The construction of quadratic models\nrequires XL(I) to be strictly less than XU(I) for each I. Further,\nthe contribution to a model from changes to the I-th variable is\ndamaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=wp), intent(in) :: rhobeg RHOBEG must be set to the initial value of a trust region radius.\nIt must be positive, and typically should be about one tenth of the greatest\nexpected change to a variable.  An error return occurs if any of\nthe differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real(kind=wp), intent(in) :: rhoend RHOEND must be set to the final value of a trust\nregion radius. It must be positive with RHOEND no greater than\nRHOBEG. Typically, RHOEND should indicate the\naccuracy that is required in the final values of the variables. integer, intent(in) :: iprint IPRINT should be set to 0, 1, 2 or 3, which controls the\namount of printing. Specifically, there is no output if IPRINT=0 and\nthere is output only at the return if IPRINT=1. Otherwise, each new\nvalue of RHO is printed, with the best vector of variables so far and\nthe corresponding value of the objective function. Further, each new\nvalue of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun an upper bound on the number of calls of CALFUN. procedure( func ) :: calfun SUBROUTINE CALFUN (N,X,F) has to be provided by the user. It must set\nF to the value of the objective function for the current values of the\nvariables X(1),X(2),...,X(N), which are generated automatically in a\nway that satisfies the bounds given in XL and XU. Calls proc~~bobyqa~~CallsGraph proc~bobyqa bobyqa proc~bobyqb bobyqb proc~bobyqa->proc~bobyqb proc~altmov altmov proc~bobyqb->proc~altmov proc~prelim~2 prelim proc~bobyqb->proc~prelim~2 proc~rescue rescue proc~bobyqb->proc~rescue proc~trsbox trsbox proc~bobyqb->proc~trsbox proc~update~3 update proc~bobyqb->proc~update~3 proc~rescue->proc~update~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~bobyqa~~CalledByGraph proc~bobyqa bobyqa proc~bobyqa_test bobyqa_test proc~bobyqa_test->proc~bobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bobyqa ( n , npt , x , xl , xu , rhobeg , rhoend , iprint , maxfun , calfun ) implicit none integer , intent ( in ) :: n !! number of variables (must be at least two) integer , intent ( in ) :: npt !! number of interpolation conditions. Its value must be in !! the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not !! recommended. real ( wp ), dimension (:), intent ( inout ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). They !! will be changed to the values that give the least calculated F. real ( wp ), dimension (:), intent ( in ) :: xl !! lower bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( wp ), dimension (:), intent ( in ) :: xu !! upper bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( wp ), intent ( in ) :: rhobeg !! RHOBEG must be set to the initial value of a trust region radius. !! It must be positive, and typically should be about one tenth of the greatest !! expected change to a variable.  An error return occurs if any of !! the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real ( wp ), intent ( in ) :: rhoend !! RHOEND must be set to the final value of a trust !! region radius. It must be positive with RHOEND no greater than !! RHOBEG. Typically, RHOEND should indicate the !! accuracy that is required in the final values of the variables. integer , intent ( in ) :: iprint !! IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, each new !! value of RHO is printed, with the best vector of variables so far and !! the corresponding value of the objective function. Further, each new !! value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! an upper bound on the number of calls of CALFUN. procedure ( func ) :: calfun !! SUBROUTINE CALFUN (N,X,F) has to be provided by the user. It must set !! F to the value of the objective function for the current values of the !! variables X(1),X(2),...,X(N), which are generated automatically in a !! way that satisfies the bounds given in XL and XU. integer :: ibmat , id , ifv , igo , ihq , ipq , isl , isu , ivl , iw , ixa ,& ixb , ixn , ixo , ixp , izmat , j , jsl , jsu , ndim , np real ( wp ), dimension (:), allocatable :: w real ( wp ) :: temp real ( wp ), parameter :: zero = 0.0_wp ! The array W will be used for working space. allocate ( w (( NPT + 5 ) * ( NPT + N ) + 3 * N * ( N + 5 ) / 2 ) ) ! !     Return if the value of NPT is unacceptable. ! np = n + 1 if ( npt < n + 2 . or . npt > (( n + 2 ) * np ) / 2 ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because NPT is not in the required interval' return end if ! !     Partition the working space array, so that different parts of it can !     be treated separately during the calculation of BOBYQB. The partition !     requires the first (NPT+2)*(NPT+N)+3*N*(N+5)/2 elements of W plus the !     space that is taken by the last array in the argument list of BOBYQB. ! ndim = npt + n ixb = 1 ixp = ixb + n ifv = ixp + n * npt ixo = ifv + npt igo = ixo + n ihq = igo + n ipq = ihq + ( n * np ) / 2 ibmat = ipq + npt izmat = ibmat + ndim * n isl = izmat + npt * ( npt - np ) isu = isl + n ixn = isu + n ixa = ixn + n id = ixa + n ivl = id + n iw = ivl + ndim ! !     Return if there is insufficient space between the bounds. Modify the !     initial X if necessary in order to avoid conflicts between the bounds !     and the construction of the first quadratic model. The lower and upper !     bounds on moves from the updated X are set now, in the ISL and ISU !     partitions of W, in order to provide useful and exact information about !     components of X that become within distance RHOBEG from their bounds. ! do j = 1 , n temp = xu ( j ) - xl ( j ) if ( temp < rhobeg + rhobeg ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because one of the differences ' // & 'XU(I)-XL(I) is less than 2*RHOBEG.' return end if jsl = isl + j - 1 jsu = jsl + n w ( jsl ) = xl ( j ) - x ( j ) w ( jsu ) = xu ( j ) - x ( j ) if ( w ( jsl ) >=- rhobeg ) then if ( w ( jsl ) >= zero ) then x ( j ) = xl ( j ) w ( jsl ) = zero w ( jsu ) = temp else x ( j ) = xl ( j ) + rhobeg w ( jsl ) = - rhobeg w ( jsu ) = max ( xu ( j ) - x ( j ), rhobeg ) end if else if ( w ( jsu ) <= rhobeg ) then if ( w ( jsu ) <= zero ) then x ( j ) = xu ( j ) w ( jsl ) = - temp w ( jsu ) = zero else x ( j ) = xu ( j ) - rhobeg w ( jsl ) = min ( xl ( j ) - x ( j ), - rhobeg ) w ( jsu ) = rhobeg end if end if end do ! !     Make the call of BOBYQB. ! call bobyqb ( n , npt , x , xl , xu , rhobeg , rhoend , iprint , maxfun , w ( ixb ), w ( ixp ), & w ( ifv ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , w ( isl ), & w ( isu ), w ( ixn ), w ( ixa ), w ( id ), w ( ivl ), w ( iw ), calfun ) deallocate ( w ) end subroutine bobyqa","tags":"","loc":"proc/bobyqa.html"},{"title":"bobyqb – PowellOpt","text":"private  subroutine bobyqb(n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, xnew, xalt, d, vlag, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su real :: xnew real :: xalt real :: d real :: vlag real :: w procedure( func ) :: calfun Calls proc~~bobyqb~~CallsGraph proc~bobyqb bobyqb proc~altmov altmov proc~bobyqb->proc~altmov proc~prelim~2 prelim proc~bobyqb->proc~prelim~2 proc~rescue rescue proc~bobyqb->proc~rescue proc~trsbox trsbox proc~bobyqb->proc~trsbox proc~update~3 update proc~bobyqb->proc~update~3 proc~rescue->proc~update~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~bobyqb~~CalledByGraph proc~bobyqb bobyqb proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb proc~bobyqa_test bobyqa_test proc~bobyqa_test->proc~bobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bobyqb ( n , npt , x , xl , xu , rhobeg , rhoend , iprint , maxfun , xbase , xpt , & fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , xnew , xalt , & d , vlag , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), & gopt ( * ), hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & xnew ( * ), xalt ( * ), d ( * ), vlag ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN !       are identical to the corresponding arguments in SUBROUTINE BOBYQA. !     XBASE holds a shift of origin that should reduce the contributions !       from rounding errors to values of the model and Lagrange functions. !     XPT is a two-dimensional array that holds the coordinates of the !       interpolation points relative to XBASE. !     FVAL holds the values of F at the interpolation points. !     XOPT is set to the displacement from XBASE of the trust region centre. !     GOPT holds the gradient of the quadratic model at XBASE+XOPT. !     HQ holds the explicit second derivatives of the quadratic model. !     PQ contains the parameters of the implicit second derivatives of the !       quadratic model. !     BMAT holds the last N columns of H. !     ZMAT holds the factorization of the leading NPT by NPT submatrix of H, !       this factorization being ZMAT times ZMAT&#94;T, which provides both the !       correct rank and positive semi-definiteness. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     SL and SU hold the differences XL-XBASE and XU-XBASE, respectively. !       All the components of every XOPT are going to satisfy the bounds !       SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when !       XOPT is on a constraint boundary. !     XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the !       vector of variables for the next call of CALFUN. XNEW also satisfies !       the SL and SU constraints in the way that has just been mentioned. !     XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW !       in order to increase the denominator in the updating of UPDATE. !     D is reserved for a trial step from XOPT, which is usually XNEW-XOPT. !     VLAG contains the values of the Lagrange functions at a new point X. !       They are part of a product that requires VLAG to be of length NDIM. !     W is a one-dimensional array that is used for working space. Its length !       must be at least 3*NDIM = 3*(NPT+N). ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp ten = 1 0.0_wp tenth = 0.1_wp two = 2.0_wp zero = 0.0_wp np = n + 1 nptm = npt - np nh = ( n * np ) / 2 ! !     The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, with the corresponding values of !     of NF and KOPT, which are the number of calls of CALFUN so far and the !     index of the interpolation point at the trust region centre. Then the !     initial XOPT is set too. The branch to label 720 occurs if MAXFUN is !     less than NPT. GOPT will be updated if KOPT is different from KBASE. ! call prelim ( n , npt , x , xl , xu , rhobeg , iprint , maxfun , xbase , xpt , fval , gopt , & & hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun ) xoptsq = zero do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do fsave = fval ( 1 ) if ( nf < npt ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if kbase = 1 ! !     Complete the settings that are required for the iterative procedure. ! rho = rhobeg delta = rho nresc = nf ntrits = 0 diffa = zero diffb = zero itest = 0 nfsav = nf ! !     Update GOPT if necessary before the first iteration and after each !     call of RESCUE that makes a call of CALFUN. ! 20 if ( kopt /= kbase ) then ih = 0 do j = 1 , n do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * xopt ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * xopt ( j ) end do end do if ( nf > npt ) then do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if end if ! !     Generate the next point in the trust region that provides a small value !     of the quadratic model subject to the constraints on the variables. !     The integer NTRITS is set to the number \"trust region\" iterations that !     have occurred since the last \"alternative\" iteration. If the length !     of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to !     label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW. ! 60 call trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , w , w ( np ), & & w ( np + n ), w ( np + 2 * n ), w ( np + 3 * n ), dsq , crvmin ) dnorm = min ( delta , sqrt ( dsq )) if ( dnorm < half * rho ) then ntrits = - 1 distsq = ( ten * rho ) ** 2 if ( nf <= nfsav + 2 ) go to 650 ! !     The following choice between labels 650 and 680 depends on whether or !     not our work with the current RHO seems to be complete. Either RHO is !     decreased or termination occurs if the errors in the quadratic model at !     the last three interpolation points compare favourably with predictions !     of likely improvements to the model within distance HALF*RHO of XOPT. ! errbig = max ( diffa , diffb , diffc ) frhosq = 0.125_wp * rho * rho if ( crvmin > zero . and . errbig > frhosq * crvmin ) go to 650 bdtol = errbig / rho do j = 1 , n bdtest = bdtol if ( xnew ( j ) == sl ( j )) bdtest = w ( j ) if ( xnew ( j ) == su ( j )) bdtest = - w ( j ) if ( bdtest < bdtol ) then curv = hq (( j + j * j ) / 2 ) do k = 1 , npt curv = curv + pq ( k ) * xpt ( k , j ) ** 2 end do bdtest = bdtest + half * curv * rho if ( bdtest < bdtol ) go to 650 end if end do go to 680 end if ntrits = ntrits + 1 ! !     Severe cancellation is likely to occur if XOPT is too far from XBASE. !     If the following test holds, then XBASE is shifted so that XOPT becomes !     zero. The appropriate changes are made to BMAT and to the second !     derivatives of the current model, beginning with the changes to BMAT !     that do not depend on ZMAT. VLAG is used temporarily for working space. ! 90 if ( dsq <= 1.0e-3_wp * xoptsq ) then fracsq = 0.25_wp * xoptsq sumpq = zero do k = 1 , npt sumpq = sumpq + pq ( k ) sum = - half * xoptsq do i = 1 , n sum = sum + xpt ( k , i ) * xopt ( i ) end do w ( npt + k ) = sum temp = fracsq - half * sum do i = 1 , n w ( i ) = bmat ( k , i ) vlag ( i ) = sum * xpt ( k , i ) + temp * xopt ( i ) ip = npt + i do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + w ( i ) * vlag ( j ) + vlag ( i ) * w ( j ) end do end do end do ! !     Then the revisions of BMAT that depend on ZMAT are calculated. ! do jj = 1 , nptm sumz = zero sumw = zero do k = 1 , npt sumz = sumz + zmat ( k , jj ) vlag ( k ) = w ( npt + k ) * zmat ( k , jj ) sumw = sumw + vlag ( k ) end do do j = 1 , n sum = ( fracsq * sumz - half * sumw ) * xopt ( j ) do k = 1 , npt sum = sum + vlag ( k ) * xpt ( k , j ) end do w ( j ) = sum do k = 1 , npt bmat ( k , j ) = bmat ( k , j ) + sum * zmat ( k , jj ) end do end do do i = 1 , n ip = i + npt temp = w ( i ) do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + temp * w ( j ) end do end do end do ! !     The following instructions complete the shift, including the changes !     to the second derivative parameters of the quadratic model. ! ih = 0 do j = 1 , n w ( j ) = - half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + xopt ( i ) * w ( j ) bmat ( npt + i , j ) = bmat ( npt + j , i ) end do end do do i = 1 , n xbase ( i ) = xbase ( i ) + xopt ( i ) xnew ( i ) = xnew ( i ) - xopt ( i ) sl ( i ) = sl ( i ) - xopt ( i ) su ( i ) = su ( i ) - xopt ( i ) xopt ( i ) = zero end do xoptsq = zero end if if ( ntrits == 0 ) go to 210 go to 230 ! !     XBASE is also moved to XOPT by a call of RESCUE. This calculation is !     more expensive than the previous shift, because new matrices BMAT and !     ZMAT are generated from scratch, which may include the replacement of !     interpolation points whose positions seem to be causing near linear !     dependence in the interpolation conditions. Therefore RESCUE is called !     only if rounding errors have reduced by at least a factor of two the !     denominator of the formula for updating the H matrix. It provides a !     useful safeguard, but is not invoked in most applications of BOBYQA. ! 190 nfsav = nf kbase = kopt call rescue ( n , npt , xl , xu , iprint , maxfun , xbase , xpt , fval , xopt , gopt , hq , & & pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , w , w ( n + np ), w ( ndim + np ), & & calfun ) ! !     XOPT is updated now in case the branch below to label 720 is taken. !     Any updating of GOPT occurs after the branch below to label 20, which !     leads to a trust region iteration as does the branch to label 60. ! xoptsq = zero if ( kopt /= kbase ) then do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do end if if ( nf < 0 ) then nf = maxfun if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nresc = nf if ( nfsav < nf ) then nfsav = nf go to 20 end if if ( ntrits > 0 ) go to 60 ! !     Pick two alternative vectors of variables, relative to XBASE, that !     are suitable as new positions of the KNEW-th interpolation point. !     Firstly, XNEW is set to the point on a line through XOPT and another !     interpolation point that minimizes the predicted value of the next !     denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL !     and SU bounds. Secondly, XALT is set to the best feasible point on !     a constrained version of the Cauchy step of the KNEW-th Lagrange !     function, the corresponding value of the square of this function !     being returned in CAUCHY. The choice between these alternatives is !     going to be made when the denominator is calculated. ! 210 call altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , w , w ( np ), w ( ndim + 1 )) do i = 1 , n d ( i ) = xnew ( i ) - xopt ( i ) end do ! !     Calculate VLAG and BETA for the current choice of D. The scalar !     product of D with XPT(K,.) is going to be held in W(NPT+K) for !     use when VQUAD is calculated. ! 230 do k = 1 , npt suma = zero sumb = zero sum = zero do j = 1 , n suma = suma + xpt ( k , j ) * d ( j ) sumb = sumb + xpt ( k , j ) * xopt ( j ) sum = sum + bmat ( k , j ) * d ( j ) end do w ( k ) = suma * ( half * suma + sumb ) vlag ( k ) = sum w ( npt + k ) = suma end do beta = zero do jj = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , jj ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , jj ) end do end do dsq = zero bsum = zero dx = zero do j = 1 , n dsq = dsq + d ( j ) ** 2 sum = zero do k = 1 , npt sum = sum + w ( k ) * bmat ( k , j ) end do bsum = bsum + sum * d ( j ) jp = npt + j do i = 1 , n sum = sum + bmat ( jp , i ) * d ( i ) end do vlag ( jp ) = sum bsum = bsum + sum * d ( j ) dx = dx + d ( j ) * xopt ( j ) end do beta = dx * dx + dsq * ( xoptsq + dx + dx + half * dsq ) + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     If NTRITS is zero, the denominator may be increased by replacing !     the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if !     rounding errors have damaged the chosen denominator. ! if ( ntrits == 0 ) then denom = vlag ( knew ) ** 2 + alpha * beta if ( denom < cauchy . and . cauchy > zero ) then do i = 1 , n xnew ( i ) = xalt ( i ) d ( i ) = xnew ( i ) - xopt ( i ) end do cauchy = zero go to 230 end if if ( denom <= half * vlag ( knew ) ** 2 ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if ! !     Alternatively, if NTRITS is positive, then set KNEW to the index of !     the next interpolation point to be deleted to make room for a trust !     region step. Again RESCUE may be called if rounding errors have damaged !     the chosen denominator, which is the reason for attempting to select !     KNEW before calculating the next value of the objective function. ! else delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt if ( k == kopt ) cycle hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xopt ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if end if ! !     Put the variables for the next calculation of the objective function !       in XNEW, with any adjustments for the bounds. ! ! !     Calculate the value of the objective function at XBASE+XNEW, unless !       the limit on the number of calculations of F has been reached. ! 360 do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xnew ( i )), xu ( i )) if ( xnew ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xnew ( i ) == su ( i )) x ( i ) = xu ( i ) end do if ( nf >= maxfun ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nf = nf + 1 call calfun ( n , x ( 1 : n ), f ) if ( iprint == 3 ) then !             print 400, nf, f, (x(i), i=1, n) ! 400         format (/ 4 x, 'Function number', i6, '    F =', 1 pd18.10,& !             '   The corresponding X is:' / (2 x, 5d15.6)) write ( * , '(/4x,a,i6,a,1pd18.10,a/(2x,5d15.6))' ) & 'Function number' , nf , '    F =' , f , & '   The corresponding X is:' , ( x ( i ), i = 1 , n ) end if if ( ntrits ==- 1 ) then fsave = f go to 720 end if ! !     Use the quadratic model to predict the change in F due to the step D, !       and set DIFF to the error of this prediction. ! fopt = fval ( kopt ) vquad = zero ih = 0 do j = 1 , n vquad = vquad + d ( j ) * gopt ( j ) do i = 1 , j ih = ih + 1 temp = d ( i ) * d ( j ) if ( i == j ) temp = half * temp vquad = vquad + hq ( ih ) * temp end do end do do k = 1 , npt vquad = vquad + half * pq ( k ) * w ( npt + k ) ** 2 end do diff = f - fopt - vquad diffc = diffb diffb = diffa diffa = abs ( diff ) if ( dnorm > rho ) nfsav = nf ! !     Pick the next value of DELTA after a trust region step. ! if ( ntrits > 0 ) then if ( vquad >= zero ) then if ( iprint > 0 ) write ( * , '(/4x,a)' ) 'Return from BOBYQA because a trust' // & ' region step has failed to reduce Q.' go to 720 end if ratio = ( f - fopt ) / vquad if ( ratio <= tenth ) then delta = min ( half * delta , dnorm ) else if ( ratio <= 0.7_wp ) then delta = max ( half * delta , dnorm ) else delta = max ( half * delta , dnorm + dnorm ) end if if ( delta <= 1.5_wp * rho ) delta = rho ! !     Recalculate KNEW and DENOM if the new F is less than FOPT. ! if ( f < fopt ) then ksav = knew densav = denom delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xnew ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then knew = ksav denom = densav end if end if end if ! !     Update BMAT and ZMAT, so that the KNEW-th interpolation point can be !     moved. Also update the second derivative terms of the model. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) ih = 0 pqold = pq ( knew ) pq ( knew ) = zero do i = 1 , n temp = pqold * xpt ( knew , i ) do j = 1 , i ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * xpt ( knew , j ) end do end do do jj = 1 , nptm temp = diff * zmat ( knew , jj ) do k = 1 , npt pq ( k ) = pq ( k ) + temp * zmat ( k , jj ) end do end do ! !     Include the new interpolation point, and make the changes to GOPT at !     the old XOPT that are caused by the updating of the quadratic model. ! fval ( knew ) = f do i = 1 , n xpt ( knew , i ) = xnew ( i ) w ( i ) = bmat ( knew , i ) end do do k = 1 , npt suma = zero do jj = 1 , nptm suma = suma + zmat ( knew , jj ) * zmat ( k , jj ) end do sumb = zero do j = 1 , n sumb = sumb + xpt ( k , j ) * xopt ( j ) end do temp = suma * sumb do i = 1 , n w ( i ) = w ( i ) + temp * xpt ( k , i ) end do end do do i = 1 , n gopt ( i ) = gopt ( i ) + diff * w ( i ) end do ! !     Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT. ! if ( f < fopt ) then kopt = knew xoptsq = zero ih = 0 do j = 1 , n xopt ( j ) = xnew ( j ) xoptsq = xoptsq + xopt ( j ) ** 2 do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * d ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * d ( j ) end do end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * d ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if ! !     Calculate the parameters of the least Frobenius norm interpolant to !     the current data, the gradient of this interpolant at XOPT being put !     into VLAG(NPT+I), I=1,2,...,N. ! if ( ntrits > 0 ) then do k = 1 , npt vlag ( k ) = fval ( k ) - fval ( kopt ) w ( k ) = zero end do do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * vlag ( k ) end do do k = 1 , npt w ( k ) = w ( k ) + sum * zmat ( k , j ) end do end do do k = 1 , npt sum = zero do j = 1 , n sum = sum + xpt ( k , j ) * xopt ( j ) end do w ( k + npt ) = w ( k ) w ( k ) = sum * w ( k ) end do gqsq = zero gisq = zero do i = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , i ) * vlag ( k ) + xpt ( k , i ) * w ( k ) end do if ( xopt ( i ) == sl ( i )) then gqsq = gqsq + min ( zero , gopt ( i )) ** 2 gisq = gisq + min ( zero , sum ) ** 2 else if ( xopt ( i ) == su ( i )) then gqsq = gqsq + max ( zero , gopt ( i )) ** 2 gisq = gisq + max ( zero , sum ) ** 2 else gqsq = gqsq + gopt ( i ) ** 2 gisq = gisq + sum * sum end if vlag ( npt + i ) = sum end do ! !     Test whether to replace the new quadratic model by the least Frobenius !     norm interpolant, making the replacement if the test is satisfied. ! itest = itest + 1 if ( gqsq < ten * gisq ) itest = 0 if ( itest >= 3 ) then do i = 1 , max ( npt , nh ) if ( i <= n ) gopt ( i ) = vlag ( npt + i ) if ( i <= npt ) pq ( i ) = w ( npt + i ) if ( i <= nh ) hq ( i ) = zero itest = 0 end do end if end if ! !     If a trust region step has provided a sufficient decrease in F, then !     branch for another trust region calculation. The case NTRITS=0 occurs !     when the new interpolation point was reached by an alternative step. ! if ( ntrits == 0 ) go to 60 if ( f <= fopt + tenth * vquad ) go to 60 ! !     Alternatively, find out if the interpolation points are close enough !       to the best point so far. ! distsq = max (( two * delta ) ** 2 , ( ten * rho ) ** 2 ) 650 knew = 0 do k = 1 , npt sum = zero do j = 1 , n sum = sum + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( sum > distsq ) then knew = k distsq = sum end if end do ! !     If KNEW is positive, then ALTMOV finds alternative new positions for !     the KNEW-th interpolation point within distance ADELT of XOPT. It is !     reached via label 90. Otherwise, there is a branch to label 60 for !     another trust region iteration, unless the calculations with the !     current RHO are complete. ! if ( knew > 0 ) then dist = sqrt ( distsq ) if ( ntrits ==- 1 ) then delta = min ( tenth * delta , half * dist ) if ( delta <= 1.5_wp * rho ) delta = rho end if ntrits = 0 adelt = max ( min ( tenth * dist , delta ), rho ) dsq = adelt * adelt go to 90 end if if ( ntrits ==- 1 ) go to 680 if ( ratio > zero ) go to 60 if ( max ( delta , dnorm ) > rho ) go to 60 ! !     The calculations with the current value of RHO are complete. Pick the !       next values of RHO and DELTA. ! 680 if ( rho > rhoend ) then delta = half * rho ratio = rho / rhoend if ( ratio <= 1 6.0_wp ) then rho = rhoend else if ( ratio <= 25 0.0_wp ) then rho = sqrt ( ratio ) * rhoend else rho = tenth * rho end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) write ( * , '(5x)' ) '' print 700 , rho , nf 700 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 710 , fval ( kopt ), ( xbase ( i ) + xopt ( i ), i = 1 , n ) 710 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if ntrits = 0 nfsav = nf go to 60 end if ! !     Return from the calculation, after another Newton-Raphson step, if !       it is too short to have been tried before. ! if ( ntrits ==- 1 ) go to 360 720 if ( fval ( kopt ) <= fsave ) then do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xopt ( i )), xu ( i )) if ( xopt ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xopt ( i ) == su ( i )) x ( i ) = xu ( i ) end do f = fval ( kopt ) end if if ( iprint >= 1 ) then print 740 , nf 740 format ( / 4 x , 'At the return from BOBYQA' , 5 x ,& 'Number of function values =' , i6 ) print 710 , f , ( x ( i ), i = 1 , n ) end if return end subroutine bobyqb","tags":"","loc":"proc/bobyqb.html"},{"title":"altmov – PowellOpt","text":"private  subroutine altmov(n, npt, xpt, xopt, bmat, zmat, ndim, sl, su, kopt, knew, adelt, xnew, xalt, alpha, cauchy, glag, hcol, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: kopt integer :: knew real :: adelt real :: xnew real :: xalt real :: alpha real :: cauchy real :: glag real :: hcol real :: w Called by proc~~altmov~~CalledByGraph proc~altmov altmov proc~bobyqb bobyqb proc~bobyqb->proc~altmov proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb proc~bobyqa_test bobyqa_test proc~bobyqa_test->proc~bobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , glag , hcol , w ) implicit real ( wp ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & & xnew ( * ), xalt ( * ), glag ( * ), hcol ( * ), w ( * ) ! !     The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have !       the same meanings as the corresponding arguments of BOBYQB. !     KOPT is the index of the optimal interpolation point. !     KNEW is the index of the interpolation point that is going to be moved. !     ADELT is the current trust region bound. !     XNEW will be set to a suitable new position for the interpolation point !       XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region !       bounds and it should provide a large denominator in the next call of !       UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the !       straight lines through XOPT and another interpolation point. !     XALT also provides a large value of the modulus of the KNEW-th Lagrange !       function subject to the constraints that have been mentioned, its main !       difference from XNEW being that XALT-XOPT is a constrained version of !       the Cauchy step within the trust region. An exception is that XALT is !       not calculated if all components of GLAG (see below) are zero. !     ALPHA will be set to the KNEW-th diagonal element of the H matrix. !     CAUCHY will be set to the square of the KNEW-th Lagrange function at !       the step XALT-XOPT from XOPT for the vector XALT that is returned, !       except that CAUCHY is set to zero if XALT is not calculated. !     GLAG is a working space vector of length N for the gradient of the !       KNEW-th Lagrange function at XOPT. !     HCOL is a working space vector of length NPT for the second derivative !       coefficients of the KNEW-th Lagrange function. !     W is a working space vector of length 2N that is going to hold the !       constrained Cauchy step from XOPT of the Lagrange function, followed !       by the downhill version of XALT when the uphill step is calculated. ! !     Set the first NPT components of W to the leading elements of the !     KNEW-th column of the H matrix. ! half = 0.5_wp one = 1.0_wp zero = 0.0_wp const = one + sqrt ( 2.0_wp ) do k = 1 , npt hcol ( k ) = zero end do do j = 1 , npt - n - 1 temp = zmat ( knew , j ) do k = 1 , npt hcol ( k ) = hcol ( k ) + temp * zmat ( k , j ) end do end do alpha = hcol ( knew ) ha = half * alpha ! !     Calculate the gradient of the KNEW-th Lagrange function at XOPT. ! do i = 1 , n glag ( i ) = bmat ( knew , i ) end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = hcol ( k ) * temp do i = 1 , n glag ( i ) = glag ( i ) + temp * xpt ( k , i ) end do end do ! !     Search for a large denominator along the straight lines through XOPT !     and another interpolation point. SLBD and SUBD will be lower and upper !     bounds on the step along each of these lines in turn. PREDSQ will be !     set to the square of the predicted denominator for each line. PRESAV !     will be set to the largest admissible value of PREDSQ that occurs. ! presav = zero do k = 1 , npt if ( k == kopt ) cycle dderiv = zero distsq = zero do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) dderiv = dderiv + glag ( i ) * temp distsq = distsq + temp * temp end do subd = adelt / sqrt ( distsq ) slbd = - subd ilbd = 0 iubd = 0 sumin = min ( one , subd ) ! !     Revise SLBD and SUBD if necessary because of the bounds in SL and SU. ! do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) if ( temp > zero ) then if ( slbd * temp < sl ( i ) - xopt ( i )) then slbd = ( sl ( i ) - xopt ( i )) / temp ilbd = - i end if if ( subd * temp > su ( i ) - xopt ( i )) then subd = max ( sumin , ( su ( i ) - xopt ( i )) / temp ) iubd = i end if else if ( temp < zero ) then if ( slbd * temp > su ( i ) - xopt ( i )) then slbd = ( su ( i ) - xopt ( i )) / temp ilbd = i end if if ( subd * temp < sl ( i ) - xopt ( i )) then subd = max ( sumin , ( sl ( i ) - xopt ( i )) / temp ) iubd = - i end if end if end do ! !     Seek a large modulus of the KNEW-th Lagrange function when the index !     of the other interpolation point on the line through XOPT is KNEW. ! if ( k == knew ) then diff = dderiv - one step = slbd vlag = slbd * ( dderiv - slbd * diff ) isbd = ilbd temp = subd * ( dderiv - subd * diff ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if tempd = half * dderiv tempa = tempd - diff * slbd tempb = tempd - diff * subd if ( tempa * tempb < zero ) then temp = tempd * tempd / diff if ( abs ( temp ) > abs ( vlag )) then step = tempd / diff vlag = temp isbd = 0 end if end if ! !     Search along each of the other lines through XOPT and another point. ! else step = slbd vlag = slbd * ( one - slbd ) isbd = ilbd temp = subd * ( one - subd ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if if ( subd > half ) then if ( abs ( vlag ) < 0.25_wp ) then step = half vlag = 0.25_wp isbd = 0 end if end if vlag = vlag * dderiv end if ! !     Calculate PREDSQ for the current line search and maintain PRESAV. ! temp = step * ( one - step ) * distsq predsq = vlag * vlag * ( vlag * vlag + ha * temp * temp ) if ( predsq > presav ) then presav = predsq ksav = k stpsav = step ibdsav = isbd end if end do ! !     Construct XNEW in a way that satisfies the bound constraints exactly. ! do i = 1 , n temp = xopt ( i ) + stpsav * ( xpt ( ksav , i ) - xopt ( i )) xnew ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do if ( ibdsav < 0 ) xnew ( - ibdsav ) = sl ( - ibdsav ) if ( ibdsav > 0 ) xnew ( ibdsav ) = su ( ibdsav ) ! !     Prepare for the iterative method that assembles the constrained Cauchy !     step in W. The sum of squares of the fixed components of W is formed in !     WFIXSQ, and the free components of W are set to BIGSTP. ! bigstp = adelt + adelt iflag = 0 100 wfixsq = zero ggfree = zero do i = 1 , n w ( i ) = zero tempa = min ( xopt ( i ) - sl ( i ), glag ( i )) tempb = max ( xopt ( i ) - su ( i ), glag ( i )) if ( tempa > zero . or . tempb < zero ) then w ( i ) = bigstp ggfree = ggfree + glag ( i ) ** 2 end if end do if ( ggfree == zero ) then cauchy = zero return end if ! !     Investigate whether more components of W can be fixed. ! 120 temp = adelt * adelt - wfixsq if ( temp > zero ) then wsqsav = wfixsq step = sqrt ( temp / ggfree ) ggfree = zero do i = 1 , n if ( w ( i ) == bigstp ) then temp = xopt ( i ) - step * glag ( i ) if ( temp <= sl ( i )) then w ( i ) = sl ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else if ( temp >= su ( i )) then w ( i ) = su ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else ggfree = ggfree + glag ( i ) ** 2 end if end if end do if ( wfixsq > wsqsav . and . ggfree > zero ) go to 120 end if ! !     Set the remaining free components of W and all components of XALT, !     except that W may be scaled later. ! gw = zero do i = 1 , n if ( w ( i ) == bigstp ) then w ( i ) = - step * glag ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), xopt ( i ) + w ( i ))) else if ( w ( i ) == zero ) then xalt ( i ) = xopt ( i ) else if ( glag ( i ) > zero ) then xalt ( i ) = sl ( i ) else xalt ( i ) = su ( i ) end if gw = gw + glag ( i ) * w ( i ) end do ! !     Set CURV to the curvature of the KNEW-th Lagrange function along W. !     Scale W by a factor less than one if that can reduce the modulus of !     the Lagrange function at XOPT+W. Set CAUCHY to the final value of !     the square of this function. ! curv = zero do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * w ( j ) end do curv = curv + hcol ( k ) * temp * temp end do if ( iflag == 1 ) curv = - curv if ( curv >- gw . and . curv <- const * gw ) then scale = - gw / curv do i = 1 , n temp = xopt ( i ) + scale * w ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do cauchy = ( half * gw * scale ) ** 2 else cauchy = ( gw + half * curv ) ** 2 end if ! !     If IFLAG is zero, then XALT is calculated as before after reversing !     the sign of GLAG. Thus two XALT vectors become available. The one that !     is chosen is the one that gives the larger value of CAUCHY. ! if ( iflag == 0 ) then do i = 1 , n glag ( i ) = - glag ( i ) w ( n + i ) = xalt ( i ) end do csave = cauchy iflag = 1 go to 100 end if if ( csave > cauchy ) then do i = 1 , n xalt ( i ) = w ( n + i ) end do cauchy = csave end if end subroutine altmov","tags":"","loc":"proc/altmov.html"},{"title":"prelim – PowellOpt","text":"private  subroutine prelim(n, npt, x, xl, xu, rhobeg, iprint, maxfun, xbase, xpt, fval, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, kopt, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf integer :: kopt procedure( func ) :: calfun Called by proc~~prelim~2~~CalledByGraph proc~prelim~2 prelim proc~bobyqb bobyqb proc~bobyqb->proc~prelim~2 proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb proc~bobyqa_test bobyqa_test proc~bobyqa_test->proc~bobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine prelim ( n , npt , x , xl , xu , rhobeg , iprint , maxfun , xbase , xpt , fval , gopt , & & hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), gopt ( * ), hq & & ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the !       same as the corresponding arguments in SUBROUTINE BOBYQA. !     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU !       are the same as the corresponding arguments in BOBYQB, the elements !       of SL and SU being set in BOBYQA. !     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but !       it is set by PRELIM to the gradient of the quadratic model at XBASE. !       If XOPT is nonzero, BOBYQB will change it to its usual value later. !     NF is maintaned as the number of calls of CALFUN so far. !     KOPT will be such that the least calculated value of F so far is at !       the point XPT(KOPT,.)+XBASE in the space of the variables. ! !     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, and it maintains the values of !     NF and KOPT. The vector X is also changed by PRELIM. ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp two = 2.0_wp zero = 0.0_wp rhosq = rhobeg * rhobeg recip = one / rhosq np = n + 1 ! !     Set XBASE to the initial vector of variables, and set the initial !     elements of XPT, BMAT, HQ, PQ and ZMAT to zero. ! do j = 1 , n xbase ( j ) = x ( j ) do k = 1 , npt xpt ( k , j ) = zero end do do i = 1 , ndim bmat ( i , j ) = zero end do end do do ih = 1 , ( n * np ) / 2 hq ( ih ) = zero end do do k = 1 , npt pq ( k ) = zero do j = 1 , npt - np zmat ( k , j ) = zero end do end do ! !     Begin the initialization procedure. NF becomes one more than the number !     of function values so far. The coordinates of the displacement of the !     next initial interpolation point from XBASE are set in XPT(NF+1,.). ! nf = 0 50 nfm = nf nfx = nf - n nf = nf + 1 if ( nfm <= 2 * n ) then if ( nfm >= 1 . and . nfm <= n ) then stepa = rhobeg if ( su ( nfm ) == zero ) stepa = - stepa xpt ( nf , nfm ) = stepa else if ( nfm > n ) then stepa = xpt ( nf - n , nfx ) stepb = - rhobeg if ( sl ( nfx ) == zero ) stepb = min ( two * rhobeg , su ( nfx )) if ( su ( nfx ) == zero ) stepb = max ( - two * rhobeg , sl ( nfx )) xpt ( nf , nfx ) = stepb end if else itemp = ( nfm - np ) / n jpt = nfm - itemp * n - n ipt = jpt + itemp if ( ipt > n ) then itemp = jpt jpt = ipt - n ipt = itemp end if xpt ( nf , ipt ) = xpt ( ipt + 1 , ipt ) xpt ( nf , jpt ) = xpt ( jpt + 1 , jpt ) end if ! !     Calculate the next value of F. The least function value so far and !     its index are required. ! do j = 1 , n x ( j ) = min ( max ( xl ( j ), xbase ( j ) + xpt ( nf , j )), xu ( j )) if ( xpt ( nf , j ) == sl ( j )) x ( j ) = xl ( j ) if ( xpt ( nf , j ) == su ( j )) x ( j ) = xu ( j ) end do call calfun ( n , x ( 1 : n ), f ) if ( iprint == 3 ) then print 70 , nf , f , ( x ( i ), i = 1 , n ) 70 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( nf ) = f if ( nf == 1 ) then fbeg = f kopt = 1 else if ( f < fval ( kopt )) then kopt = nf end if ! !     Set the nonzero initial elements of BMAT and the quadratic model in the !     cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions !     of the NF-th and (NF-N)-th interpolation points may be switched, in !     order that the function value at the first of them contributes to the !     off-diagonal second derivative terms of the initial quadratic model. ! if ( nf <= 2 * n + 1 ) then if ( nf >= 2 . and . nf <= n + 1 ) then gopt ( nfm ) = ( f - fbeg ) / stepa if ( npt < nf + n ) then bmat ( 1 , nfm ) = - one / stepa bmat ( nf , nfm ) = one / stepa bmat ( npt + nfm , nfm ) = - half * rhosq end if else if ( nf >= n + 2 ) then ih = ( nfx * ( nfx + 1 )) / 2 temp = ( f - fbeg ) / stepb diff = stepb - stepa hq ( ih ) = two * ( temp - gopt ( nfx )) / diff gopt ( nfx ) = ( gopt ( nfx ) * stepb - temp * stepa ) / diff if ( stepa * stepb < zero ) then if ( f < fval ( nf - n )) then fval ( nf ) = fval ( nf - n ) fval ( nf - n ) = f if ( kopt == nf ) kopt = nf - n xpt ( nf - n , nfx ) = stepb xpt ( nf , nfx ) = stepa end if end if bmat ( 1 , nfx ) = - ( stepa + stepb ) / ( stepa * stepb ) bmat ( nf , nfx ) = - half / xpt ( nf - n , nfx ) bmat ( nf - n , nfx ) = - bmat ( 1 , nfx ) - bmat ( nf , nfx ) zmat ( 1 , nfx ) = sqrt ( two ) / ( stepa * stepb ) zmat ( nf , nfx ) = sqrt ( half ) / rhosq zmat ( nf - n , nfx ) = - zmat ( 1 , nfx ) - zmat ( nf , nfx ) end if ! !     Set the off-diagonal second derivatives of the Lagrange functions and !     the initial quadratic model. ! else ih = ( ipt * ( ipt - 1 )) / 2 + jpt zmat ( 1 , nfx ) = recip zmat ( nf , nfx ) = recip zmat ( ipt + 1 , nfx ) = - recip zmat ( jpt + 1 , nfx ) = - recip temp = xpt ( nf , ipt ) * xpt ( nf , jpt ) hq ( ih ) = ( fbeg - fval ( ipt + 1 ) - fval ( jpt + 1 ) + f ) / temp end if if ( nf < npt . and . nf < maxfun ) go to 50 end subroutine prelim","tags":"","loc":"proc/prelim~2.html"},{"title":"rescue – PowellOpt","text":"private  subroutine rescue(n, npt, xl, xu, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, delta, kopt, vlag, ptsaux, ptsid, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xl real :: xu integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf real :: delta integer :: kopt real :: vlag real :: ptsaux real :: ptsid real :: w procedure( func ) :: calfun Calls proc~~rescue~~CallsGraph proc~rescue rescue proc~update~3 update proc~rescue->proc~update~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~rescue~~CalledByGraph proc~rescue rescue proc~bobyqb bobyqb proc~bobyqb->proc~rescue proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb proc~bobyqa_test bobyqa_test proc~bobyqa_test->proc~bobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rescue ( n , npt , xl , xu , iprint , maxfun , xbase , xpt , fval , xopt , gopt , hq , & & pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , ptsaux , ptsid , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), gopt ( * ), & & hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), vlag ( * ), ptsaux & & ( 2 , * ), ptsid ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, XL, XU, IPRINT, MAXFUN, XBASE, XPT, FVAL, XOPT, !       GOPT, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU have the same meanings as !       the corresponding arguments of BOBYQB on the entry to RESCUE. !     NF is maintained as the number of calls of CALFUN so far, except that !       NF is set to -1 if the value of MAXFUN prevents further progress. !     KOPT is maintained so that FVAL(KOPT) is the least calculated function !       value. Its correct value must be given on entry. It is updated if a !       new least function value is found, but the corresponding changes to !       XOPT and GOPT have to be made later by the calling program. !     DELTA is the current trust region radius. !     VLAG is a working space vector that will be used for the values of the !       provisional Lagrange functions at each of the interpolation points. !       They are part of a product that requires VLAG to be of length NDIM. !     PTSAUX is also a working space array. For J=1,2,...,N, PTSAUX(1,J) and !       PTSAUX(2,J) specify the two positions of provisional interpolation !       points when a nonzero step is taken along e_J (the J-th coordinate !       direction) through XBASE+XOPT, as specified below. Usually these !       steps have length DELTA, but other lengths are chosen if necessary !       in order to satisfy the given bounds on the variables. !     PTSID is also a working space array. It has NPT components that denote !       provisional new positions of the original interpolation points, in !       case changes are needed to restore the linear independence of the !       interpolation conditions. The K-th point is a candidate for change !       if and only if PTSID(K) is nonzero. In this case let p and q be the !       integer parts of PTSID(K) and (PTSID(K)-p) multiplied by N+1. If p !       and q are both positive, the step from XBASE+XOPT to the new K-th !       interpolation point is PTSAUX(1,p)*e_p + PTSAUX(1,q)*e_q. Otherwise !       the step is PTSAUX(1,p)*e_p or PTSAUX(2,q)*e_q in the cases q=0 or !       p=0, respectively. !     The first NDIM+NPT elements of the array W are used for working space. !     The final elements of BMAT and ZMAT are set in a well-conditioned way !       to the values that are appropriate for the new interpolation points. !     The elements of GOPT, HQ and PQ are also revised to the values that are !       appropriate to the final quadratic model. ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp zero = 0.0_wp np = n + 1 sfrac = half / real ( np , wp ) nptm = npt - np ! !     Shift the interpolation points so that XOPT becomes the origin, and set !     the elements of ZMAT to zero. The value of SUMPQ is required in the !     updating of HQ below. The squares of the distances from XOPT to the !     other interpolation points are set at the end of W. Increments of WINC !     may be added later to these squares to balance the consideration of !     the choice of point that is going to become current. ! sumpq = zero winc = zero do k = 1 , npt distsq = zero do j = 1 , n xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) distsq = distsq + xpt ( k , j ) ** 2 end do sumpq = sumpq + pq ( k ) w ( ndim + k ) = distsq winc = max ( winc , distsq ) do j = 1 , nptm zmat ( k , j ) = zero end do end do ! !     Update HQ so that HQ and PQ define the second derivatives of the model !     after XBASE has been shifted to the trust region centre. ! ih = 0 do j = 1 , n w ( j ) = half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + w ( j ) * xopt ( i ) end do end do ! !     Shift XBASE, SL, SU and XOPT. Set the elements of BMAT to zero, and !     also set the elements of PTSAUX. ! do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) sl ( j ) = sl ( j ) - xopt ( j ) su ( j ) = su ( j ) - xopt ( j ) xopt ( j ) = zero ptsaux ( 1 , j ) = min ( delta , su ( j )) ptsaux ( 2 , j ) = max ( - delta , sl ( j )) if ( ptsaux ( 1 , j ) + ptsaux ( 2 , j ) < zero ) then temp = ptsaux ( 1 , j ) ptsaux ( 1 , j ) = ptsaux ( 2 , j ) ptsaux ( 2 , j ) = temp end if if ( abs ( ptsaux ( 2 , j )) < half * abs ( ptsaux ( 1 , j ))) then ptsaux ( 2 , j ) = half * ptsaux ( 1 , j ) end if do i = 1 , ndim bmat ( i , j ) = zero end do end do fbase = fval ( kopt ) ! !     Set the identifiers of the artificial interpolation points that are !     along a coordinate direction from XOPT, and set the corresponding !     nonzero elements of BMAT and ZMAT. ! ptsid ( 1 ) = sfrac do j = 1 , n jp = j + 1 jpn = jp + n ptsid ( jp ) = real ( j , wp ) + sfrac if ( jpn <= npt ) then ptsid ( jpn ) = real ( j , wp ) / real ( np , wp ) + sfrac temp = one / ( ptsaux ( 1 , j ) - ptsaux ( 2 , j )) bmat ( jp , j ) = - temp + one / ptsaux ( 1 , j ) bmat ( jpn , j ) = temp + one / ptsaux ( 2 , j ) bmat ( 1 , j ) = - bmat ( jp , j ) - bmat ( jpn , j ) zmat ( 1 , j ) = sqrt ( 2.0_wp ) / abs ( ptsaux ( 1 , j ) * ptsaux ( 2 , j )) zmat ( jp , j ) = zmat ( 1 , j ) * ptsaux ( 2 , j ) * temp zmat ( jpn , j ) = - zmat ( 1 , j ) * ptsaux ( 1 , j ) * temp else bmat ( 1 , j ) = - one / ptsaux ( 1 , j ) bmat ( jp , j ) = one / ptsaux ( 1 , j ) bmat ( j + npt , j ) = - half * ptsaux ( 1 , j ) ** 2 end if end do ! !     Set any remaining identifiers with their nonzero elements of ZMAT. ! if ( npt >= n + np ) then do k = 2 * np , npt iw = ( real ( k - np , wp ) - half ) / real ( n , wp ) ip = k - np - iw * n iq = ip + iw if ( iq > n ) iq = iq - n ptsid ( k ) = real ( ip , wp ) + real ( iq , wp ) / real ( np , wp ) + sfrac temp = one / ( ptsaux ( 1 , ip ) * ptsaux ( 1 , iq )) zmat ( 1 , k - np ) = temp zmat ( ip + 1 , k - np ) = - temp zmat ( iq + 1 , k - np ) = - temp zmat ( k , k - np ) = temp end do end if nrem = npt kold = 1 knew = kopt ! !     Reorder the provisional points in the way that exchanges PTSID(KOLD) !     with PTSID(KNEW). ! 80 do j = 1 , n temp = bmat ( kold , j ) bmat ( kold , j ) = bmat ( knew , j ) bmat ( knew , j ) = temp end do do j = 1 , nptm temp = zmat ( kold , j ) zmat ( kold , j ) = zmat ( knew , j ) zmat ( knew , j ) = temp end do ptsid ( kold ) = ptsid ( knew ) ptsid ( knew ) = zero w ( ndim + knew ) = zero nrem = nrem - 1 if ( knew /= kopt ) then temp = vlag ( kold ) vlag ( kold ) = vlag ( knew ) vlag ( knew ) = temp ! !     Update the BMAT and ZMAT matrices so that the status of the KNEW-th !     interpolation point can be changed from provisional to original. The !     subroutine returns if all the original points are reinstated. !     The nonnegative values of W(NDIM+K) are required in the search below. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) if ( nrem == 0 ) return do k = 1 , npt w ( ndim + k ) = abs ( w ( ndim + k )) end do end if ! !     Pick the index KNEW of an original interpolation point that has not !     yet replaced one of the provisional interpolation points, giving !     attention to the closeness to XOPT and to previous tries with KNEW. ! 120 dsqmin = zero do k = 1 , npt if ( w ( ndim + k ) > zero ) then if ( dsqmin == zero . or . w ( ndim + k ) < dsqmin ) then knew = k dsqmin = w ( ndim + k ) end if end if end do if ( dsqmin == zero ) go to 260 ! !     Form the W-vector of the chosen original interpolation point. ! do j = 1 , n w ( npt + j ) = xpt ( knew , j ) end do do k = 1 , npt sum = zero if ( k == kopt ) then continue else if ( ptsid ( k ) == zero ) then do j = 1 , n sum = sum + w ( npt + j ) * xpt ( k , j ) end do else ip = ptsid ( k ) if ( ip > 0 ) sum = w ( npt + ip ) * ptsaux ( 1 , ip ) iq = real ( np , wp ) * ptsid ( k ) - real ( ip * np , wp ) if ( iq > 0 ) then iw = 1 if ( ip == 0 ) iw = 2 sum = sum + w ( npt + iq ) * ptsaux ( iw , iq ) end if end if w ( k ) = half * sum * sum end do ! !     Calculate VLAG and BETA for the required updating of the H matrix if !     XPT(KNEW,.) is reinstated in the set of interpolation points. ! do k = 1 , npt sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * w ( npt + j ) end do vlag ( k ) = sum end do beta = zero do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , j ) end do end do bsum = zero distsq = zero do j = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , j ) * w ( k ) end do jp = j + npt bsum = bsum + sum * w ( jp ) do ip = npt + 1 , ndim sum = sum + bmat ( ip , j ) * w ( ip ) end do bsum = bsum + sum * w ( jp ) vlag ( jp ) = sum distsq = distsq + xpt ( knew , j ) ** 2 end do beta = half * distsq * distsq + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     KOLD is set to the index of the provisional interpolation point that is !     going to be deleted to make way for the KNEW-th original interpolation !     point. The choice of KOLD is governed by the avoidance of a small value !     of the denominator in the updating calculation of UPDATE. ! denom = zero vlmxsq = zero do k = 1 , npt if ( ptsid ( k ) /= zero ) then hdiag = zero do j = 1 , nptm hdiag = hdiag + zmat ( k , j ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 if ( den > denom ) then kold = k denom = den end if end if vlmxsq = max ( vlmxsq , vlag ( k ) ** 2 ) end do if ( denom <= 1.0e-2_wp * vlmxsq ) then w ( ndim + knew ) = - w ( ndim + knew ) - winc go to 120 end if go to 80 ! !     When label 260 is reached, all the final positions of the interpolation !     points have been chosen although any changes have not been included yet !     in XPT. Also the final BMAT and ZMAT matrices are complete, but, apart !     from the shift of XBASE, the updating of the quadratic model remains to !     be done. The following cycle through the new interpolation points begins !     by putting the new point in XPT(KPT,.) and by setting PQ(KPT) to zero, !     except that a RETURN occurs if MAXFUN prohibits another value of F. ! 260 do kpt = 1 , npt if ( ptsid ( kpt ) == zero ) cycle if ( nf >= maxfun ) then nf = - 1 return end if ih = 0 do j = 1 , n w ( j ) = xpt ( kpt , j ) xpt ( kpt , j ) = zero temp = pq ( kpt ) * w ( j ) do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * w ( i ) end do end do pq ( kpt ) = zero ip = ptsid ( kpt ) iq = real ( np , wp ) * ptsid ( kpt ) - real ( ip * np , wp ) if ( ip > 0 ) then xp = ptsaux ( 1 , ip ) xpt ( kpt , ip ) = xp end if if ( iq > 0 ) then xq = ptsaux ( 1 , iq ) if ( ip == 0 ) xq = ptsaux ( 2 , iq ) xpt ( kpt , iq ) = xq end if ! !     Set VQUAD to the value of the current model at the new point. ! vquad = fbase if ( ip > 0 ) then ihp = ( ip + ip * ip ) / 2 vquad = vquad + xp * ( gopt ( ip ) + half * xp * hq ( ihp )) end if if ( iq > 0 ) then ihq = ( iq + iq * iq ) / 2 vquad = vquad + xq * ( gopt ( iq ) + half * xq * hq ( ihq )) if ( ip > 0 ) then iw = max ( ihp , ihq ) - abs ( ip - iq ) vquad = vquad + xp * xq * hq ( iw ) end if end if do k = 1 , npt temp = zero if ( ip > 0 ) temp = temp + xp * xpt ( k , ip ) if ( iq > 0 ) temp = temp + xq * xpt ( k , iq ) vquad = vquad + half * pq ( k ) * temp * temp end do ! !     Calculate F at the new interpolation point, and set DIFF to the factor !     that is going to multiply the KPT-th Lagrange function when the model !     is updated to provide interpolation to the new function value. ! do i = 1 , n w ( i ) = min ( max ( xl ( i ), xbase ( i ) + xpt ( kpt , i )), xu ( i )) if ( xpt ( kpt , i ) == sl ( i )) w ( i ) = xl ( i ) if ( xpt ( kpt , i ) == su ( i )) w ( i ) = xu ( i ) end do nf = nf + 1 call calfun ( n , w ( 1 : n ), f ) if ( iprint == 3 ) then print 300 , nf , f , ( w ( i ), i = 1 , n ) 300 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( kpt ) = f if ( f < fval ( kopt )) kopt = kpt diff = f - vquad ! !     Update the quadratic model. The RETURN from the subroutine occurs when !     all the new interpolation points are included in the model. ! do i = 1 , n gopt ( i ) = gopt ( i ) + diff * bmat ( kpt , i ) end do do k = 1 , npt sum = zero do j = 1 , nptm sum = sum + zmat ( k , j ) * zmat ( kpt , j ) end do temp = diff * sum if ( ptsid ( k ) == zero ) then pq ( k ) = pq ( k ) + temp else ip = ptsid ( k ) iq = real ( np , wp ) * ptsid ( k ) - real ( ip * np , wp ) ihq = ( iq * iq + iq ) / 2 if ( ip == 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 2 , iq ) ** 2 else ihp = ( ip * ip + ip ) / 2 hq ( ihp ) = hq ( ihp ) + temp * ptsaux ( 1 , ip ) ** 2 if ( iq > 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 1 , iq ) ** 2 iw = max ( ihp , ihq ) - abs ( iq - ip ) hq ( iw ) = hq ( iw ) + temp * ptsaux ( 1 , ip ) * ptsaux ( 1 , iq ) end if end if end if end do ptsid ( kpt ) = zero end do end subroutine rescue","tags":"","loc":"proc/rescue.html"},{"title":"trsbox – PowellOpt","text":"private  subroutine trsbox(n, npt, xpt, xopt, gopt, hq, pq, sl, su, delta, xnew, d, gnew, xbdi, s, hs, hred, dsq, crvmin) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: gopt real :: hq real :: pq real :: sl real :: su real :: delta real :: xnew real :: d real :: gnew real :: xbdi real :: s real :: hs real :: hred real :: dsq real :: crvmin Called by proc~~trsbox~~CalledByGraph proc~trsbox trsbox proc~bobyqb bobyqb proc~bobyqb->proc~trsbox proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb proc~bobyqa_test bobyqa_test proc~bobyqa_test->proc~bobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , gnew , & & xbdi , s , hs , hred , dsq , crvmin ) implicit real ( wp ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), gopt ( * ), hq ( * ), pq ( * ), sl ( * ), su ( * ), xnew & & ( * ), d ( * ), gnew ( * ), xbdi ( * ), s ( * ), hs ( * ), hred ( * ) ! !     The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same !       meanings as the corresponding arguments of BOBYQB. !     DELTA is the trust region radius for the present calculation, which !       seeks a small value of the quadratic model within distance DELTA of !       XOPT subject to the bounds on the variables. !     XNEW will be set to a new vector of variables that is approximately !       the one that minimizes the quadratic model within the trust region !       subject to the SL and SU constraints on the variables. It satisfies !       as equations the bounds that become active during the calculation. !     D is the calculated trial step from XOPT, generated iteratively from an !       initial value of zero. Thus XNEW is XOPT+D after the final iteration. !     GNEW holds the gradient of the quadratic model at XOPT+D. It is updated !       when D is updated. !     XBDI is a working space vector. For I=1,2,...,N, the element XBDI(I) is !       set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the !       I-th variable has become fixed at a bound, the bound being SL(I) or !       SU(I) in the case XBDI(I)=-1.0 or XBDI(I)=1.0, respectively. This !       information is accumulated during the construction of XNEW. !     The arrays S, HS and HRED are also used for working space. They hold the !       current search direction, and the changes in the gradient of Q along S !       and the reduced D, respectively, where the reduced D is the same as D, !       except that the components of the fixed variables are zero. !     DSQ will be set to the square of the length of XNEW-XOPT. !     CRVMIN is set to zero if D reaches the trust region boundary. Otherwise !       it is set to the least curvature of H that occurs in the conjugate !       gradient searches that are not restricted by any constraints. The !       value CRVMIN=-1.0D0 is set, however, if all of these searches are !       constrained. ! !     A version of the truncated conjugate gradient is applied. If a line !     search is restricted by a constraint, then the procedure is restarted, !     the values of the variables that are at their bounds being fixed. If !     the trust region boundary is reached, then further changes may be made !     to D, each one being in the two dimensional space that is spanned !     by the current D and the gradient of Q at XOPT+D, staying on the trust !     region boundary. Termination occurs when the reduction in Q seems to !     be close to the greatest reduction that can be achieved. ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp onemin = - 1.0_wp zero = 0.0_wp ! !     The sign of GOPT(I) gives the sign of the change to the I-th variable !     that will reduce Q from its value at XOPT. Thus XBDI(I) shows whether !     or not to fix the I-th variable at one of its bounds initially, with !     NACT being set to the number of fixed variables. D and GNEW are also !     set for the first iteration. DELSQ is the upper bound on the sum of !     squares of the free variables. QRED is the reduction in Q so far. ! iterc = 0 nact = 0 sqstp = zero do i = 1 , n xbdi ( i ) = zero if ( xopt ( i ) <= sl ( i )) then if ( gopt ( i ) >= zero ) xbdi ( i ) = onemin else if ( xopt ( i ) >= su ( i )) then if ( gopt ( i ) <= zero ) xbdi ( i ) = one end if if ( xbdi ( i ) /= zero ) nact = nact + 1 d ( i ) = zero gnew ( i ) = gopt ( i ) end do delsq = delta * delta qred = zero crvmin = onemin ! !     Set the next search direction of the conjugate gradient method. It is !     the steepest descent direction initially and when the iterations are !     restarted because a variable has just been fixed by a bound, and of !     course the components of the fixed variables are zero. ITERMAX is an !     upper bound on the indices of the conjugate gradient iterations. ! 20 beta = zero 30 stepsq = zero do i = 1 , n if ( xbdi ( i ) /= zero ) then s ( i ) = zero else if ( beta == zero ) then s ( i ) = - gnew ( i ) else s ( i ) = beta * s ( i ) - gnew ( i ) end if stepsq = stepsq + s ( i ) ** 2 end do if ( stepsq == zero ) go to 190 if ( beta == zero ) then gredsq = stepsq itermax = iterc + n - nact end if if ( gredsq * delsq <= 1.0e-4_wp * qred * qred ) go to 190 ! !     Multiply the search direction by the second derivative matrix of Q and !     calculate some scalars for the choice of steplength. Then set BLEN to !     the length of the the step to the trust region boundary and STPLEN to !     the steplength, ignoring the simple bounds. ! go to 210 50 resid = delsq ds = zero shs = zero do i = 1 , n if ( xbdi ( i ) == zero ) then resid = resid - d ( i ) ** 2 ds = ds + s ( i ) * d ( i ) shs = shs + s ( i ) * hs ( i ) end if end do if ( resid <= zero ) go to 90 temp = sqrt ( stepsq * resid + ds * ds ) if ( ds < zero ) then blen = ( temp - ds ) / stepsq else blen = resid / ( temp + ds ) end if stplen = blen if ( shs > zero ) then stplen = min ( blen , gredsq / shs ) end if ! ! !     Reduce STPLEN if necessary in order to preserve the simple bounds, !     letting IACT be the index of the new constrained variable. ! iact = 0 do i = 1 , n if ( s ( i ) /= zero ) then xsum = xopt ( i ) + d ( i ) if ( s ( i ) > zero ) then temp = ( su ( i ) - xsum ) / s ( i ) else temp = ( sl ( i ) - xsum ) / s ( i ) end if if ( temp < stplen ) then stplen = temp iact = i end if end if end do ! !     Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q. ! sdec = zero if ( stplen > zero ) then iterc = iterc + 1 temp = shs / stepsq if ( iact == 0 . and . temp > zero ) then crvmin = min ( crvmin , temp ) if ( crvmin == onemin ) crvmin = temp end if ggsav = gredsq gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + stplen * hs ( i ) if ( xbdi ( i ) == zero ) gredsq = gredsq + gnew ( i ) ** 2 d ( i ) = d ( i ) + stplen * s ( i ) end do sdec = max ( stplen * ( ggsav - half * stplen * shs ), zero ) qred = qred + sdec end if ! !     Restart the conjugate gradient method if it has hit a new bound. ! if ( iact > 0 ) then nact = nact + 1 xbdi ( iact ) = one if ( s ( iact ) < zero ) xbdi ( iact ) = onemin delsq = delsq - d ( iact ) ** 2 if ( delsq <= zero ) go to 90 go to 20 end if ! !     If STPLEN is less than BLEN, then either apply another conjugate !     gradient iteration or RETURN. ! if ( stplen < blen ) then if ( iterc == itermax ) go to 190 if ( sdec <= 0.01_wp * qred ) go to 190 beta = gredsq / ggsav go to 30 end if 90 crvmin = zero ! !     Prepare for the alternative iteration by calculating some scalars and !     by multiplying the reduced D by the second derivative matrix of Q. ! 100 if ( nact >= n - 1 ) go to 190 dredsq = zero dredg = zero gredsq = zero do i = 1 , n if ( xbdi ( i ) == zero ) then dredsq = dredsq + d ( i ) ** 2 dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 s ( i ) = d ( i ) else s ( i ) = zero end if end do itcsav = iterc go to 210 ! !     Let the search direction S be a linear combination of the reduced D !     and the reduced G that is orthogonal to the reduced D. ! 120 iterc = iterc + 1 temp = gredsq * dredsq - dredg * dredg if ( temp <= 1.0e-4_wp * qred * qred ) go to 190 temp = sqrt ( temp ) do i = 1 , n if ( xbdi ( i ) == zero ) then s ( i ) = ( dredg * d ( i ) - dredsq * gnew ( i )) / temp else s ( i ) = zero end if end do sredg = - temp ! !     By considering the simple bounds on the variables, calculate an upper !     bound on the tangent of half the angle of the alternative iteration, !     namely ANGBD, except that, if already a free variable has reached a !     bound, there is a branch back to label 100 after fixing that variable. ! angbd = one iact = 0 do i = 1 , n if ( xbdi ( i ) == zero ) then tempa = xopt ( i ) + d ( i ) - sl ( i ) tempb = su ( i ) - xopt ( i ) - d ( i ) if ( tempa <= zero ) then nact = nact + 1 xbdi ( i ) = onemin go to 100 else if ( tempb <= zero ) then nact = nact + 1 xbdi ( i ) = one go to 100 end if ratio = one ssq = d ( i ) ** 2 + s ( i ) ** 2 temp = ssq - ( xopt ( i ) - sl ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) - s ( i ) if ( angbd * temp > tempa ) then angbd = tempa / temp iact = i xsav = onemin end if end if temp = ssq - ( su ( i ) - xopt ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) + s ( i ) if ( angbd * temp > tempb ) then angbd = tempb / temp iact = i xsav = one end if end if end if end do ! !     Calculate HHD and some curvatures for the alternative iteration. ! go to 210 150 shs = zero dhs = zero dhd = zero do i = 1 , n if ( xbdi ( i ) == zero ) then shs = shs + s ( i ) * hs ( i ) dhs = dhs + d ( i ) * hs ( i ) dhd = dhd + d ( i ) * hred ( i ) end if end do ! !     Seek the greatest reduction in Q for a range of equally spaced values !     of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of !     the alternative iteration. ! redmax = zero isav = 0 redsav = zero iu = 1 7.0_wp * angbd + 3.1_wp do i = 1 , iu angt = angbd * real ( i , wp ) / real ( iu , wp ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) rednew = sth * ( angt * dredg - sredg - half * sth * temp ) if ( rednew > redmax ) then redmax = rednew isav = i rdprev = redsav else if ( i == isav + 1 ) then rdnext = rednew end if redsav = rednew end do ! !     Return if the reduction is zero. Otherwise, set the sine and cosine !     of the angle of the alternative iteration, and calculate SDEC. ! if ( isav == 0 ) go to 190 if ( isav < iu ) then temp = ( rdnext - rdprev ) / ( redmax + redmax - rdprev - rdnext ) angt = angbd * ( real ( isav , wp ) + half * temp ) / real ( iu , wp ) end if cth = ( one - angt * angt ) / ( one + angt * angt ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) sdec = sth * ( angt * dredg - sredg - half * sth * temp ) if ( sdec <= zero ) go to 190 ! !     Update GNEW, D and HRED. If the angle of the alternative iteration !     is restricted by a bound on a free variable, that variable is fixed !     at the bound. ! dredg = zero gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + ( cth - one ) * hred ( i ) + sth * hs ( i ) if ( xbdi ( i ) == zero ) then d ( i ) = cth * d ( i ) + sth * s ( i ) dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 end if hred ( i ) = cth * hred ( i ) + sth * hs ( i ) end do qred = qred + sdec if ( iact > 0 . and . isav == iu ) then nact = nact + 1 xbdi ( iact ) = xsav go to 100 end if ! !     If SDEC is sufficiently small, then RETURN after setting XNEW to !     XOPT+D, giving careful attention to the bounds. ! if ( sdec > 0.01_wp * qred ) go to 120 190 dsq = zero do i = 1 , n xnew ( i ) = max ( min ( xopt ( i ) + d ( i ), su ( i )), sl ( i )) if ( xbdi ( i ) == onemin ) xnew ( i ) = sl ( i ) if ( xbdi ( i ) == one ) xnew ( i ) = su ( i ) d ( i ) = xnew ( i ) - xopt ( i ) dsq = dsq + d ( i ) ** 2 end do return ! !     The following instructions multiply the current S-vector by the second !     derivative matrix of the quadratic model, putting the product in HS. !     They are reached from three different parts of the software above and !     they can be regarded as an external subroutine. ! 210 ih = 0 do j = 1 , n hs ( j ) = zero do i = 1 , j ih = ih + 1 if ( i < j ) hs ( j ) = hs ( j ) + hq ( ih ) * s ( i ) hs ( i ) = hs ( i ) + hq ( ih ) * s ( j ) end do end do do k = 1 , npt if ( pq ( k ) /= zero ) then temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * s ( j ) end do temp = temp * pq ( k ) do i = 1 , n hs ( i ) = hs ( i ) + temp * xpt ( k , i ) end do end if end do if ( crvmin /= zero ) go to 50 if ( iterc > itcsav ) go to 150 do i = 1 , n hred ( i ) = hs ( i ) end do go to 120 end subroutine trsbox","tags":"","loc":"proc/trsbox.html"},{"title":"update – PowellOpt","text":"private  subroutine update(n, npt, bmat, zmat, ndim, vlag, beta, denom, knew, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: bmat real :: zmat integer :: ndim real :: vlag real :: beta real :: denom integer :: knew real :: w Called by proc~~update~3~~CalledByGraph proc~update~3 update proc~bobyqb bobyqb proc~bobyqb->proc~update~3 proc~rescue rescue proc~bobyqb->proc~rescue proc~rescue->proc~update~3 proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb proc~bobyqa_test bobyqa_test proc~bobyqa_test->proc~bobyqa Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) implicit real ( wp ) ( a - h , o - z ) dimension bmat ( ndim , * ), zmat ( npt , * ), vlag ( * ), w ( * ) ! !     The arrays BMAT and ZMAT are updated, as required by the new position !     of the interpolation point that has the index KNEW. The vector VLAG has !     N+NPT components, set on entry to the first NPT and last N components !     of the product Hw in equation (4.11) of the Powell (2006) paper on !     NEWUOA. Further, BETA is set on entry to the value of the parameter !     with that name, and DENOM is set to the denominator of the updating !     formula. Elements of ZMAT may be treated as zero if their moduli are !     at most ZTEST. The first NDIM elements of W are used for working space. ! !     Set some constants. ! one = 1.0_wp zero = 0.0_wp nptm = npt - n - 1 ztest = zero do k = 1 , npt do j = 1 , nptm ztest = max ( ztest , abs ( zmat ( k , j ))) end do end do ztest = 1.0e-20_wp * ztest ! !     Apply the rotations that put zeros in the KNEW-th row of ZMAT. ! jl = 1 do j = 2 , nptm if ( abs ( zmat ( knew , j )) > ztest ) then temp = sqrt ( zmat ( knew , 1 ) ** 2 + zmat ( knew , j ) ** 2 ) tempa = zmat ( knew , 1 ) / temp tempb = zmat ( knew , j ) / temp do i = 1 , npt temp = tempa * zmat ( i , 1 ) + tempb * zmat ( i , j ) zmat ( i , j ) = tempa * zmat ( i , j ) - tempb * zmat ( i , 1 ) zmat ( i , 1 ) = temp end do end if zmat ( knew , j ) = zero end do ! !     Put the first NPT components of the KNEW-th column of HLAG into W, !     and calculate the parameters of the updating formula. ! do i = 1 , npt w ( i ) = zmat ( knew , 1 ) * zmat ( i , 1 ) end do alpha = w ( knew ) tau = vlag ( knew ) vlag ( knew ) = vlag ( knew ) - one ! !     Complete the updating of ZMAT. ! temp = sqrt ( denom ) tempb = zmat ( knew , 1 ) / temp tempa = tau / temp do i = 1 , npt zmat ( i , 1 ) = tempa * zmat ( i , 1 ) - tempb * vlag ( i ) end do ! !     Finally, update the matrix BMAT. ! do j = 1 , n jp = npt + j w ( jp ) = bmat ( knew , j ) tempa = ( alpha * vlag ( jp ) - tau * w ( jp )) / denom tempb = ( - beta * w ( jp ) - tau * vlag ( jp )) / denom do i = 1 , jp bmat ( i , j ) = bmat ( i , j ) + tempa * vlag ( i ) + tempb * w ( i ) if ( i > npt ) bmat ( jp , i - npt ) = bmat ( i , j ) end do end do end subroutine update","tags":"","loc":"proc/update~3.html"},{"title":"bobyqa_test – PowellOpt","text":"public  subroutine bobyqa_test() Test problem for bobyqa , the objective function being the sum of\nthe reciprocals of all pairwise distances between the points P_I,\nI=1,2,...,M in two dimensions, where M=N/2 and where the components\nof P_I are X(2 I-1) and X(2 I). Thus each vector X of N variables\ndefines the M points P_I. The initial X gives equally spaced points\non a circle. Four different choices of the pairs (N,NPT) are tried,\nnamely (10,16), (10,21), (20,26) and (20,41). Convergence to a local\nminimum that is not global occurs in both the N=10 cases. The details\nof the results are highly sensitive to computer rounding errors. The\nchoice IPRINT=2 provides the current X and optimal F so far whenever\nRHO is reduced. The bound constraints of the problem require every\ncomponent of X to be in the interval [-1,1]. Arguments None Calls proc~~bobyqa_test~~CallsGraph proc~bobyqa_test bobyqa_test proc~bobyqa bobyqa proc~bobyqa_test->proc~bobyqa proc~bobyqb bobyqb proc~bobyqa->proc~bobyqb proc~altmov altmov proc~bobyqb->proc~altmov proc~prelim~2 prelim proc~bobyqb->proc~prelim~2 proc~rescue rescue proc~bobyqb->proc~rescue proc~trsbox trsbox proc~bobyqb->proc~trsbox proc~update~3 update proc~bobyqb->proc~update~3 proc~rescue->proc~update~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bobyqa_test () implicit none real ( wp ), dimension ( 100 ) :: x , xl , xu integer :: i , j , m , n , jcase , npt real ( wp ) :: temp real ( wp ), parameter :: twopi = 8.0_wp * atan ( 1.0_wp ) real ( wp ), parameter :: bdl = - 1.0_wp real ( wp ), parameter :: bdu = 1.0_wp integer , parameter :: iprint = 2 integer , parameter :: maxfun = 500000 real ( wp ), parameter :: rhobeg = 1.0e-1_wp real ( wp ), parameter :: rhoend = 1.0e-6_wp m = 5 do n = 2 * m do i = 1 , n xl ( i ) = bdl xu ( i ) = bdu end do do jcase = 1 , 2 npt = n + 6 if ( jcase == 2 ) npt = 2 * n + 1 print 30 , m , n , npt 30 format ( / / 5 x , '2D output with M =' , i4 , ',  N =' , i4 , '  and  NPT =' , i4 ) do j = 1 , m temp = real ( j , wp ) * twopi / real ( m , wp ) x ( 2 * j - 1 ) = cos ( temp ) x ( 2 * j ) = sin ( temp ) end do call bobyqa ( n , npt , x , xl , xu , rhobeg , rhoend , iprint , maxfun , calfun ) end do m = m + m if ( m > 10 ) exit end do contains subroutine calfun ( n , x , f ) implicit none integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( out ) :: f integer :: i , j real ( wp ) :: temp f = 0.0_wp do i = 4 , n , 2 do j = 2 , i - 2 , 2 temp = ( x ( i - 1 ) - x ( j - 1 )) ** 2 + ( x ( i ) - x ( j )) ** 2 temp = max ( temp , 1.0e-6_wp ) f = f + 1.0_wp / sqrt ( temp ) end do end do end subroutine calfun end subroutine bobyqa_test","tags":"","loc":"proc/bobyqa_test.html"},{"title":"newuoa_module – PowellOpt","text":"NEWUOA: NEW U nconstrained O ptimization A lgorithm The purpose of NEWUOA is to seek\n  the least value of a function F of several variables, when derivatives\n  are not available.\n  The main new feature of the method is that quadratic\n  models are updated using only about NPT=2N+1 interpolation conditions,\n  the remaining freedom being taken up by minimizing the Frobenius norm of\n  the change to the second derivative matrix of the model. The new software was developed from uobyqa , which also forms quadratic\n  models from interpolation conditions. That method requires NPT=(N+1)(N+2)/2 conditions, however, because they have to define all the parameters of the\n  model. The least Frobenius norm updating procedure with NPT=2N+1 is usually\n  much more efficient when N is large, because the work of each iteration is\n  much less than before, and in some experiments the number of calculations\n  of the objective function seems to be only of magnitude N . References \" The NEWUOA software for unconstrained optimization without\n    derivatives \",\n    2004/NA08 \" The NEWUOA software for unconstrained minimization\n    without derivatives \", \n    in Large-Scale Nonlinear Optimization, editors G. Di\n    Pillo and M. Roma, Springer (2006), pages 255-297. History M.J.D. Powell, December 16th, 2004 : It is hoped that the software will\n    be helpful to much future research and to many applications. There are no\n    restrictions on or charges for its use. Jacob Williams, July 2015 : refactoring of the code into modern Fortran. Uses kind_module module~~newuoa_module~~UsesGraph module~newuoa_module newuoa_module module~kind_module kind_module module~newuoa_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~newuoa_module~~UsedByGraph module~newuoa_module newuoa_module module~powellopt powellopt module~powellopt->module~newuoa_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine func(n, x, f) calfun interface Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (*) real(kind=wp) :: f Subroutines public  subroutine newuoa (n, npt, x, rhobeg, rhoend, iprint, maxfun, calfun) This subroutine seeks the least value of a function of many variables,\nby a trust region method that forms quadratic models by interpolation.\nThere can be some freedom in the interpolation conditions, which is\ntaken up by minimizing the Frobenius norm of the change to the second\nderivative of the quadratic model, beginning with a zero matrix. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the number of variables. must be at least 2. integer, intent(in) :: npt The number of interpolation conditions.\nIts value must be in the interval [N+2,(N+1)(N+2)/2] . real(kind=wp), intent(inout), dimension(*) :: x Initial values of the variables must be set in X(1),X(2),...,X(N). They\nwill be changed to the values that give the least calculated F. real(kind=wp), intent(in) :: rhobeg RHOBEG and RHOEND must be set to the initial and final values of a trust\nregion radius, so both must be positive with RHOEND<=RHOBEG. Typically\nRHOBEG should be about one tenth of the greatest expected change to a\nvariable, and RHOEND should indicate the accuracy that is required in\nthe final values of the variables. real(kind=wp), intent(in) :: rhoend RHOBEG and RHOEND must be set to the initial and final values of a trust\nregion radius, so both must be positive with RHOEND<=RHOBEG. Typically\nRHOBEG should be about one tenth of the greatest expected change to a\nvariable, and RHOEND should indicate the accuracy that is required in\nthe final values of the variables. integer, intent(in) :: iprint The value of IPRINT should be set to 0, 1, 2 or 3, which controls the\namount of printing. Specifically, there is no output if IPRINT=0 and\nthere is output only at the return if IPRINT=1. Otherwise, each new\nvalue of RHO is printed, with the best vector of variables so far and\nthe corresponding value of the objective function. Further, each new\nvalue of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun an upper bound on the number of calls of CALFUN. procedure( func ) :: calfun It must set F to the value of the objective function \nfor the variables X(1),X(2),...,X(N) . private  subroutine newuob (n, npt, x, rhobeg, rhoend, iprint, maxfun, xbase, xopt, xnew, xpt, fval, gq, hq, pq, bmat, zmat, ndim, d, vlag, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: x real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: xbase real :: xopt real :: xnew real :: xpt real :: fval real :: gq real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: d real :: vlag real :: w procedure( func ) :: calfun private  subroutine bigden (n, npt, xopt, xpt, bmat, zmat, idz, ndim, kopt, knew, d, w, vlag, beta, s, wvec, prod) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xopt real :: xpt real :: bmat real :: zmat integer :: idz integer :: ndim integer :: kopt integer :: knew real :: d real :: w real :: vlag real :: beta real :: s real :: wvec real :: prod private  subroutine biglag (n, npt, xopt, xpt, bmat, zmat, idz, ndim, knew, delta, d, alpha, hcol, gc, gd, s, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xopt real :: xpt real :: bmat real :: zmat integer :: idz integer :: ndim integer :: knew real :: delta real :: d real :: alpha real :: hcol real :: gc real :: gd real :: s real :: w private  subroutine trsapp (n, npt, xopt, xpt, gq, hq, pq, delta, step, d, g, hd, hs, crvmin) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xopt real :: xpt real :: gq real :: hq real :: pq real :: delta real :: step real :: d real :: g real :: hd real :: hs real :: crvmin private  subroutine update (n, npt, bmat, zmat, idz, ndim, vlag, beta, knew, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: bmat real :: zmat integer :: idz integer :: ndim real :: vlag real :: beta integer :: knew real :: w public  subroutine newuoa_test () The Chebyquad test problem (Fletcher, 1965) for N = 2,4,6 and 8,\nwith NPT = 2N+1. Arguments None","tags":"","loc":"module/newuoa_module.html"},{"title":"cobyla_module – PowellOpt","text":"COBYLA: C onstrained O ptimization BY L inear A pproximations. Minimize an objective function F([X1,X2,...,XN]) subject to M inequality constraints. References \" A direct search optimization method that models the objective and constraint\n    functions by linear interpolation \", Advances in Optimization and Numerical Analysis (eds. Susana Gomez and Jean-Pierre Hennart), Kluwer Academic Publishers (1994). History Mike Powell (May 7th, 1992) -- There are no restrictions on the use of the\n    software, nor do I offer any guarantees of success. Jacob Williams, July 2015 : refactoring of the code into modern Fortran. Note There is a need for a linear programming problem to be solved subject to a\n      Euclidean norm trust region constraint. Therefore SUBROUTINE TRSTLP is provided,\n      but you may have some software that you prefer to use instead. Uses kind_module module~~cobyla_module~~UsesGraph module~cobyla_module cobyla_module module~kind_module kind_module module~cobyla_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~cobyla_module~~UsedByGraph module~cobyla_module cobyla_module module~powellopt powellopt module~powellopt->module~cobyla_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine func(n, m, x, f, con) calcfc interface Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(in), dimension(*) :: x real(kind=wp), intent(out) :: f real(kind=wp), intent(out), dimension(*) :: con Subroutines public  subroutine cobyla (n, m, x, rhobeg, rhoend, iprint, maxfun, calcfc) This subroutine minimizes an objective function F(X) subject to M\ninequality constraints on X, where X is a vector of variables that has\nN components. The algorithm employs linear approximations to the\nobjective and constraint functions, the approximations being formed by\nlinear interpolation at N+1 points in the space of the variables.\nWe regard these interpolation points as vertices of a simplex. The\nparameter RHO controls the size of the simplex and it is reduced\nautomatically from RHOBEG to RHOEND. For each RHO the subroutine tries\nto achieve a good vector of variables for the current size, and then\nRHO is reduced until the value RHOEND is reached. Therefore RHOBEG and\nRHOEND should be set to reasonable initial changes to and the required\naccuracy in the variables respectively, but this accuracy should be\nviewed as a subject for experimentation because it is not guaranteed. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n number of variables integer, intent(in) :: m number of inequality constraints real(kind=wp), intent(inout), dimension(*) :: x Initial values of the variables must be set in X(1),X(2),...,X(N).\nOn return they will be changed to the solution. real(kind=wp), intent(in) :: rhobeg reasonable initial change to variables (see description of RHO) real(kind=wp), intent(in) :: rhoend required accuracy (see description of RHO) integer, intent(in) :: iprint IPRINT should be set to 0, 1, 2 or 3, which controls the amount of\nprinting during the calculation. Specifically, there is no output if\nIPRINT=0 and there is output only at the end of the calculation if\nIPRINT=1. Otherwise each new value of RHO and SIGMA is printed.\nFurther, the vector of variables and some function information are\ngiven either when RHO is reduced or when each new value of F(X) is\ncomputed in the cases IPRINT=2 or IPRINT=3 respectively. Here SIGMA\nis a penalty parameter, it being assumed that a change to X is an\nimprovement if it reduces the merit function\n    F(X)+SIGMA*MAX(0.0,-C1(X),-C2(X),...,-CM(X)),\nwhere C1,C2,...,CM denote the constraint functions that should become\nnonnegative eventually, at least to the precision of RHOEND. In the\nprinted output the displayed term that is multiplied by SIGMA is\ncalled MAXCV, which stands for 'MAXimum Constraint Violation'. integer, intent(inout) :: maxfun MAXFUN is an integer variable that must be set by the user to a\nlimit on the number of calls of CALCFC.\nThe value of MAXFUN will be altered to the number of calls\nof CALCFC that are made. procedure( func ) :: calcfc In order to define the objective and constraint functions, we require\na subroutine that has the name and arguments\n    SUBROUTINE CALCFC (N,M,X,F,CON)\n    DIMENSION X( ),CON( )\nThe values of N and M are fixed and have been defined already, while\nX is now the current vector of variables. The subroutine should return\nthe objective and constraint functions at X in F and CON(1),CON(2),\n...,CON(M). Note that we are trying to adjust X so that F(X) is as\nsmall as possible subject to the constraint functions being nonnegative. private  subroutine cobylb (n, m, mpp, x, rhobeg, rhoend, iprint, maxfun, con, sim, simi, datmat, a, vsig, veta, sigbar, dx, w, iact, calcfc) Arguments Type Intent Optional Attributes Name integer :: n integer :: m integer :: mpp real :: x real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: con real :: sim real :: simi real :: datmat real :: a real :: vsig real :: veta real :: sigbar real :: dx real :: w integer :: iact procedure( func ) :: calcfc private  subroutine trstlp (n, m, a, b, rho, dx, ifull, iact, z, zdota, vmultc, sdirn, dxnew, vmultd) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: a real :: b real :: rho real :: dx integer :: ifull integer :: iact real :: z real :: zdota real :: vmultc real :: sdirn real :: dxnew real :: vmultd public  subroutine cobyla_test () Test routine for cobyla . Read more… Arguments None","tags":"","loc":"module/cobyla_module.html"},{"title":"powellopt – PowellOpt","text":"PowellOpt Module Uses uobyqa_module cobyla_module newuoa_module lincoa_module bobyqa_module module~~powellopt~~UsesGraph module~powellopt powellopt module~bobyqa_module bobyqa_module module~powellopt->module~bobyqa_module module~cobyla_module cobyla_module module~powellopt->module~cobyla_module module~lincoa_module lincoa_module module~powellopt->module~lincoa_module module~newuoa_module newuoa_module module~powellopt->module~newuoa_module module~uobyqa_module uobyqa_module module~powellopt->module~uobyqa_module module~kind_module kind_module module~bobyqa_module->module~kind_module module~cobyla_module->module~kind_module module~lincoa_module->module~kind_module module~newuoa_module->module~kind_module module~uobyqa_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses.","tags":"","loc":"module/powellopt.html"},{"title":"kind_module – PowellOpt","text":"Kind definitions for the other modules. Uses iso_fortran_env module~~kind_module~~UsesGraph module~kind_module kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~kind_module~~UsedByGraph module~kind_module kind_module module~bobyqa_module bobyqa_module module~bobyqa_module->module~kind_module module~cobyla_module cobyla_module module~cobyla_module->module~kind_module module~lincoa_module lincoa_module module~lincoa_module->module~kind_module module~newuoa_module newuoa_module module~newuoa_module->module~kind_module module~uobyqa_module uobyqa_module module~uobyqa_module->module~kind_module module~powellopt powellopt module~powellopt->module~bobyqa_module module~powellopt->module~cobyla_module module~powellopt->module~lincoa_module module~powellopt->module~newuoa_module module~powellopt->module~uobyqa_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 double precision [default]","tags":"","loc":"module/kind_module.html"},{"title":"lincoa_module – PowellOpt","text":"LINCOA: LIN early C onstrained O ptimization A lgorithm The purpose of LINCOA is to seek the least value of a function F of several variables\n  subject to general linear inequality constraints on the variables,\n  when derivatives of F are not available. History M.J.D. Powell, December 6th, 2013 : There are no\n    restrictions on or charges for the use of the software. I hope that the time\n    and effort I have spent on developing the package will be helpful to much\n    research and to many applications. Jacob Williams, July 2015 : refactoring of the code into modern Fortran. Uses kind_module module~~lincoa_module~~UsesGraph module~lincoa_module lincoa_module module~kind_module kind_module module~lincoa_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lincoa_module~~UsedByGraph module~lincoa_module lincoa_module module~powellopt powellopt module~powellopt->module~lincoa_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine func(n, x, f) calfun interface Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (*) real(kind=wp) :: f Subroutines public  subroutine lincoa (n, npt, m, a, ia, b, x, rhobeg, rhoend, iprint, maxfun, calfun) This subroutine seeks the least value of a function of many variables,\n  subject to general linear inequality constraints, by a trust region\n  method that forms quadratic models by interpolation. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the number of variables. must be at least 2. integer, intent(in) :: npt the number of interpolation conditions, which is\nrequired to be in the interval [N+2,(N+1)(N+2)/2]. Typical choices\nof the author are NPT=N+6 and NPT=2*N+1. Larger values tend to be\nhighly inefficent when the number of variables is substantial, due\nto the amount of work and extra difficulty of adjusting more points. integer, intent(in) :: m the number of linear inequality constraints. real(kind=wp), intent(in), dimension(ia,*) :: a a matrix whose columns are the constraint gradients, which are\nrequired to be nonzero. integer, intent(in) :: ia the first dimension of the array A, which must be at least N. real(kind=wp), intent(in), dimension(*) :: b the vector of right hand sides of the constraints, the J-th\nconstraint being that the scalar product of A(.,J) with X(.) is at\nmost B(J). The initial vector X(.) is made feasible by increasing\nthe value of B(J) if necessary. real(kind=wp), intent(inout), dimension(*) :: x the vector of variables. Initial values of X(1),X(2),...,X(N)\nmust be supplied. If they do not satisfy the constraints, then B\nis increased as mentioned above. X contains on return the variables\nthat have given the least calculated F subject to the constraints. real(kind=wp), intent(in) :: rhobeg RHOBEG and RHOEND must be set to the initial and final values of a\ntrust region radius, so both must be positive with RHOEND<=RHOBEG.\nTypically, RHOBEG should be about one tenth of the greatest expected\nchange to a variable, and RHOEND should indicate the accuracy that\nis required in the final values of the variables. real(kind=wp), intent(in) :: rhoend RHOBEG and RHOEND must be set to the initial and final values of a\ntrust region radius, so both must be positive with RHOEND<=RHOBEG.\nTypically, RHOBEG should be about one tenth of the greatest expected\nchange to a variable, and RHOEND should indicate the accuracy that\nis required in the final values of the variables. integer, intent(in) :: iprint The value of IPRINT should be set to 0, 1, 2 or 3, which controls the\namount of printing. Specifically, there is no output if IPRINT=0 and\nthere is output only at the return if IPRINT=1. Otherwise, the best\nfeasible vector of variables so far and the corresponding value of\nthe objective function are printed whenever RHO is reduced, where\nRHO is the current lower bound on the trust region radius. Further,\neach new value of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun an upper bound on the number of calls of CALFUN,\nits value being at least NPT+1. procedure( func ) :: calfun It must set\nF to the value of the objective function for the variables X(1),\nX(2),...,X(N). The value of the argument F is positive when CALFUN\nis called if and only if the current X satisfies the constraints private  subroutine lincob (n, npt, m, amat, b, x, rhobeg, rhoend, iprint, maxfun, xbase, xpt, fval, xsav, xopt, gopt, hq, pq, bmat, zmat, ndim, step, sp, xnew, iact, rescon, qfac, rfac, pqw, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt integer :: m real :: amat real :: b real :: x real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xsav real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: step real :: sp real :: xnew integer :: iact real :: rescon real :: qfac real :: rfac real :: pqw real :: w procedure( func ) :: calfun private  subroutine getact (n, m, amat, b, nact, iact, qfac, rfac, snorm, resnew, resact, g, dw, vlam, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: m real :: amat real :: b integer :: nact integer :: iact real :: qfac real :: rfac real :: snorm real :: resnew real :: resact real :: g real :: dw real :: vlam real :: w private  subroutine prelim (n, npt, m, amat, b, x, rhobeg, iprint, xbase, xpt, fval, xsav, xopt, gopt, kopt, hq, pq, bmat, zmat, idz, ndim, sp, rescon, step, pqw, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt integer :: m real :: amat real :: b real :: x real :: rhobeg integer :: iprint real :: xbase real :: xpt real :: fval real :: xsav real :: xopt real :: gopt integer :: kopt real :: hq real :: pq real :: bmat real :: zmat integer :: idz integer :: ndim real :: sp real :: rescon real :: step real :: pqw real :: w procedure( func ) :: calfun private  subroutine qmstep (n, npt, m, amat, b, xpt, xopt, nact, iact, rescon, qfac, kopt, knew, del, step, gl, pqw, rstat, w, ifeas) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt integer :: m real :: amat real :: b real :: xpt real :: xopt integer :: nact integer :: iact real :: rescon real :: qfac integer :: kopt integer :: knew real :: del real :: step real :: gl real :: pqw real :: rstat real :: w integer :: ifeas private  subroutine trstep (n, npt, m, amat, b, xpt, hq, pq, nact, iact, rescon, qfac, rfac, snorm, step, g, resnew, resact, d, dw, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt integer :: m real :: amat real :: b real :: xpt real :: hq real :: pq integer :: nact integer :: iact real :: rescon real :: qfac real :: rfac real :: snorm real :: step real :: g real :: resnew real :: resact real :: d real :: dw real :: w private  subroutine update (n, npt, xpt, bmat, zmat, idz, ndim, sp, step, kopt, knew, vlag, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: bmat real :: zmat integer :: idz integer :: ndim real :: sp real :: step integer :: kopt integer :: knew real :: vlag real :: w public  subroutine lincoa_test () Test problem for lincoa . Read more… Arguments None","tags":"","loc":"module/lincoa_module.html"},{"title":"uobyqa_module – PowellOpt","text":"UOBYQA: U nconstrained O ptimization BY Q uadratic A pproximation The purpose of UOBYQA is to seek the least value of a function F of several variables,\n  when derivatives are not available.\n  It uses a trust region method that forms quadratic models by interpolation. References \"UOBYQA: unconstrained optimization by\n    quadratic approximation\" by M.J.D. Powell, Report DAMTP 2000/NA14,\n    University of Cambridge. \" UOBYQA: unconstrained optimization by quadratic\n    approximation \" by\n    M.J.D. Powell, Mathematical Programming Series B, Volume\n    92, pages 555-582 (2002). History M.J.D. Powell : It is hoped that the software will\n    be helpful to much future research and to many applications.\n    There are no restrictions on or charges for its use. Jacob Williams, July 2015 : refactoring of the code into modern Fortran. Uses kind_module module~~uobyqa_module~~UsesGraph module~uobyqa_module uobyqa_module module~kind_module kind_module module~uobyqa_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~uobyqa_module~~UsedByGraph module~uobyqa_module uobyqa_module module~powellopt powellopt module~powellopt->module~uobyqa_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: half = 0.5_wp real(kind=wp), private, parameter :: one = 1.0_wp real(kind=wp), private, parameter :: tenth = 0.1_wp real(kind=wp), private, parameter :: zero = 0.0_wp real(kind=wp), private, parameter :: quart = 0.25_wp real(kind=wp), private, parameter :: two = 2.0_wp real(kind=wp), private, parameter :: halfrt = sqrt(half) Abstract Interfaces abstract interface private  subroutine func(n, x, f) calfun interface Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: x (*) real(kind=wp) :: f Subroutines public  subroutine uobyqa (n, x, rhobeg, rhoend, iprint, maxfun, calfun) This subroutine seeks the least value of a function of many variables,\nby a trust region method that forms quadratic models by interpolation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the number of variables and must be at least two real(kind=wp), intent(inout), dimension(*) :: x Initial values of the variables must be set in X(1),X(2),...,X(N). They\nwill be changed to the values that give the least calculated F. real(kind=wp), intent(in) :: rhobeg RHOBEG and RHOEND must be set to the initial and final values of a trust\nregion radius, so both must be positive with RHOEND<=RHOBEG. Typically\nRHOBEG should be about one tenth of the greatest expected change to a\nvariable, and RHOEND should indicate the accuracy that is required in\nthe final values of the variables. real(kind=wp), intent(in) :: rhoend RHOBEG and RHOEND must be set to the initial and final values of a trust\nregion radius, so both must be positive with RHOEND<=RHOBEG. Typically\nRHOBEG should be about one tenth of the greatest expected change to a\nvariable, and RHOEND should indicate the accuracy that is required in\nthe final values of the variables. integer, intent(in) :: iprint The value of IPRINT should be set to 0, 1, 2 or 3, which controls the\namount of printing. Specifically, there is no output if IPRINT=0 and\nthere is output only at the return if IPRINT=1. Otherwise, each new\nvalue of RHO is printed, with the best vector of variables so far and\nthe corresponding value of the objective function. Further, each new\nvalue of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun upper bound on the number of calls of CALFUN. procedure( func ) :: calfun It must set F to the value of the objective\nfunction for the variables X(1),X(2),...,X(N). private  subroutine uobyqb (n, x, rhobeg, rhoend, iprint, maxfun, npt, xbase, xopt, xnew, xpt, pq, pl, h, g, d, vlag, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n real :: x real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun integer :: npt real :: xbase real :: xopt real :: xnew real :: xpt real :: pq real :: pl real :: h real :: g real :: d real :: vlag real :: w procedure( func ) :: calfun private  subroutine lagmax (n, g, h, rho, d, v, vmax) Arguments Type Intent Optional Attributes Name integer :: n real :: g real :: h real :: rho real :: d real :: v real :: vmax private  subroutine trstep (n, g, h, delta, tol, d, gg, td, tn, w, piv, z, evalue) Arguments Type Intent Optional Attributes Name integer :: n real :: g real :: h real :: delta real :: tol real :: d real :: gg real :: td real :: tn real :: w real :: piv real :: z real :: evalue public  subroutine uobyqa_test () The Chebyquad test problem (Fletcher, 1965) for N = 2,4,6,8. Arguments None","tags":"","loc":"module/uobyqa_module.html"},{"title":"bobyqa_module – PowellOpt","text":"BOBYQA: B ound O ptimization BY Q uadratic A pproximation The purpose of BOBYQA is to seek the least value of a function F of several\n  variables, when derivatives are not available. The constraints are the lower\n  and upper bounds on every variable, which can be set to huge values for\n  unconstrained variables. The algorithm is intended to change the variables to values that are close\n  to a local minimum of F. The user, however, should assume responsibility for\n  finding out if the calculations are satisfactory, by considering carefully\n  the values of F that occur. References \" The BOBYQA algorithm for bound constrained optimization without\n    derivatives \". History M.J.D. Powell (January 5th, 2009) -- There are no restrictions on or charges\n    for the use of the software. I hope that the time and effort I have spent on\n     developing the package will be helpful to much research and to many applications. Jacob Williams, July 2015 : refactoring of the code into modern Fortran. Uses kind_module module~~bobyqa_module~~UsesGraph module~bobyqa_module bobyqa_module module~kind_module kind_module module~bobyqa_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~bobyqa_module~~UsedByGraph module~bobyqa_module bobyqa_module module~powellopt powellopt module~powellopt->module~bobyqa_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine func(n, x, f) calfun interface Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out) :: f Subroutines public  subroutine bobyqa (n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, calfun) This subroutine seeks the least value of a function of many variables,\nby applying a trust region method that forms quadratic models by\ninterpolation. There is usually some freedom in the interpolation\nconditions, which is taken up by minimizing the Frobenius norm of\nthe change to the second derivative of the model, beginning with the\nzero matrix. The values of the variables are constrained by upper and\nlower bounds. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n number of variables (must be at least two) integer, intent(in) :: npt number of interpolation conditions. Its value must be in\nthe interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not\nrecommended. real(kind=wp), intent(inout), dimension(:) :: x Initial values of the variables must be set in X(1),X(2),...,X(N). They\nwill be changed to the values that give the least calculated F. real(kind=wp), intent(in), dimension(:) :: xl lower bounds on x. The construction of quadratic models\nrequires XL(I) to be strictly less than XU(I) for each I. Further,\nthe contribution to a model from changes to the I-th variable is\ndamaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=wp), intent(in), dimension(:) :: xu upper bounds on x. The construction of quadratic models\nrequires XL(I) to be strictly less than XU(I) for each I. Further,\nthe contribution to a model from changes to the I-th variable is\ndamaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=wp), intent(in) :: rhobeg RHOBEG must be set to the initial value of a trust region radius.\nIt must be positive, and typically should be about one tenth of the greatest\nexpected change to a variable.  An error return occurs if any of\nthe differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real(kind=wp), intent(in) :: rhoend RHOEND must be set to the final value of a trust\nregion radius. It must be positive with RHOEND no greater than\nRHOBEG. Typically, RHOEND should indicate the\naccuracy that is required in the final values of the variables. integer, intent(in) :: iprint IPRINT should be set to 0, 1, 2 or 3, which controls the\namount of printing. Specifically, there is no output if IPRINT=0 and\nthere is output only at the return if IPRINT=1. Otherwise, each new\nvalue of RHO is printed, with the best vector of variables so far and\nthe corresponding value of the objective function. Further, each new\nvalue of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun an upper bound on the number of calls of CALFUN. procedure( func ) :: calfun SUBROUTINE CALFUN (N,X,F) has to be provided by the user. It must set\nF to the value of the objective function for the current values of the\nvariables X(1),X(2),...,X(N), which are generated automatically in a\nway that satisfies the bounds given in XL and XU. private  subroutine bobyqb (n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, xnew, xalt, d, vlag, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su real :: xnew real :: xalt real :: d real :: vlag real :: w procedure( func ) :: calfun private  subroutine altmov (n, npt, xpt, xopt, bmat, zmat, ndim, sl, su, kopt, knew, adelt, xnew, xalt, alpha, cauchy, glag, hcol, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: kopt integer :: knew real :: adelt real :: xnew real :: xalt real :: alpha real :: cauchy real :: glag real :: hcol real :: w private  subroutine prelim (n, npt, x, xl, xu, rhobeg, iprint, maxfun, xbase, xpt, fval, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, kopt, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf integer :: kopt procedure( func ) :: calfun private  subroutine rescue (n, npt, xl, xu, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, delta, kopt, vlag, ptsaux, ptsid, w, calfun) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xl real :: xu integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf real :: delta integer :: kopt real :: vlag real :: ptsaux real :: ptsid real :: w procedure( func ) :: calfun private  subroutine trsbox (n, npt, xpt, xopt, gopt, hq, pq, sl, su, delta, xnew, d, gnew, xbdi, s, hs, hred, dsq, crvmin) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: gopt real :: hq real :: pq real :: sl real :: su real :: delta real :: xnew real :: d real :: gnew real :: xbdi real :: s real :: hs real :: hred real :: dsq real :: crvmin private  subroutine update (n, npt, bmat, zmat, ndim, vlag, beta, denom, knew, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: bmat real :: zmat integer :: ndim real :: vlag real :: beta real :: denom integer :: knew real :: w public  subroutine bobyqa_test () Test problem for bobyqa , the objective function being the sum of\nthe reciprocals of all pairwise distances between the points P_I,\nI=1,2,...,M in two dimensions, where M=N/2 and where the components\nof P_I are X(2 I-1) and X(2 I). Thus each vector X of N variables\ndefines the M points P_I. The initial X gives equally spaced points\non a circle. Four different choices of the pairs (N,NPT) are tried,\nnamely (10,16), (10,21), (20,26) and (20,41). Convergence to a local\nminimum that is not global occurs in both the N=10 cases. The details\nof the results are highly sensitive to computer rounding errors. The\nchoice IPRINT=2 provides the current X and optimal F so far whenever\nRHO is reduced. The bound constraints of the problem require every\ncomponent of X to be in the interval [-1,1]. Arguments None","tags":"","loc":"module/bobyqa_module.html"},{"title":"newuoa.f90 – PowellOpt","text":"This file depends on sourcefile~~newuoa.f90~~EfferentGraph sourcefile~newuoa.f90 newuoa.f90 sourcefile~kind_module.f90 kind_module.f90 sourcefile~newuoa.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~newuoa.f90~~AfferentGraph sourcefile~newuoa.f90 newuoa.f90 sourcefile~powellopt.f90 powellopt.f90 sourcefile~powellopt.f90->sourcefile~newuoa.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  NEWUOA: **NEW** **U**nconstrained **O**ptimization **A**lgorithm ! !  The purpose of NEWUOA is to seek !  the least value of a function F of several variables, when derivatives !  are not available. !  The main new feature of the method is that quadratic !  models are updated using only about ```NPT=2N+1``` interpolation conditions, !  the remaining freedom being taken up by minimizing the Frobenius norm of !  the change to the second derivative matrix of the model. ! !  The new software was developed from [[UOBYQA]], which also forms quadratic !  models from interpolation conditions. That method requires ```NPT=(N+1)(N+2)/2``` !  conditions, however, because they have to define all the parameters of the !  model. The least Frobenius norm updating procedure with ```NPT=2N+1``` is usually !  much more efficient when ```N``` is large, because the work of each iteration is !  much less than before, and in some experiments the number of calculations !  of the objective function seems to be only of magnitude ```N```. ! !# References ! !  * \"[The NEWUOA software for unconstrained optimization without !    derivatives](http://www.damtp.cam.ac.uk/user/na/NA_papers/NA2004_08.pdf)\", !    2004/NA08 !  * \"[The NEWUOA software for unconstrained minimization !    without derivatives](http://link.springer.com/chapter/10.1007%2F0-387-30065-1_16)\", !    in Large-Scale Nonlinear Optimization, editors G. Di !    Pillo and M. Roma, Springer (2006), pages 255-297. ! !# History !  * M.J.D. Powell, December 16th, 2004 : It is hoped that the software will !    be helpful to much future research and to many applications. There are no !    restrictions on or charges for its use. !  * Jacob Williams, July 2015 : refactoring of the code into modern Fortran. module newuoa_module use kind_module , only : wp private abstract interface subroutine func ( n , x , f ) !! calfun interface import :: wp implicit none integer :: n real ( wp ) :: x ( * ) real ( wp ) :: f end subroutine func end interface public :: newuoa public :: newuoa_test contains !***************************************************************************************** !> !  This subroutine seeks the least value of a function of many variables, !  by a trust region method that forms quadratic models by interpolation. !  There can be some freedom in the interpolation conditions, which is !  taken up by minimizing the Frobenius norm of the change to the second !  derivative of the quadratic model, beginning with a zero matrix. subroutine newuoa ( n , npt , x , rhobeg , rhoend , iprint , maxfun , calfun ) implicit none integer , intent ( in ) :: n !! the number of variables. must be at least 2. integer , intent ( in ) :: npt !! The number of interpolation conditions. !! Its value must be in the interval `[N+2,(N+1)(N+2)/2]`. real ( wp ), dimension ( * ), intent ( inout ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). They !! will be changed to the values that give the least calculated F. real ( wp ), intent ( in ) :: rhobeg !! RHOBEG and RHOEND must be set to the initial and final values of a trust !! region radius, so both must be positive with RHOEND<=RHOBEG. Typically !! RHOBEG should be about one tenth of the greatest expected change to a !! variable, and RHOEND should indicate the accuracy that is required in !! the final values of the variables. real ( wp ), intent ( in ) :: rhoend !! RHOBEG and RHOEND must be set to the initial and final values of a trust !! region radius, so both must be positive with RHOEND<=RHOBEG. Typically !! RHOBEG should be about one tenth of the greatest expected change to a !! variable, and RHOEND should indicate the accuracy that is required in !! the final values of the variables. integer , intent ( in ) :: iprint !! The value of IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, each new !! value of RHO is printed, with the best vector of variables so far and !! the corresponding value of the objective function. Further, each new !! value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! an upper bound on the number of calls of CALFUN. procedure ( func ) :: calfun !! It must set F to the value of the objective function !! for the variables `X(1),X(2),...,X(N)`. real ( wp ), dimension (:), allocatable :: w integer :: np , nptm , ndim , ixb , ixo , ixn , ixp , ifv , igq , ihq , ipq , ibmat , izmat , id , ivl , iw ! Partition the working space array, so that different parts of it can be ! treated separately by the subroutine that performs the main calculation. np = n + 1 nptm = npt - np if ( npt < n + 2 . or . npt > (( n + 2 ) * np ) / 2 ) then write ( * , * ) 'Return from NEWUOA because NPT is not in the required interval' return end if ! The array W will be used for working space allocate ( w (( NPT + 13 ) * ( NPT + N ) + 3 * N * ( N + 3 ) / 2 )) ndim = npt + n ixb = 1 ixo = ixb + n ixn = ixo + n ixp = ixn + n ifv = ixp + n * npt igq = ifv + npt ihq = igq + n ipq = ihq + ( n * np ) / 2 ibmat = ipq + npt izmat = ibmat + ndim * n id = izmat + npt * nptm ivl = id + n iw = ivl + ndim ! The above settings provide a partition of W for subroutine NEWUOB. ! The partition requires the first NPT*(NPT+N)+5*N*(N+3)/2 elements of ! W plus the space that is needed by the last array of NEWUOB. call newuob ( n , npt , x , rhobeg , rhoend , iprint , maxfun , w ( ixb ), w ( ixo ), w ( ixn ), & w ( ixp ), w ( ifv ), w ( igq ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , & w ( id ), w ( ivl ), w ( iw ), calfun ) deallocate ( w ) end subroutine newuoa !***************************************************************************************** subroutine newuob ( n , npt , x , rhobeg , rhoend , iprint , maxfun , xbase , xopt , xnew , xpt , & fval , gq , hq , pq , bmat , zmat , ndim , d , vlag , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension x ( * ), xbase ( * ), xopt ( * ), xnew ( * ), xpt ( npt , * ), fval ( * ), gq ( * ), hq & ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), d ( * ), vlag ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, X, RHOBEG, RHOEND, IPRINT and MAXFUN are identical !       to the corresponding arguments in SUBROUTINE NEWUOA. !     XBASE will hold a shift of origin that should reduce the contributions !       from rounding errors to values of the model and Lagrange functions. !     XOPT will be set to the displacement from XBASE of the vector of !       variables that provides the least calculated F so far. !     XNEW will be set to the displacement from XBASE of the vector of !       variables for the current calculation of F. !     XPT will contain the interpolation point coordinates relative to XBASE. !     FVAL will hold the values of F at the interpolation points. !     GQ will hold the gradient of the quadratic model at XBASE. !     HQ will hold the explicit second derivatives of the quadratic model. !     PQ will contain the parameters of the implicit second derivatives of !       the quadratic model. !     BMAT will hold the last N columns of H. !     ZMAT will hold the factorization of the leading NPT by NPT submatrix of !       H, this factorization being ZMAT times Diag(DZ) times ZMAT&#94;T, where !       the elements of DZ are plus or minus one, as specified by IDZ. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     D is reserved for trial steps from XOPT. !     VLAG will contain the values of the Lagrange functions at a new point X. !       They are part of a product that requires VLAG to be of length NDIM. !     The array W will be used for working space. Its length must be at least !       10*NDIM = 10*(NPT+N). ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp tenth = 0.1_wp zero = 0.0_wp np = n + 1 nh = ( n * np ) / 2 nptm = npt - np nftest = max ( maxfun , 1 ) ! !     Set the initial elements of XPT, BMAT, HQ, PQ and ZMAT to zero. ! do j = 1 , n xbase ( j ) = x ( j ) do k = 1 , npt xpt ( k , j ) = zero end do do i = 1 , ndim bmat ( i , j ) = zero end do end do do ih = 1 , nh hq ( ih ) = zero end do do k = 1 , npt pq ( k ) = zero do j = 1 , nptm zmat ( k , j ) = zero end do end do ! !     Begin the initialization procedure. NF becomes one more than the number !     of function values so far. The coordinates of the displacement of the !     next initial interpolation point from XBASE are set in XPT(NF,.). ! rhosq = rhobeg * rhobeg recip = one / rhosq reciq = sqrt ( half ) / rhosq nf = 0 50 nfm = nf nfmm = nf - n nf = nf + 1 if ( nfm <= 2 * n ) then if ( nfm >= 1 . and . nfm <= n ) then xpt ( nf , nfm ) = rhobeg else if ( nfm > n ) then xpt ( nf , nfmm ) = - rhobeg end if else itemp = ( nfmm - 1 ) / n jpt = nfm - itemp * n - n ipt = jpt + itemp if ( ipt > n ) then itemp = jpt jpt = ipt - n ipt = itemp end if xipt = rhobeg if ( fval ( ipt + np ) < fval ( ipt + 1 )) xipt = - xipt xjpt = rhobeg if ( fval ( jpt + np ) < fval ( jpt + 1 )) xjpt = - xjpt xpt ( nf , ipt ) = xipt xpt ( nf , jpt ) = xjpt end if ! !     Calculate the next value of F, label 70 being reached immediately !     after this calculation. The least function value so far and its index !     are required. ! do j = 1 , n x ( j ) = xpt ( nf , j ) + xbase ( j ) end do go to 310 70 fval ( nf ) = f if ( nf == 1 ) then fbeg = f fopt = f kopt = 1 else if ( f < fopt ) then fopt = f kopt = nf end if ! !     Set the nonzero initial elements of BMAT and the quadratic model in !     the cases when NF is at most 2*N+1. ! if ( nfm <= 2 * n ) then if ( nfm >= 1 . and . nfm <= n ) then gq ( nfm ) = ( f - fbeg ) / rhobeg if ( npt < nf + n ) then bmat ( 1 , nfm ) = - one / rhobeg bmat ( nf , nfm ) = one / rhobeg bmat ( npt + nfm , nfm ) = - half * rhosq end if else if ( nfm > n ) then bmat ( nf - n , nfmm ) = half / rhobeg bmat ( nf , nfmm ) = - half / rhobeg zmat ( 1 , nfmm ) = - reciq - reciq zmat ( nf - n , nfmm ) = reciq zmat ( nf , nfmm ) = reciq ih = ( nfmm * ( nfmm + 1 )) / 2 temp = ( fbeg - f ) / rhobeg hq ( ih ) = ( gq ( nfmm ) - temp ) / rhobeg gq ( nfmm ) = half * ( gq ( nfmm ) + temp ) end if ! !     Set the off-diagonal second derivatives of the Lagrange functions and !     the initial quadratic model. ! else ih = ( ipt * ( ipt - 1 )) / 2 + jpt if ( xipt < zero ) ipt = ipt + n if ( xjpt < zero ) jpt = jpt + n zmat ( 1 , nfmm ) = recip zmat ( nf , nfmm ) = recip zmat ( ipt + 1 , nfmm ) = - recip zmat ( jpt + 1 , nfmm ) = - recip hq ( ih ) = ( fbeg - fval ( ipt + 1 ) - fval ( jpt + 1 ) + f ) / ( xipt * xjpt ) end if if ( nf < npt ) go to 50 ! !     Begin the iterative procedure, because the initial model is complete. ! rho = rhobeg delta = rho idz = 1 diffa = zero diffb = zero itest = 0 xoptsq = zero do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do 90 nfsav = nf ! !     Generate the next trust region step and test its length. Set KNEW !     to -1 if the purpose of the next F will be to improve the model. ! 100 knew = 0 call trsapp ( n , npt , xopt , xpt , gq , hq , pq , delta , d , w , w ( np ), w ( np + n ), & w ( np + 2 * n ), crvmin ) dsq = zero do i = 1 , n dsq = dsq + d ( i ) ** 2 end do dnorm = min ( delta , sqrt ( dsq )) if ( dnorm < half * rho ) then knew = - 1 delta = tenth * delta ratio = - 1.0_wp if ( delta <= 1.5_wp * rho ) delta = rho if ( nf <= nfsav + 2 ) go to 460 temp = 0.125_wp * crvmin * rho * rho if ( temp <= max ( diffa , diffb , diffc )) go to 460 go to 490 end if ! !     Shift XBASE if XOPT may be too far from XBASE. First make the changes !     to BMAT that do not depend on ZMAT. ! 120 if ( dsq <= 1.0e-3_wp * xoptsq ) then tempq = 0.25_wp * xoptsq do k = 1 , npt sum = zero do i = 1 , n sum = sum + xpt ( k , i ) * xopt ( i ) end do temp = pq ( k ) * sum sum = sum - half * xoptsq w ( npt + k ) = sum do i = 1 , n gq ( i ) = gq ( i ) + temp * xpt ( k , i ) xpt ( k , i ) = xpt ( k , i ) - half * xopt ( i ) vlag ( i ) = bmat ( k , i ) w ( i ) = sum * xpt ( k , i ) + tempq * xopt ( i ) ip = npt + i do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + vlag ( i ) * w ( j ) + w ( i ) * vlag ( j ) end do end do end do ! !     Then the revisions of BMAT that depend on ZMAT are calculated. ! do k = 1 , nptm sumz = zero do i = 1 , npt sumz = sumz + zmat ( i , k ) w ( i ) = w ( npt + i ) * zmat ( i , k ) end do do j = 1 , n sum = tempq * sumz * xopt ( j ) do i = 1 , npt sum = sum + w ( i ) * xpt ( i , j ) end do vlag ( j ) = sum if ( k < idz ) sum = - sum do i = 1 , npt bmat ( i , j ) = bmat ( i , j ) + sum * zmat ( i , k ) end do end do do i = 1 , n ip = i + npt temp = vlag ( i ) if ( k < idz ) temp = - temp do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + temp * vlag ( j ) end do end do end do ! !     The following instructions complete the shift of XBASE, including !     the changes to the parameters of the quadratic model. ! ih = 0 do j = 1 , n w ( j ) = zero do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) xpt ( k , j ) = xpt ( k , j ) - half * xopt ( j ) end do do i = 1 , j ih = ih + 1 if ( i < j ) gq ( j ) = gq ( j ) + hq ( ih ) * xopt ( i ) gq ( i ) = gq ( i ) + hq ( ih ) * xopt ( j ) hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + xopt ( i ) * w ( j ) bmat ( npt + i , j ) = bmat ( npt + j , i ) end do end do do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) xopt ( j ) = zero end do xoptsq = zero end if ! !     Pick the model step if KNEW is positive. A different choice of D !     may be made later, if the choice of D by BIGLAG causes substantial !     cancellation in DENOM. ! if ( knew > 0 ) then call biglag ( n , npt , xopt , xpt , bmat , zmat , idz , ndim , knew , dstep , d , alpha , & vlag , vlag ( npt + 1 ), w , w ( np ), w ( np + n )) end if ! !     Calculate VLAG and BETA for the current choice of D. The first NPT !     components of W_check will be held in W. ! do k = 1 , npt suma = zero sumb = zero sum = zero do j = 1 , n suma = suma + xpt ( k , j ) * d ( j ) sumb = sumb + xpt ( k , j ) * xopt ( j ) sum = sum + bmat ( k , j ) * d ( j ) end do w ( k ) = suma * ( half * suma + sumb ) vlag ( k ) = sum end do beta = zero do k = 1 , nptm sum = zero do i = 1 , npt sum = sum + zmat ( i , k ) * w ( i ) end do if ( k < idz ) then beta = beta + sum * sum sum = - sum else beta = beta - sum * sum end if do i = 1 , npt vlag ( i ) = vlag ( i ) + sum * zmat ( i , k ) end do end do bsum = zero dx = zero do j = 1 , n sum = zero do i = 1 , npt sum = sum + w ( i ) * bmat ( i , j ) end do bsum = bsum + sum * d ( j ) jp = npt + j do k = 1 , n sum = sum + bmat ( jp , k ) * d ( k ) end do vlag ( jp ) = sum bsum = bsum + sum * d ( j ) dx = dx + d ( j ) * xopt ( j ) end do beta = dx * dx + dsq * ( xoptsq + dx + dx + half * dsq ) + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     If KNEW is positive and if the cancellation in DENOM is unacceptable, !     then BIGDEN calculates an alternative model step, XNEW being used for !     working space. ! if ( knew > 0 ) then temp = one + alpha * beta / vlag ( knew ) ** 2 if ( abs ( temp ) <= 0.8_wp ) then call bigden ( n , npt , xopt , xpt , bmat , zmat , idz , ndim , kopt , knew , d , w , & vlag , beta , xnew , w ( ndim + 1 ), w ( 6 * ndim + 1 )) end if end if ! !     Calculate the next value of the objective function. ! 290 do i = 1 , n xnew ( i ) = xopt ( i ) + d ( i ) x ( i ) = xbase ( i ) + xnew ( i ) end do nf = nf + 1 310 if ( nf > nftest ) then nf = nf - 1 if ( iprint > 0 ) print 320 320 format ( / 4 x , 'Return from NEWUOA because CALFUN has been' ,& ' called MAXFUN times.' ) go to 530 end if call calfun ( n , x , f ) if ( iprint == 3 ) then print 330 , nf , f , ( x ( i ), i = 1 , n ) 330 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( nf <= npt ) go to 70 if ( knew ==- 1 ) go to 530 ! !     Use the quadratic model to predict the change in F due to the step D, !     and set DIFF to the error of this prediction. ! vquad = zero ih = 0 do j = 1 , n vquad = vquad + d ( j ) * gq ( j ) do i = 1 , j ih = ih + 1 temp = d ( i ) * xnew ( j ) + d ( j ) * xopt ( i ) if ( i == j ) temp = half * temp vquad = vquad + temp * hq ( ih ) end do end do do k = 1 , npt vquad = vquad + pq ( k ) * w ( k ) end do diff = f - fopt - vquad diffc = diffb diffb = diffa diffa = abs ( diff ) if ( dnorm > rho ) nfsav = nf ! !     Update FOPT and XOPT if the new F is the least value of the objective !     function so far. The branch when KNEW is positive occurs if D is not !     a trust region step. ! fsave = fopt if ( f < fopt ) then fopt = f xoptsq = zero do i = 1 , n xopt ( i ) = xnew ( i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do end if ksave = knew if ( knew > 0 ) go to 410 ! !     Pick the next value of DELTA after a trust region step. ! if ( vquad >= zero ) then if ( iprint > 0 ) print 370 370 format ( / 4 x , 'Return from NEWUOA because a trust' ,& ' region step has failed to reduce Q.' ) go to 530 end if ratio = ( f - fsave ) / vquad if ( ratio <= tenth ) then delta = half * dnorm else if ( ratio <= 0.7_wp ) then delta = max ( half * delta , dnorm ) else delta = max ( half * delta , dnorm + dnorm ) end if if ( delta <= 1.5_wp * rho ) delta = rho ! !     Set KNEW to the index of the next interpolation point to be deleted. ! rhosq = max ( tenth * delta , rho ) ** 2 ktemp = 0 detrat = zero if ( f >= fsave ) then ktemp = kopt detrat = one end if do k = 1 , npt hdiag = zero do j = 1 , nptm temp = one if ( j < idz ) temp = - one hdiag = hdiag + temp * zmat ( k , j ) ** 2 end do temp = abs ( beta * hdiag + vlag ( k ) ** 2 ) distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( distsq > rhosq ) temp = temp * ( distsq / rhosq ) ** 3 if ( temp > detrat . and . k /= ktemp ) then detrat = temp knew = k end if end do if ( knew == 0 ) go to 460 ! !     Update BMAT, ZMAT and IDZ, so that the KNEW-th interpolation point !     can be moved. Begin the updating of the quadratic model, starting !     with the explicit second derivative term. ! 410 call update ( n , npt , bmat , zmat , idz , ndim , vlag , beta , knew , w ) fval ( knew ) = f ih = 0 do i = 1 , n temp = pq ( knew ) * xpt ( knew , i ) do j = 1 , i ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * xpt ( knew , j ) end do end do pq ( knew ) = zero ! !     Update the other second derivative parameters, and then the gradient !     vector of the model. Also include the new interpolation point. ! do j = 1 , nptm temp = diff * zmat ( knew , j ) if ( j < idz ) temp = - temp do k = 1 , npt pq ( k ) = pq ( k ) + temp * zmat ( k , j ) end do end do gqsq = zero do i = 1 , n gq ( i ) = gq ( i ) + diff * bmat ( knew , i ) gqsq = gqsq + gq ( i ) ** 2 xpt ( knew , i ) = xnew ( i ) end do ! !     If a trust region step makes a small change to the objective function, !     then calculate the gradient of the least Frobenius norm interpolant at !     XBASE, and store it in W, using VLAG for a vector of right hand sides. ! if ( ksave == 0 . and . delta == rho ) then if ( abs ( ratio ) > 1.0e-2_wp ) then itest = 0 else do k = 1 , npt vlag ( k ) = fval ( k ) - fval ( kopt ) end do gisq = zero do i = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , i ) * vlag ( k ) end do gisq = gisq + sum * sum w ( i ) = sum end do ! !     Test whether to replace the new quadratic model by the least Frobenius !     norm interpolant, making the replacement if the test is satisfied. ! itest = itest + 1 if ( gqsq < 10 0.0_wp * gisq ) itest = 0 if ( itest >= 3 ) then do i = 1 , n gq ( i ) = w ( i ) end do do ih = 1 , nh hq ( ih ) = zero end do do j = 1 , nptm w ( j ) = zero do k = 1 , npt w ( j ) = w ( j ) + vlag ( k ) * zmat ( k , j ) end do if ( j < idz ) w ( j ) = - w ( j ) end do do k = 1 , npt pq ( k ) = zero do j = 1 , nptm pq ( k ) = pq ( k ) + zmat ( k , j ) * w ( j ) end do end do itest = 0 end if end if end if if ( f < fsave ) kopt = knew ! !     If a trust region step has provided a sufficient decrease in F, then !     branch for another trust region calculation. The case KSAVE>0 occurs !     when the new function value was calculated by a model step. ! if ( f <= fsave + tenth * vquad ) go to 100 if ( ksave > 0 ) go to 100 ! !     Alternatively, find out if the interpolation points are close enough !     to the best point so far. ! knew = 0 460 distsq = 4.0_wp * delta * delta do k = 1 , npt sum = zero do j = 1 , n sum = sum + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( sum > distsq ) then knew = k distsq = sum end if end do ! !     If KNEW is positive, then set DSTEP, and branch back for the next !     iteration, which will generate a \"model step\". ! if ( knew > 0 ) then dstep = max ( min ( tenth * sqrt ( distsq ), half * delta ), rho ) dsq = dstep * dstep go to 120 end if if ( ratio > zero ) go to 100 if ( max ( delta , dnorm ) > rho ) go to 100 ! !     The calculations with the current value of RHO are complete. Pick the !     next values of RHO and DELTA. ! 490 if ( rho > rhoend ) then delta = half * rho ratio = rho / rhoend if ( ratio <= 1 6.0_wp ) then rho = rhoend else if ( ratio <= 25 0.0_wp ) then rho = sqrt ( ratio ) * rhoend else rho = tenth * rho end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) print 500 500 format ( 5 x ) print 510 , rho , nf 510 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 520 , fopt , ( xbase ( i ) + xopt ( i ), i = 1 , n ) 520 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if go to 90 end if ! !     Return from the calculation, after another Newton-Raphson step, if !     it is too short to have been tried before. ! if ( knew ==- 1 ) go to 290 530 if ( fopt <= f ) then do i = 1 , n x ( i ) = xbase ( i ) + xopt ( i ) end do f = fopt end if if ( iprint >= 1 ) then print 550 , nf 550 format ( / 4 x , 'At the return from NEWUOA' , 5 x ,& 'Number of function values =' , i6 ) print 520 , f , ( x ( i ), i = 1 , n ) end if end subroutine newuob subroutine bigden ( n , npt , xopt , xpt , bmat , zmat , idz , ndim , kopt , knew , d , w , vlag , & beta , s , wvec , prod ) implicit real ( wp ) ( a - h , o - z ) dimension xopt ( * ), xpt ( npt , * ), bmat ( ndim , * ), zmat ( npt , * ), d ( * ), w ( * ), vlag & ( * ), s ( * ), wvec ( ndim , * ), prod ( ndim , * ) dimension den ( 9 ), denex ( 9 ), par ( 9 ) ! !     N is the number of variables. !     NPT is the number of interpolation equations. !     XOPT is the best interpolation point so far. !     XPT contains the coordinates of the current interpolation points. !     BMAT provides the last N columns of H. !     ZMAT and IDZ give a factorization of the first NPT by NPT submatrix of H. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     KOPT is the index of the optimal interpolation point. !     KNEW is the index of the interpolation point that is going to be moved. !     D will be set to the step from XOPT to the new point, and on entry it !       should be the D that was calculated by the last call of BIGLAG. The !       length of the initial D provides a trust region bound on the final D. !     W will be set to Wcheck for the final choice of D. !     VLAG will be set to Theta*Wcheck+e_b for the final choice of D. !     BETA will be set to the value that will occur in the updating formula !       when the KNEW-th interpolation point is moved to its new position. !     S, WVEC, PROD and the private arrays DEN, DENEX and PAR will be used !       for working space. ! !     D is calculated in a way that should provide a denominator with a large !     modulus in the updating formula when the KNEW-th interpolation point is !     shifted to the new position XOPT+D. ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp quart = 0.25_wp two = 2.0_wp zero = 0.0_wp twopi = 8.0_wp * atan ( one ) nptm = npt - n - 1 ! !     Store the first NPT elements of the KNEW-th column of H in W(N+1) !     to W(N+NPT). ! do k = 1 , npt w ( n + k ) = zero end do do j = 1 , nptm temp = zmat ( knew , j ) if ( j < idz ) temp = - temp do k = 1 , npt w ( n + k ) = w ( n + k ) + temp * zmat ( k , j ) end do end do alpha = w ( n + knew ) ! !     The initial search direction D is taken from the last call of BIGLAG, !     and the initial S is set below, usually to the direction from X_OPT !     to X_KNEW, but a different direction to an interpolation point may !     be chosen, in order to prevent S from being nearly parallel to D. ! dd = zero ds = zero ss = zero xoptsq = zero do i = 1 , n dd = dd + d ( i ) ** 2 s ( i ) = xpt ( knew , i ) - xopt ( i ) ds = ds + d ( i ) * s ( i ) ss = ss + s ( i ) ** 2 xoptsq = xoptsq + xopt ( i ) ** 2 end do if ( ds * ds > 0.99_wp * dd * ss ) then ksav = knew dtest = ds * ds / ss do k = 1 , npt if ( k /= kopt ) then dstemp = zero sstemp = zero do i = 1 , n diff = xpt ( k , i ) - xopt ( i ) dstemp = dstemp + d ( i ) * diff sstemp = sstemp + diff * diff end do if ( dstemp * dstemp / sstemp < dtest ) then ksav = k dtest = dstemp * dstemp / sstemp ds = dstemp ss = sstemp end if end if end do do i = 1 , n s ( i ) = xpt ( ksav , i ) - xopt ( i ) end do end if ssden = dd * ss - ds * ds iterc = 0 densav = zero ! !     Begin the iteration by overwriting S with a vector that has the !     required length and direction. ! 70 iterc = iterc + 1 temp = one / sqrt ( ssden ) xoptd = zero xopts = zero do i = 1 , n s ( i ) = temp * ( dd * s ( i ) - ds * d ( i )) xoptd = xoptd + xopt ( i ) * d ( i ) xopts = xopts + xopt ( i ) * s ( i ) end do ! !     Set the coefficients of the first two terms of BETA. ! tempa = half * xoptd * xoptd tempb = half * xopts * xopts den ( 1 ) = dd * ( xoptsq + half * dd ) + tempa + tempb den ( 2 ) = two * xoptd * dd den ( 3 ) = two * xopts * dd den ( 4 ) = tempa - tempb den ( 5 ) = xoptd * xopts do i = 6 , 9 den ( i ) = zero end do ! !     Put the coefficients of Wcheck in WVEC. ! do k = 1 , npt tempa = zero tempb = zero tempc = zero do i = 1 , n tempa = tempa + xpt ( k , i ) * d ( i ) tempb = tempb + xpt ( k , i ) * s ( i ) tempc = tempc + xpt ( k , i ) * xopt ( i ) end do wvec ( k , 1 ) = quart * ( tempa * tempa + tempb * tempb ) wvec ( k , 2 ) = tempa * tempc wvec ( k , 3 ) = tempb * tempc wvec ( k , 4 ) = quart * ( tempa * tempa - tempb * tempb ) wvec ( k , 5 ) = half * tempa * tempb end do do i = 1 , n ip = i + npt wvec ( ip , 1 ) = zero wvec ( ip , 2 ) = d ( i ) wvec ( ip , 3 ) = s ( i ) wvec ( ip , 4 ) = zero wvec ( ip , 5 ) = zero end do ! !     Put the coefficents of THETA*Wcheck in PROD. ! do jc = 1 , 5 nw = npt if ( jc == 2 . or . jc == 3 ) nw = ndim do k = 1 , npt prod ( k , jc ) = zero end do do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * wvec ( k , jc ) end do if ( j < idz ) sum = - sum do k = 1 , npt prod ( k , jc ) = prod ( k , jc ) + sum * zmat ( k , j ) end do end do if ( nw == ndim ) then do k = 1 , npt sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * wvec ( npt + j , jc ) end do prod ( k , jc ) = prod ( k , jc ) + sum end do end if do j = 1 , n sum = zero do i = 1 , nw sum = sum + bmat ( i , j ) * wvec ( i , jc ) end do prod ( npt + j , jc ) = sum end do end do ! !     Include in DEN the part of BETA that depends on THETA. ! do k = 1 , ndim sum = zero do i = 1 , 5 par ( i ) = half * prod ( k , i ) * wvec ( k , i ) sum = sum + par ( i ) end do den ( 1 ) = den ( 1 ) - par ( 1 ) - sum tempa = prod ( k , 1 ) * wvec ( k , 2 ) + prod ( k , 2 ) * wvec ( k , 1 ) tempb = prod ( k , 2 ) * wvec ( k , 4 ) + prod ( k , 4 ) * wvec ( k , 2 ) tempc = prod ( k , 3 ) * wvec ( k , 5 ) + prod ( k , 5 ) * wvec ( k , 3 ) den ( 2 ) = den ( 2 ) - tempa - half * ( tempb + tempc ) den ( 6 ) = den ( 6 ) - half * ( tempb - tempc ) tempa = prod ( k , 1 ) * wvec ( k , 3 ) + prod ( k , 3 ) * wvec ( k , 1 ) tempb = prod ( k , 2 ) * wvec ( k , 5 ) + prod ( k , 5 ) * wvec ( k , 2 ) tempc = prod ( k , 3 ) * wvec ( k , 4 ) + prod ( k , 4 ) * wvec ( k , 3 ) den ( 3 ) = den ( 3 ) - tempa - half * ( tempb - tempc ) den ( 7 ) = den ( 7 ) - half * ( tempb + tempc ) tempa = prod ( k , 1 ) * wvec ( k , 4 ) + prod ( k , 4 ) * wvec ( k , 1 ) den ( 4 ) = den ( 4 ) - tempa - par ( 2 ) + par ( 3 ) tempa = prod ( k , 1 ) * wvec ( k , 5 ) + prod ( k , 5 ) * wvec ( k , 1 ) tempb = prod ( k , 2 ) * wvec ( k , 3 ) + prod ( k , 3 ) * wvec ( k , 2 ) den ( 5 ) = den ( 5 ) - tempa - half * tempb den ( 8 ) = den ( 8 ) - par ( 4 ) + par ( 5 ) tempa = prod ( k , 4 ) * wvec ( k , 5 ) + prod ( k , 5 ) * wvec ( k , 4 ) den ( 9 ) = den ( 9 ) - half * tempa end do ! !     Extend DEN so that it holds all the coefficients of DENOM. ! sum = zero do i = 1 , 5 par ( i ) = half * prod ( knew , i ) ** 2 sum = sum + par ( i ) end do denex ( 1 ) = alpha * den ( 1 ) + par ( 1 ) + sum tempa = two * prod ( knew , 1 ) * prod ( knew , 2 ) tempb = prod ( knew , 2 ) * prod ( knew , 4 ) tempc = prod ( knew , 3 ) * prod ( knew , 5 ) denex ( 2 ) = alpha * den ( 2 ) + tempa + tempb + tempc denex ( 6 ) = alpha * den ( 6 ) + tempb - tempc tempa = two * prod ( knew , 1 ) * prod ( knew , 3 ) tempb = prod ( knew , 2 ) * prod ( knew , 5 ) tempc = prod ( knew , 3 ) * prod ( knew , 4 ) denex ( 3 ) = alpha * den ( 3 ) + tempa + tempb - tempc denex ( 7 ) = alpha * den ( 7 ) + tempb + tempc tempa = two * prod ( knew , 1 ) * prod ( knew , 4 ) denex ( 4 ) = alpha * den ( 4 ) + tempa + par ( 2 ) - par ( 3 ) tempa = two * prod ( knew , 1 ) * prod ( knew , 5 ) denex ( 5 ) = alpha * den ( 5 ) + tempa + prod ( knew , 2 ) * prod ( knew , 3 ) denex ( 8 ) = alpha * den ( 8 ) + par ( 4 ) - par ( 5 ) denex ( 9 ) = alpha * den ( 9 ) + prod ( knew , 4 ) * prod ( knew , 5 ) ! !     Seek the value of the angle that maximizes the modulus of DENOM. ! sum = denex ( 1 ) + denex ( 2 ) + denex ( 4 ) + denex ( 6 ) + denex ( 8 ) denold = sum denmax = sum isave = 0 iu = 49 temp = twopi / real ( iu + 1 , wp ) par ( 1 ) = one do i = 1 , iu angle = real ( i , wp ) * temp par ( 2 ) = cos ( angle ) par ( 3 ) = sin ( angle ) do j = 4 , 8 , 2 par ( j ) = par ( 2 ) * par ( j - 2 ) - par ( 3 ) * par ( j - 1 ) par ( j + 1 ) = par ( 2 ) * par ( j - 1 ) + par ( 3 ) * par ( j - 2 ) end do sumold = sum sum = zero do j = 1 , 9 sum = sum + denex ( j ) * par ( j ) end do if ( abs ( sum ) > abs ( denmax )) then denmax = sum isave = i tempa = sumold else if ( i == isave + 1 ) then tempb = sum end if end do if ( isave == 0 ) tempa = sum if ( isave == iu ) tempb = denold step = zero if ( tempa /= tempb ) then tempa = tempa - denmax tempb = tempb - denmax step = half * ( tempa - tempb ) / ( tempa + tempb ) end if angle = temp * ( real ( isave , wp ) + step ) ! !     Calculate the new parameters of the denominator, the new VLAG vector !     and the new D. Then test for convergence. ! par ( 2 ) = cos ( angle ) par ( 3 ) = sin ( angle ) do j = 4 , 8 , 2 par ( j ) = par ( 2 ) * par ( j - 2 ) - par ( 3 ) * par ( j - 1 ) par ( j + 1 ) = par ( 2 ) * par ( j - 1 ) + par ( 3 ) * par ( j - 2 ) end do beta = zero denmax = zero do j = 1 , 9 beta = beta + den ( j ) * par ( j ) denmax = denmax + denex ( j ) * par ( j ) end do do k = 1 , ndim vlag ( k ) = zero do j = 1 , 5 vlag ( k ) = vlag ( k ) + prod ( k , j ) * par ( j ) end do end do tau = vlag ( knew ) dd = zero tempa = zero tempb = zero do i = 1 , n d ( i ) = par ( 2 ) * d ( i ) + par ( 3 ) * s ( i ) w ( i ) = xopt ( i ) + d ( i ) dd = dd + d ( i ) ** 2 tempa = tempa + d ( i ) * w ( i ) tempb = tempb + w ( i ) * w ( i ) end do if ( iterc >= n ) go to 340 if ( iterc > 1 ) densav = max ( densav , denold ) if ( abs ( denmax ) <= 1.1_wp * abs ( densav )) go to 340 densav = denmax ! !     Set S to half the gradient of the denominator with respect to D. !     Then branch for the next iteration. ! do i = 1 , n temp = tempa * xopt ( i ) + tempb * d ( i ) - vlag ( npt + i ) s ( i ) = tau * bmat ( knew , i ) + alpha * temp end do do k = 1 , npt sum = zero do j = 1 , n sum = sum + xpt ( k , j ) * w ( j ) end do temp = ( tau * w ( n + k ) - alpha * vlag ( k )) * sum do i = 1 , n s ( i ) = s ( i ) + temp * xpt ( k , i ) end do end do ss = zero ds = zero do i = 1 , n ss = ss + s ( i ) ** 2 ds = ds + d ( i ) * s ( i ) end do ssden = dd * ss - ds * ds if ( ssden >= 1.0e-8_wp * dd * ss ) go to 70 ! !     Set the vector W before the RETURN from the subroutine. ! 340 do k = 1 , ndim w ( k ) = zero do j = 1 , 5 w ( k ) = w ( k ) + wvec ( k , j ) * par ( j ) end do end do vlag ( kopt ) = vlag ( kopt ) + one end subroutine bigden subroutine biglag ( n , npt , xopt , xpt , bmat , zmat , idz , ndim , knew , delta , d , alpha , & hcol , gc , gd , s , w ) implicit real ( wp ) ( a - h , o - z ) dimension xopt ( * ), xpt ( npt , * ), bmat ( ndim , * ), zmat ( npt , * ), d ( * ), hcol ( * ), & gc ( * ), gd ( * ), s ( * ), w ( * ) ! !     N is the number of variables. !     NPT is the number of interpolation equations. !     XOPT is the best interpolation point so far. !     XPT contains the coordinates of the current interpolation points. !     BMAT provides the last N columns of H. !     ZMAT and IDZ give a factorization of the first NPT by NPT submatrix of H. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     KNEW is the index of the interpolation point that is going to be moved. !     DELTA is the current trust region bound. !     D will be set to the step from XOPT to the new point. !     ALPHA will be set to the KNEW-th diagonal element of the H matrix. !     HCOL, GC, GD, S and W will be used for working space. ! !     The step D is calculated in a way that attempts to maximize the modulus !     of LFUNC(XOPT+D), subject to the bound ||D|| .LE. DELTA, where LFUNC is !     the KNEW-th Lagrange function. ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp zero = 0.0_wp twopi = 8.0_wp * atan ( one ) delsq = delta * delta nptm = npt - n - 1 ! !     Set the first NPT components of HCOL to the leading elements of the !     KNEW-th column of H. ! iterc = 0 do k = 1 , npt hcol ( k ) = zero end do do j = 1 , nptm temp = zmat ( knew , j ) if ( j < idz ) temp = - temp do k = 1 , npt hcol ( k ) = hcol ( k ) + temp * zmat ( k , j ) end do end do alpha = hcol ( knew ) ! !     Set the unscaled initial direction D. Form the gradient of LFUNC at !     XOPT, and multiply D by the second derivative matrix of LFUNC. ! dd = zero do i = 1 , n d ( i ) = xpt ( knew , i ) - xopt ( i ) gc ( i ) = bmat ( knew , i ) gd ( i ) = zero dd = dd + d ( i ) ** 2 end do do k = 1 , npt temp = zero sum = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) sum = sum + xpt ( k , j ) * d ( j ) end do temp = hcol ( k ) * temp sum = hcol ( k ) * sum do i = 1 , n gc ( i ) = gc ( i ) + temp * xpt ( k , i ) gd ( i ) = gd ( i ) + sum * xpt ( k , i ) end do end do ! !     Scale D and GD, with a sign change if required. Set S to another !     vector in the initial two dimensional subspace. ! gg = zero sp = zero dhd = zero do i = 1 , n gg = gg + gc ( i ) ** 2 sp = sp + d ( i ) * gc ( i ) dhd = dhd + d ( i ) * gd ( i ) end do scale = delta / sqrt ( dd ) if ( sp * dhd < zero ) scale = - scale temp = zero if ( sp * sp > 0.99_wp * dd * gg ) temp = one tau = scale * ( abs ( sp ) + half * scale * abs ( dhd )) if ( gg * delsq < 0.01_wp * tau * tau ) temp = one do i = 1 , n d ( i ) = scale * d ( i ) gd ( i ) = scale * gd ( i ) s ( i ) = gc ( i ) + temp * gd ( i ) end do ! !     Begin the iteration by overwriting S with a vector that has the !     required length and direction, except that termination occurs if !     the given D and S are nearly parallel. ! 80 iterc = iterc + 1 dd = zero sp = zero ss = zero do i = 1 , n dd = dd + d ( i ) ** 2 sp = sp + d ( i ) * s ( i ) ss = ss + s ( i ) ** 2 end do temp = dd * ss - sp * sp if ( temp <= 1.0e-8_wp * dd * ss ) go to 160 denom = sqrt ( temp ) do i = 1 , n s ( i ) = ( dd * s ( i ) - sp * d ( i )) / denom w ( i ) = zero end do ! !     Calculate the coefficients of the objective function on the circle, !     beginning with the multiplication of S by the second derivative matrix. ! do k = 1 , npt sum = zero do j = 1 , n sum = sum + xpt ( k , j ) * s ( j ) end do sum = hcol ( k ) * sum do i = 1 , n w ( i ) = w ( i ) + sum * xpt ( k , i ) end do end do cf1 = zero cf2 = zero cf3 = zero cf4 = zero cf5 = zero do i = 1 , n cf1 = cf1 + s ( i ) * w ( i ) cf2 = cf2 + d ( i ) * gc ( i ) cf3 = cf3 + s ( i ) * gc ( i ) cf4 = cf4 + d ( i ) * gd ( i ) cf5 = cf5 + s ( i ) * gd ( i ) end do cf1 = half * cf1 cf4 = half * cf4 - cf1 ! !     Seek the value of the angle that maximizes the modulus of TAU. ! taubeg = cf1 + cf2 + cf4 taumax = taubeg tauold = taubeg isave = 0 iu = 49 temp = twopi / real ( iu + 1 , wp ) do i = 1 , iu angle = real ( i , wp ) * temp cth = cos ( angle ) sth = sin ( angle ) tau = cf1 + ( cf2 + cf4 * cth ) * cth + ( cf3 + cf5 * cth ) * sth if ( abs ( tau ) > abs ( taumax )) then taumax = tau isave = i tempa = tauold else if ( i == isave + 1 ) then tempb = tau end if tauold = tau end do if ( isave == 0 ) tempa = tau if ( isave == iu ) tempb = taubeg step = zero if ( tempa /= tempb ) then tempa = tempa - taumax tempb = tempb - taumax step = half * ( tempa - tempb ) / ( tempa + tempb ) end if angle = temp * ( real ( isave , wp ) + step ) ! !     Calculate the new D and GD. Then test for convergence. ! cth = cos ( angle ) sth = sin ( angle ) tau = cf1 + ( cf2 + cf4 * cth ) * cth + ( cf3 + cf5 * cth ) * sth do i = 1 , n d ( i ) = cth * d ( i ) + sth * s ( i ) gd ( i ) = cth * gd ( i ) + sth * w ( i ) s ( i ) = gc ( i ) + gd ( i ) end do if ( abs ( tau ) <= 1.1_wp * abs ( taubeg )) go to 160 if ( iterc < n ) go to 80 160 return end subroutine biglag subroutine trsapp ( n , npt , xopt , xpt , gq , hq , pq , delta , step , d , g , hd , hs , crvmin ) implicit real ( wp ) ( a - h , o - z ) dimension xopt ( * ), xpt ( npt , * ), gq ( * ), hq ( * ), pq ( * ), step ( * ), d ( * ), g ( * ), & hd ( * ), hs ( * ) ! !     N is the number of variables of a quadratic objective function, Q say. !     The arguments NPT, XOPT, XPT, GQ, HQ and PQ have their usual meanings, !       in order to define the current quadratic model Q. !     DELTA is the trust region radius, and has to be positive. !     STEP will be set to the calculated trial step. !     The arrays D, G, HD and HS will be used for working space. !     CRVMIN will be set to the least curvature of H along the conjugate !       directions that occur, except that it is set to zero if STEP goes !       all the way to the trust region boundary. ! !     The calculation of STEP begins with the truncated conjugate gradient !     method. If the boundary of the trust region is reached, then further !     changes to STEP may be made, each one being in the 2D space spanned !     by the current STEP and the corresponding gradient of Q. Thus STEP !     should provide a substantial reduction to Q within the trust region. ! !     Initialization, which includes setting HD to H times XOPT. ! half = 0.5_wp zero = 0.0_wp twopi = 8.0_wp * atan ( 1.0_wp ) delsq = delta * delta iterc = 0 itermax = n itersw = itermax do i = 1 , n d ( i ) = xopt ( i ) end do go to 170 ! !     Prepare for the first line search. ! 20 qred = zero dd = zero do i = 1 , n step ( i ) = zero hs ( i ) = zero g ( i ) = gq ( i ) + hd ( i ) d ( i ) = - g ( i ) dd = dd + d ( i ) ** 2 end do crvmin = zero if ( dd == zero ) go to 160 ds = zero ss = zero gg = dd ggbeg = gg ! !     Calculate the step to the trust region boundary and the product HD. ! 40 iterc = iterc + 1 temp = delsq - ss bstep = temp / ( ds + sqrt ( ds * ds + dd * temp )) go to 170 50 dhd = zero do j = 1 , n dhd = dhd + d ( j ) * hd ( j ) end do ! !     Update CRVMIN and set the step-length ALPHA. ! alpha = bstep if ( dhd > zero ) then temp = dhd / dd if ( iterc == 1 ) crvmin = temp crvmin = min ( crvmin , temp ) alpha = min ( alpha , gg / dhd ) end if qadd = alpha * ( gg - half * alpha * dhd ) qred = qred + qadd ! !     Update STEP and HS. ! ggsav = gg gg = zero do i = 1 , n step ( i ) = step ( i ) + alpha * d ( i ) hs ( i ) = hs ( i ) + alpha * hd ( i ) gg = gg + ( g ( i ) + hs ( i )) ** 2 end do ! !     Begin another conjugate direction iteration if required. ! if ( alpha < bstep ) then if ( qadd <= 0.01_wp * qred ) go to 160 if ( gg <= 1.0e-4_wp * ggbeg ) go to 160 if ( iterc == itermax ) go to 160 temp = gg / ggsav dd = zero ds = zero ss = zero do i = 1 , n d ( i ) = temp * d ( i ) - g ( i ) - hs ( i ) dd = dd + d ( i ) ** 2 ds = ds + d ( i ) * step ( i ) ss = ss + step ( i ) ** 2 end do if ( ds <= zero ) go to 160 if ( ss < delsq ) go to 40 end if crvmin = zero itersw = iterc ! !     Test whether an alternative iteration is required. ! 90 if ( gg <= 1.0e-4_wp * ggbeg ) go to 160 sg = zero shs = zero do i = 1 , n sg = sg + step ( i ) * g ( i ) shs = shs + step ( i ) * hs ( i ) end do sgk = sg + shs angtest = sgk / sqrt ( gg * delsq ) if ( angtest <=- 0.99_wp ) go to 160 ! !     Begin the alternative iteration by calculating D and HD and some !     scalar products. ! iterc = iterc + 1 temp = sqrt ( delsq * gg - sgk * sgk ) tempa = delsq / temp tempb = sgk / temp do i = 1 , n d ( i ) = tempa * ( g ( i ) + hs ( i )) - tempb * step ( i ) end do go to 170 120 dg = zero dhd = zero dhs = zero do i = 1 , n dg = dg + d ( i ) * g ( i ) dhd = dhd + hd ( i ) * d ( i ) dhs = dhs + hd ( i ) * step ( i ) end do ! !     Seek the value of the angle that minimizes Q. ! cf = half * ( shs - dhd ) qbeg = sg + cf qsav = qbeg qmin = qbeg isave = 0 iu = 49 temp = twopi / real ( iu + 1 , wp ) do i = 1 , iu angle = real ( i , wp ) * temp cth = cos ( angle ) sth = sin ( angle ) qnew = ( sg + cf * cth ) * cth + ( dg + dhs * cth ) * sth if ( qnew < qmin ) then qmin = qnew isave = i tempa = qsav else if ( i == isave + 1 ) then tempb = qnew end if qsav = qnew end do if ( isave == zero ) tempa = qnew if ( isave == iu ) tempb = qbeg angle = zero if ( tempa /= tempb ) then tempa = tempa - qmin tempb = tempb - qmin angle = half * ( tempa - tempb ) / ( tempa + tempb ) end if angle = temp * ( real ( isave , wp ) + angle ) ! !     Calculate the new STEP and HS. Then test for convergence. ! cth = cos ( angle ) sth = sin ( angle ) reduc = qbeg - ( sg + cf * cth ) * cth - ( dg + dhs * cth ) * sth gg = zero do i = 1 , n step ( i ) = cth * step ( i ) + sth * d ( i ) hs ( i ) = cth * hs ( i ) + sth * hd ( i ) gg = gg + ( g ( i ) + hs ( i )) ** 2 end do qred = qred + reduc ratio = reduc / qred if ( iterc < itermax . and . ratio > 0.01_wp ) go to 90 160 return ! !     The following instructions act as a subroutine for setting the vector !     HD to the vector D multiplied by the second derivative matrix of Q. !     They are called from three different places, which are distinguished !     by the value of ITERC. ! 170 do i = 1 , n hd ( i ) = zero end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * d ( j ) end do temp = temp * pq ( k ) do i = 1 , n hd ( i ) = hd ( i ) + temp * xpt ( k , i ) end do end do ih = 0 do j = 1 , n do i = 1 , j ih = ih + 1 if ( i < j ) hd ( j ) = hd ( j ) + hq ( ih ) * d ( i ) hd ( i ) = hd ( i ) + hq ( ih ) * d ( j ) end do end do if ( iterc == 0 ) go to 20 if ( iterc <= itersw ) go to 50 go to 120 end subroutine trsapp subroutine update ( n , npt , bmat , zmat , idz , ndim , vlag , beta , knew , w ) implicit real ( wp ) ( a - h , o - z ) dimension bmat ( ndim , * ), zmat ( npt , * ), vlag ( * ), w ( * ) ! !     The arrays BMAT and ZMAT with IDZ are updated, in order to shift the !     interpolation point that has index KNEW. On entry, VLAG contains the !     components of the vector Theta*Wcheck+e_b of the updating formula !     (6.11), and BETA holds the value of the parameter that has this name. !     The vector W is used for working space. ! !     Set some constants. ! one = 1.0_wp zero = 0.0_wp nptm = npt - n - 1 ! !     Apply the rotations that put zeros in the KNEW-th row of ZMAT. ! jl = 1 do j = 2 , nptm if ( j == idz ) then jl = idz else if ( zmat ( knew , j ) /= zero ) then temp = sqrt ( zmat ( knew , jl ) ** 2 + zmat ( knew , j ) ** 2 ) tempa = zmat ( knew , jl ) / temp tempb = zmat ( knew , j ) / temp do i = 1 , npt temp = tempa * zmat ( i , jl ) + tempb * zmat ( i , j ) zmat ( i , j ) = tempa * zmat ( i , j ) - tempb * zmat ( i , jl ) zmat ( i , jl ) = temp end do zmat ( knew , j ) = zero end if end do ! !     Put the first NPT components of the KNEW-th column of HLAG into W, !     and calculate the parameters of the updating formula. ! tempa = zmat ( knew , 1 ) if ( idz >= 2 ) tempa = - tempa if ( jl > 1 ) tempb = zmat ( knew , jl ) do i = 1 , npt w ( i ) = tempa * zmat ( i , 1 ) if ( jl > 1 ) w ( i ) = w ( i ) + tempb * zmat ( i , jl ) end do alpha = w ( knew ) tau = vlag ( knew ) tausq = tau * tau denom = alpha * beta + tausq vlag ( knew ) = vlag ( knew ) - one ! !     Complete the updating of ZMAT when there is only one nonzero element !     in the KNEW-th row of the new matrix ZMAT, but, if IFLAG is set to one, !     then the first column of ZMAT will be exchanged with another one later. ! iflag = 0 if ( jl == 1 ) then temp = sqrt ( abs ( denom )) tempb = tempa / temp tempa = tau / temp do i = 1 , npt zmat ( i , 1 ) = tempa * zmat ( i , 1 ) - tempb * vlag ( i ) end do if ( idz == 1 . and . temp < zero ) idz = 2 if ( idz >= 2 . and . temp >= zero ) iflag = 1 else ! !     Complete the updating of ZMAT in the alternative case. ! ja = 1 if ( beta >= zero ) ja = jl jb = jl + 1 - ja temp = zmat ( knew , jb ) / denom tempa = temp * beta tempb = temp * tau temp = zmat ( knew , ja ) scala = one / sqrt ( abs ( beta ) * temp * temp + tausq ) scalb = scala * sqrt ( abs ( denom )) do i = 1 , npt zmat ( i , ja ) = scala * ( tau * zmat ( i , ja ) - temp * vlag ( i )) zmat ( i , jb ) = scalb * ( zmat ( i , jb ) - tempa * w ( i ) - tempb * vlag ( i )) end do if ( denom <= zero ) then if ( beta < zero ) idz = idz + 1 if ( beta >= zero ) iflag = 1 end if end if ! !     IDZ is reduced in the following case, and usually the first column !     of ZMAT is exchanged with a later one. ! if ( iflag == 1 ) then idz = idz - 1 do i = 1 , npt temp = zmat ( i , 1 ) zmat ( i , 1 ) = zmat ( i , idz ) zmat ( i , idz ) = temp end do end if ! !     Finally, update the matrix BMAT. ! do j = 1 , n jp = npt + j w ( jp ) = bmat ( knew , j ) tempa = ( alpha * vlag ( jp ) - tau * w ( jp )) / denom tempb = ( - beta * w ( jp ) - tau * vlag ( jp )) / denom do i = 1 , jp bmat ( i , j ) = bmat ( i , j ) + tempa * vlag ( i ) + tempb * w ( i ) if ( i > npt ) bmat ( jp , i - npt ) = bmat ( i , j ) end do end do end subroutine update !***************************************************************************************** !> !  The Chebyquad test problem (Fletcher, 1965) for N = 2,4,6 and 8, !  with NPT = 2N+1. subroutine newuoa_test () implicit none real ( wp ) :: x ( 10 ) integer :: iprint , maxfun , n , npt , i real ( wp ) :: rhoend , rhobeg iprint = 2 maxfun = 5000 rhoend = 1.0e-6_wp do n = 2 , 8 , 2 npt = 2 * n + 1 do i = 1 , n x ( i ) = real ( i , wp ) / real ( n + 1 , wp ) end do rhobeg = 0.2_wp * x ( 1 ) print 20 , n , npt 20 format ( / / 4 x , 'Results with N =' , i2 , ' and NPT =' , i3 ) call newuoa ( n , npt , x , rhobeg , rhoend , iprint , maxfun , calfun ) end do contains subroutine calfun ( n , x , f ) implicit none integer :: n real ( wp ) :: x ( * ) real ( wp ) :: f real ( wp ) :: y ( 10 , 10 ) integer :: i , j , np , iw real ( wp ) :: sum do j = 1 , n y ( 1 , j ) = 1.0_wp y ( 2 , j ) = 2.0_wp * x ( j ) - 1.0_wp end do do i = 2 , n do j = 1 , n y ( i + 1 , j ) = 2.0_wp * y ( 2 , j ) * y ( i , j ) - y ( i - 1 , j ) end do end do f = 0.0_wp np = n + 1 iw = 1 do i = 1 , np sum = 0.0_wp do j = 1 , n sum = sum + y ( i , j ) end do sum = sum / real ( n , wp ) if ( iw > 0 ) sum = sum + 1.0_wp / real ( i * i - 2 * i , wp ) iw = - iw f = f + sum * sum end do end subroutine calfun end subroutine newuoa_test !***************************************************************************************** end module newuoa_module","tags":"","loc":"sourcefile/newuoa.f90.html"},{"title":"cobyla.f90 – PowellOpt","text":"This file depends on sourcefile~~cobyla.f90~~EfferentGraph sourcefile~cobyla.f90 cobyla.f90 sourcefile~kind_module.f90 kind_module.f90 sourcefile~cobyla.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~cobyla.f90~~AfferentGraph sourcefile~cobyla.f90 cobyla.f90 sourcefile~powellopt.f90 powellopt.f90 sourcefile~powellopt.f90->sourcefile~cobyla.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  COBYLA: **C**onstrained **O**ptimization **BY** **L**inear **A**pproximations. ! !  Minimize an objective function F([X1,X2,...,XN]) subject to M inequality constraints. ! !# References !  * \"[A direct search optimization method that models the objective and constraint !    functions by linear interpolation](http://link.springer.com/chapter/10.1007/978-94-015-8330-5_4)\", !    *Advances in Optimization and Numerical Analysis* !    (eds. Susana Gomez and Jean-Pierre Hennart), Kluwer Academic Publishers (1994). ! !# History !  * Mike Powell (May 7th, 1992) -- There are no restrictions on the use of the !    software, nor do I offer any guarantees of success. !  * Jacob Williams, July 2015 : refactoring of the code into modern Fortran. ! !@note There is a need for a linear programming problem to be solved subject to a !      Euclidean norm trust region constraint. Therefore SUBROUTINE TRSTLP is provided, !      but you may have some software that you prefer to use instead. module cobyla_module use kind_module , only : wp private abstract interface subroutine func ( n , m , x , f , con ) !! calcfc interface import :: wp implicit none integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( * ), intent ( in ) :: x real ( wp ), intent ( out ) :: f real ( wp ), dimension ( * ), intent ( out ) :: con end subroutine func end interface public :: cobyla public :: cobyla_test contains !***************************************************************************************** !> !  This subroutine minimizes an objective function F(X) subject to M !  inequality constraints on X, where X is a vector of variables that has !  N components. The algorithm employs linear approximations to the !  objective and constraint functions, the approximations being formed by !  linear interpolation at N+1 points in the space of the variables. !  We regard these interpolation points as vertices of a simplex. The !  parameter RHO controls the size of the simplex and it is reduced !  automatically from RHOBEG to RHOEND. For each RHO the subroutine tries !  to achieve a good vector of variables for the current size, and then !  RHO is reduced until the value RHOEND is reached. Therefore RHOBEG and !  RHOEND should be set to reasonable initial changes to and the required !  accuracy in the variables respectively, but this accuracy should be !  viewed as a subject for experimentation because it is not guaranteed. ! !  The subroutine has an advantage over many of its competitors, however, !  which is that it treats each constraint individually when calculating !  a change to the variables, instead of lumping the constraints together !  into a single penalty function. subroutine cobyla ( n , m , x , rhobeg , rhoend , iprint , maxfun , calcfc ) implicit none integer , intent ( in ) :: n !! number of variables integer , intent ( in ) :: m !! number of inequality constraints real ( wp ), dimension ( * ), intent ( inout ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). !! On return they will be changed to the solution. real ( wp ), intent ( in ) :: rhobeg !! reasonable initial change to variables (see description of RHO) real ( wp ), intent ( in ) :: rhoend !! required accuracy (see description of RHO) integer , intent ( in ) :: iprint !! IPRINT should be set to 0, 1, 2 or 3, which controls the amount of !! printing during the calculation. Specifically, there is no output if !! IPRINT=0 and there is output only at the end of the calculation if !! IPRINT=1. Otherwise each new value of RHO and SIGMA is printed. !! Further, the vector of variables and some function information are !! given either when RHO is reduced or when each new value of F(X) is !! computed in the cases IPRINT=2 or IPRINT=3 respectively. Here SIGMA !! is a penalty parameter, it being assumed that a change to X is an !! improvement if it reduces the merit function !!     F(X)+SIGMA*MAX(0.0,-C1(X),-C2(X),...,-CM(X)), !! where C1,C2,...,CM denote the constraint functions that should become !! nonnegative eventually, at least to the precision of RHOEND. In the !! printed output the displayed term that is multiplied by SIGMA is !! called MAXCV, which stands for 'MAXimum Constraint Violation'. integer , intent ( inout ) :: maxfun !! MAXFUN is an integer variable that must be set by the user to a !! limit on the number of calls of CALCFC. !! The value of MAXFUN will be altered to the number of calls !! of CALCFC that are made. procedure ( func ) :: calcfc !! In order to define the objective and constraint functions, we require !! a subroutine that has the name and arguments !!     SUBROUTINE CALCFC (N,M,X,F,CON) !!     DIMENSION X(*),CON(*) !! The values of N and M are fixed and have been defined already, while !! X is now the current vector of variables. The subroutine should return !! the objective and constraint functions at X in F and CON(1),CON(2), !! ...,CON(M). Note that we are trying to adjust X so that F(X) is as !! small as possible subject to the constraint functions being nonnegative. integer , dimension (:), allocatable :: iact real ( wp ), dimension (:), allocatable :: w integer :: mpp , icon , isim , isimi , idatm , ia , ivsig , iveta , isigb , idx , iwork !W and IACT provide real and integer arrays that are used as working space. allocate ( w ( N * ( 3 * N + 2 * M + 11 ) + 4 * M + 6 )) allocate ( iact ( M + 1 )) ! Partition the working space array W to provide the storage that is needed ! for the main calculation. mpp = m + 2 icon = 1 isim = icon + mpp isimi = isim + n * n + n idatm = isimi + n * n ia = idatm + n * mpp + mpp ivsig = ia + m * n + n iveta = ivsig + n isigb = iveta + n idx = isigb + n iwork = idx + n call cobylb ( n , m , mpp , x , rhobeg , rhoend , iprint , maxfun , w ( icon ), w ( isim ), & w ( isimi ), w ( idatm ), w ( ia ), w ( ivsig ), w ( iveta ), w ( isigb ), w ( idx ), & w ( iwork ), iact , calcfc ) deallocate ( iact ) deallocate ( w ) end subroutine cobyla !***************************************************************************************** subroutine cobylb ( n , m , mpp , x , rhobeg , rhoend , iprint , maxfun , con , sim , simi , & datmat , a , vsig , veta , sigbar , dx , w , iact , calcfc ) implicit real ( wp ) ( a - h , o - z ) dimension x ( * ), con ( * ), sim ( n , * ), simi ( n , * ), datmat ( mpp , * ), a ( n , * ), vsig ( * ),& veta ( * ), sigbar ( * ), dx ( * ), w ( * ), iact ( * ) procedure ( func ) :: calcfc ! !     Set the initial values of some parameters. The last column of SIM holds !     the optimal vertex of the current simplex, and the preceding N columns !     hold the displacements from the optimal vertex to the other vertices. !     Further, SIMI holds the inverse of the matrix that is contained in the !     first N columns of SIM. ! iptem = min ( n , 5 ) iptemp = iptem + 1 np = n + 1 mp = m + 1 alpha = 0.25_wp beta = 2.1_wp gamma = 0.5_wp delta = 1.1_wp rho = rhobeg parmu = 0.0_wp if ( iprint >= 2 ) print 10 , rho 10 format ( / 3 x , 'The initial value of RHO is' , 1 pe13 . 6 , 2 x ,& 'and PARMU is set to zero.' ) nfvals = 0 temp = 1.0_wp / rho do i = 1 , n sim ( i , np ) = x ( i ) do j = 1 , n sim ( i , j ) = 0.0_wp simi ( i , j ) = 0.0_wp end do sim ( i , i ) = rho simi ( i , i ) = temp end do jdrop = np ibrnch = 0 ! !     Make the next call of the user-supplied subroutine CALCFC. These !     instructions are also used for calling CALCFC during the iterations of !     the algorithm. ! 40 if ( nfvals >= maxfun . and . nfvals > 0 ) then if ( iprint >= 1 ) print 50 50 format ( / 3 x , 'Return from subroutine COBYLA because the ' ,& 'MAXFUN limit has been reached.' ) go to 600 end if nfvals = nfvals + 1 call calcfc ( n , m , x , f , con ) resmax = 0.0_wp if ( m > 0 ) then do k = 1 , m resmax = max ( resmax , - con ( k )) end do end if if ( nfvals == iprint - 1 . or . iprint == 3 ) then print 70 , nfvals , f , resmax , ( x ( i ), i = 1 , iptem ) 70 format ( / 3 x , 'NFVALS =' , i5 , 3 x , 'F =' , 1 pe13 . 6 , 4 x , 'MAXCV =' , 1 pe13 . 6 & & / 3 x , 'X =' , 1 pe13 . 6 , 1 p4e15 . 6 ) if ( iptem < n ) print 80 , ( x ( i ), i = iptemp , n ) 80 format ( 1 pe19 . 6 , 1 p4e15 . 6 ) end if con ( mp ) = f con ( mpp ) = resmax if ( ibrnch == 1 ) go to 440 ! !     Set the recently calculated function values in a column of DATMAT. This !     array has a column for each vertex of the current simplex, the entries of !     each column being the values of the constraint functions (if any) !     followed by the objective function and the greatest constraint violation !     at the vertex. ! do k = 1 , mpp datmat ( k , jdrop ) = con ( k ) end do if ( nfvals > np ) go to 130 ! !     Exchange the new vertex of the initial simplex with the optimal vertex if !     necessary. Then, if the initial simplex is not complete, pick its next !     vertex and calculate the function values there. ! if ( jdrop <= n ) then if ( datmat ( mp , np ) <= f ) then x ( jdrop ) = sim ( jdrop , np ) else sim ( jdrop , np ) = x ( jdrop ) do k = 1 , mpp datmat ( k , jdrop ) = datmat ( k , np ) datmat ( k , np ) = con ( k ) end do do k = 1 , jdrop sim ( jdrop , k ) = - rho temp = 0.0_wp do i = k , jdrop temp = temp - simi ( i , k ) end do simi ( jdrop , k ) = temp end do end if end if if ( nfvals <= n ) then jdrop = nfvals x ( jdrop ) = x ( jdrop ) + rho go to 40 end if 130 ibrnch = 1 ! !     Identify the optimal vertex of the current simplex. ! 140 phimin = datmat ( mp , np ) + parmu * datmat ( mpp , np ) nbest = np do j = 1 , n temp = datmat ( mp , j ) + parmu * datmat ( mpp , j ) if ( temp < phimin ) then nbest = j phimin = temp else if ( temp == phimin . and . parmu == 0.0_wp ) then if ( datmat ( mpp , j ) < datmat ( mpp , nbest )) nbest = j end if end do ! !     Switch the best vertex into pole position if it is not there already, !     and also update SIM, SIMI and DATMAT. ! if ( nbest <= n ) then do i = 1 , mpp temp = datmat ( i , np ) datmat ( i , np ) = datmat ( i , nbest ) datmat ( i , nbest ) = temp end do do i = 1 , n temp = sim ( i , nbest ) sim ( i , nbest ) = 0.0_wp sim ( i , np ) = sim ( i , np ) + temp tempa = 0.0_wp do k = 1 , n sim ( i , k ) = sim ( i , k ) - temp tempa = tempa - simi ( k , i ) end do simi ( nbest , i ) = tempa end do end if ! !     Make an error return if SIGI is a poor approximation to the inverse of !     the leading N by N submatrix of SIG. ! error = 0.0_wp do i = 1 , n do j = 1 , n temp = 0.0_wp if ( i == j ) temp = temp - 1.0_wp do k = 1 , n temp = temp + simi ( i , k ) * sim ( k , j ) end do error = max ( error , abs ( temp )) end do end do if ( error > 0.1_wp ) then if ( iprint >= 1 ) print 210 210 format ( / 3 x , 'Return from subroutine COBYLA because ' ,& 'rounding errors are becoming damaging.' ) go to 600 end if ! !     Calculate the coefficients of the linear approximations to the objective !     and constraint functions, placing minus the objective function gradient !     after the constraint gradients in the array A. The vector W is used for !     working space. ! do k = 1 , mp con ( k ) = - datmat ( k , np ) do j = 1 , n w ( j ) = datmat ( k , j ) + con ( k ) end do do i = 1 , n temp = 0.0_wp do j = 1 , n temp = temp + w ( j ) * simi ( j , i ) end do if ( k == mp ) temp = - temp a ( i , k ) = temp end do end do ! !     Calculate the values of sigma and eta, and set IFLAG=0 if the current !     simplex is not acceptable. ! iflag = 1 parsig = alpha * rho pareta = beta * rho do j = 1 , n wsig = 0.0_wp weta = 0.0_wp do i = 1 , n wsig = wsig + simi ( j , i ) ** 2 weta = weta + sim ( i , j ) ** 2 end do vsig ( j ) = 1.0_wp / sqrt ( wsig ) veta ( j ) = sqrt ( weta ) if ( vsig ( j ) < parsig . or . veta ( j ) > pareta ) iflag = 0 end do ! !     If a new vertex is needed to improve acceptability, then decide which !     vertex to drop from the simplex. ! if ( ibrnch == 1 . or . iflag == 1 ) go to 370 jdrop = 0 temp = pareta do j = 1 , n if ( veta ( j ) > temp ) then jdrop = j temp = veta ( j ) end if end do if ( jdrop == 0 ) then do j = 1 , n if ( vsig ( j ) < temp ) then jdrop = j temp = vsig ( j ) end if end do end if ! !     Calculate the step to the new vertex and its sign. ! temp = gamma * rho * vsig ( jdrop ) do i = 1 , n dx ( i ) = temp * simi ( jdrop , i ) end do cvmaxp = 0.0_wp cvmaxm = 0.0_wp do k = 1 , mp sum = 0.0_wp do i = 1 , n sum = sum + a ( i , k ) * dx ( i ) end do if ( k < mp ) then temp = datmat ( k , np ) cvmaxp = max ( cvmaxp , - sum - temp ) cvmaxm = max ( cvmaxm , sum - temp ) end if end do dxsign = 1.0_wp if ( parmu * ( cvmaxp - cvmaxm ) > sum + sum ) dxsign = - 1.0_wp ! !     Update the elements of SIM and SIMI, and set the next X. ! temp = 0.0_wp do i = 1 , n dx ( i ) = dxsign * dx ( i ) sim ( i , jdrop ) = dx ( i ) temp = temp + simi ( jdrop , i ) * dx ( i ) end do do i = 1 , n simi ( jdrop , i ) = simi ( jdrop , i ) / temp end do do j = 1 , n if ( j /= jdrop ) then temp = 0.0_wp do i = 1 , n temp = temp + simi ( j , i ) * dx ( i ) end do do i = 1 , n simi ( j , i ) = simi ( j , i ) - temp * simi ( jdrop , i ) end do end if x ( j ) = sim ( j , np ) + dx ( j ) end do go to 40 ! !     Calculate DX=x(*)-x(0). Branch if the length of DX is less than 0.5*RHO. ! 370 iz = 1 izdota = iz + n * n ivmc = izdota + n isdirn = ivmc + mp idxnew = isdirn + n ivmd = idxnew + n call trstlp ( n , m , a , con , rho , dx , ifull , iact , w ( iz ), w ( izdota ), w ( ivmc ), & & w ( isdirn ), w ( idxnew ), w ( ivmd )) if ( ifull == 0 ) then temp = 0.0_wp do i = 1 , n temp = temp + dx ( i ) ** 2 end do if ( temp < 0.25_wp * rho * rho ) then ibrnch = 1 go to 550 end if end if ! !     Predict the change to F and the new maximum constraint violation if the !     variables are altered from x(0) to x(0)+DX. ! resnew = 0.0_wp con ( mp ) = 0.0_wp do k = 1 , mp sum = con ( k ) do i = 1 , n sum = sum - a ( i , k ) * dx ( i ) end do if ( k < mp ) resnew = max ( resnew , sum ) end do ! !     Increase PARMU if necessary and branch back if this change alters the !     optimal vertex. Otherwise PREREM and PREREC will be set to the predicted !     reductions in the merit function and the maximum constraint violation !     respectively. ! barmu = 0.0_wp prerec = datmat ( mpp , np ) - resnew if ( prerec > 0.0_wp ) barmu = sum / prerec if ( parmu < 1.5_wp * barmu ) then parmu = 2.0_wp * barmu if ( iprint >= 2 ) print 410 , parmu 410 format ( / 3 x , 'Increase in PARMU to' , 1 pe13 . 6 ) phi = datmat ( mp , np ) + parmu * datmat ( mpp , np ) do j = 1 , n temp = datmat ( mp , j ) + parmu * datmat ( mpp , j ) if ( temp < phi ) go to 140 if ( temp == phi . and . parmu == 0.0_wp ) then if ( datmat ( mpp , j ) < datmat ( mpp , np )) go to 140 end if end do end if prerem = parmu * prerec - sum ! !     Calculate the constraint and objective functions at x(*). Then find the !     actual reduction in the merit function. ! do i = 1 , n x ( i ) = sim ( i , np ) + dx ( i ) end do ibrnch = 1 go to 40 440 vmold = datmat ( mp , np ) + parmu * datmat ( mpp , np ) vmnew = f + parmu * resmax trured = vmold - vmnew if ( parmu == 0.0_wp . and . f == datmat ( mp , np )) then prerem = prerec trured = datmat ( mpp , np ) - resmax end if ! !     Begin the operations that decide whether x(*) should replace one of the !     vertices of the current simplex, the change being mandatory if TRURED is !     positive. Firstly, JDROP is set to the index of the vertex that is to be !     replaced. ! ratio = 0.0_wp if ( trured <= 0.0_wp ) ratio = 1.0_wp jdrop = 0 do j = 1 , n temp = 0.0_wp do i = 1 , n temp = temp + simi ( j , i ) * dx ( i ) end do temp = abs ( temp ) if ( temp > ratio ) then jdrop = j ratio = temp end if sigbar ( j ) = temp * vsig ( j ) end do ! !     Calculate the value of ell. ! edgmax = delta * rho l = 0 do j = 1 , n if ( sigbar ( j ) >= parsig . or . sigbar ( j ) >= vsig ( j )) then temp = veta ( j ) if ( trured > 0.0_wp ) then temp = 0.0_wp do i = 1 , n temp = temp + ( dx ( i ) - sim ( i , j )) ** 2 end do temp = sqrt ( temp ) end if if ( temp > edgmax ) then l = j edgmax = temp end if end if end do if ( l > 0 ) jdrop = l if ( jdrop == 0 ) go to 550 ! !     Revise the simplex by updating the elements of SIM, SIMI and DATMAT. ! temp = 0.0_wp do i = 1 , n sim ( i , jdrop ) = dx ( i ) temp = temp + simi ( jdrop , i ) * dx ( i ) end do do i = 1 , n simi ( jdrop , i ) = simi ( jdrop , i ) / temp end do do j = 1 , n if ( j /= jdrop ) then temp = 0.0_wp do i = 1 , n temp = temp + simi ( j , i ) * dx ( i ) end do do i = 1 , n simi ( j , i ) = simi ( j , i ) - temp * simi ( jdrop , i ) end do end if end do do k = 1 , mpp datmat ( k , jdrop ) = con ( k ) end do ! !     Branch back for further iterations with the current RHO. ! if ( trured > 0.0_wp . and . trured >= 0.1_wp * prerem ) go to 140 550 if ( iflag == 0 ) then ibrnch = 0 go to 140 end if ! !     Otherwise reduce RHO if it is not at its least value and reset PARMU. ! if ( rho > rhoend ) then rho = 0.5_wp * rho if ( rho <= 1.5_wp * rhoend ) rho = rhoend if ( parmu > 0.0_wp ) then denom = 0.0_wp do k = 1 , mp cmin = datmat ( k , np ) cmax = cmin do i = 1 , n cmin = min ( cmin , datmat ( k , i )) cmax = max ( cmax , datmat ( k , i )) end do if ( k <= m . and . cmin < 0.5_wp * cmax ) then temp = max ( cmax , 0.0_wp ) - cmin if ( denom <= 0.0_wp ) then denom = temp else denom = min ( denom , temp ) end if end if end do if ( denom == 0.0_wp ) then parmu = 0.0_wp else if ( cmax - cmin < parmu * denom ) then parmu = ( cmax - cmin ) / denom end if end if if ( iprint >= 2 ) print 580 , rho , parmu 580 format ( / 3 x , 'Reduction in RHO to' , 1 pe13 . 6 , '  and PARMU =' , 1 pe13 . 6 ) if ( iprint == 2 ) then print 70 , nfvals , datmat ( mp , np ), datmat ( mpp , np ), ( sim ( i , np ), i = 1 , & & iptem ) if ( iptem < n ) print 80 , ( x ( i ), i = iptemp , n ) end if go to 140 end if ! !     Return the best calculated values of the variables. ! if ( iprint >= 1 ) print 590 590 format ( / 3 x , 'Normal return from subroutine COBYLA' ) if ( ifull == 1 ) go to 620 600 do i = 1 , n x ( i ) = sim ( i , np ) end do f = datmat ( mp , np ) resmax = datmat ( mpp , np ) 620 if ( iprint >= 1 ) then print 70 , nfvals , f , resmax , ( x ( i ), i = 1 , iptem ) if ( iptem < n ) print 80 , ( x ( i ), i = iptemp , n ) end if maxfun = nfvals end subroutine cobylb subroutine trstlp ( n , m , a , b , rho , dx , ifull , iact , z , zdota , vmultc , sdirn , dxnew , & vmultd ) implicit real ( wp ) ( a - h , o - z ) dimension a ( n , * ), b ( * ), dx ( * ), iact ( * ), z ( n , * ), zdota ( * ), vmultc ( * ), & sdirn ( * ), dxnew ( * ), vmultd ( * ) ! !     This subroutine calculates an N-component vector DX by applying the !     following two stages. In the first stage, DX is set to the shortest !     vector that minimizes the greatest violation of the constraints !       A(1,K)*DX(1)+A(2,K)*DX(2)+...+A(N,K)*DX(N) .GE. B(K), K=2,3,...,M, !     subject to the Euclidean length of DX being at most RHO. If its length is !     strictly less than RHO, then we use the resultant freedom in DX to !     minimize the objective function !              -A(1,M+1)*DX(1)-A(2,M+1)*DX(2)-...-A(N,M+1)*DX(N) !     subject to no increase in any greatest constraint violation. This !     notation allows the gradient of the objective function to be regarded as !     the gradient of a constraint. Therefore the two stages are distinguished !     by MCON .EQ. M and MCON .GT. M respectively. It is possible that a !     degeneracy may prevent DX from attaining the target length RHO. Then the !     value IFULL=0 would be set, but usually IFULL=1 on return. ! !     In general NACT is the number of constraints in the active set and !     IACT(1),...,IACT(NACT) are their indices, while the remainder of IACT !     contains a permutation of the remaining constraint indices. Further, Z is !     an orthogonal matrix whose first NACT columns can be regarded as the !     result of Gram-Schmidt applied to the active constraint gradients. For !     J=1,2,...,NACT, the number ZDOTA(J) is the scalar product of the J-th !     column of Z with the gradient of the J-th active constraint. DX is the !     current vector of variables and here the residuals of the active !     constraints should be zero. Further, the active constraints have !     nonnegative Lagrange multipliers that are held at the beginning of !     VMULTC. The remainder of this vector holds the residuals of the inactive !     constraints at DX, the ordering of the components of VMULTC being in !     agreement with the permutation of the indices of the constraints that is !     in IACT. All these residuals are nonnegative, which is achieved by the !     shift RESMAX that makes the least residual zero. ! !     Initialize Z and some other variables. The value of RESMAX will be !     appropriate to DX=0, while ICON will be the index of a most violated !     constraint if RESMAX is positive. Usually during the first stage the !     vector SDIRN gives a search direction that reduces all the active !     constraint violations by one simultaneously. ! ifull = 1 mcon = m nact = 0 resmax = 0.0_wp do i = 1 , n do j = 1 , n z ( i , j ) = 0.0_wp end do z ( i , i ) = 1.0_wp dx ( i ) = 0.0_wp end do if ( m >= 1 ) then do k = 1 , m if ( b ( k ) > resmax ) then resmax = b ( k ) icon = k end if end do do k = 1 , m iact ( k ) = k vmultc ( k ) = resmax - b ( k ) end do end if if ( resmax == 0.0_wp ) go to 480 do i = 1 , n sdirn ( i ) = 0.0_wp end do ! !     End the current stage of the calculation if 3 consecutive iterations !     have either failed to reduce the best calculated value of the objective !     function or to increase the number of active constraints since the best !     value was calculated. This strategy prevents cycling, but there is a !     remote possibility that it will cause premature termination. ! 60 optold = 0.0_wp icount = 0 70 if ( mcon == m ) then optnew = resmax else optnew = 0.0_wp do i = 1 , n optnew = optnew - dx ( i ) * a ( i , mcon ) end do end if if ( icount == 0 . or . optnew < optold ) then optold = optnew nactx = nact icount = 3 else if ( nact > nactx ) then nactx = nact icount = 3 else icount = icount - 1 if ( icount == 0 ) go to 490 end if ! !     If ICON exceeds NACT, then we add the constraint with index IACT(ICON) to !     the active set. Apply Givens rotations so that the last N-NACT-1 columns !     of Z are orthogonal to the gradient of the new constraint, a scalar !     product being set to zero if its nonzero value could be due to computer !     rounding errors. The array DXNEW is used for working space. ! if ( icon <= nact ) go to 260 kk = iact ( icon ) do i = 1 , n dxnew ( i ) = a ( i , kk ) end do tot = 0.0_wp k = n 100 if ( k > nact ) then sp = 0.0_wp spabs = 0.0_wp do i = 1 , n temp = z ( i , k ) * dxnew ( i ) sp = sp + temp spabs = spabs + abs ( temp ) end do acca = spabs + 0.1_wp * abs ( sp ) accb = spabs + 0.2_wp * abs ( sp ) if ( spabs >= acca . or . acca >= accb ) sp = 0.0_wp if ( tot == 0.0_wp ) then tot = sp else kp = k + 1 temp = sqrt ( sp * sp + tot * tot ) alpha = sp / temp beta = tot / temp tot = temp do i = 1 , n temp = alpha * z ( i , k ) + beta * z ( i , kp ) z ( i , kp ) = alpha * z ( i , kp ) - beta * z ( i , k ) z ( i , k ) = temp end do end if k = k - 1 go to 100 end if ! !     Add the new constraint if this can be done without a deletion from the !     active set. ! if ( tot /= 0.0_wp ) then nact = nact + 1 zdota ( nact ) = tot vmultc ( icon ) = vmultc ( nact ) vmultc ( nact ) = 0.0_wp go to 210 end if ! !     The next instruction is reached if a deletion has to be made from the !     active set in order to make room for the new active constraint, because !     the new constraint gradient is a linear combination of the gradients of !     the old active constraints. Set the elements of VMULTD to the multipliers !     of the linear combination. Further, set IOUT to the index of the !     constraint to be deleted, but branch if no suitable index can be found. ! ratio = - 1.0_wp k = nact 130 zdotv = 0.0_wp zdvabs = 0.0_wp do i = 1 , n temp = z ( i , k ) * dxnew ( i ) zdotv = zdotv + temp zdvabs = zdvabs + abs ( temp ) end do acca = zdvabs + 0.1_wp * abs ( zdotv ) accb = zdvabs + 0.2_wp * abs ( zdotv ) if ( zdvabs < acca . and . acca < accb ) then temp = zdotv / zdota ( k ) if ( temp > 0.0_wp . and . iact ( k ) <= m ) then tempa = vmultc ( k ) / temp if ( ratio < 0.0_wp . or . tempa < ratio ) then ratio = tempa iout = k end if end if if ( k >= 2 ) then kw = iact ( k ) do i = 1 , n dxnew ( i ) = dxnew ( i ) - temp * a ( i , kw ) end do end if vmultd ( k ) = temp else vmultd ( k ) = 0.0_wp end if k = k - 1 if ( k > 0 ) go to 130 if ( ratio < 0.0_wp ) go to 490 ! !     Revise the Lagrange multipliers and reorder the active constraints so !     that the one to be replaced is at the end of the list. Also calculate the !     new value of ZDOTA(NACT) and branch if it is not acceptable. ! do k = 1 , nact vmultc ( k ) = max ( 0.0_wp , vmultc ( k ) - ratio * vmultd ( k )) end do if ( icon < nact ) then isave = iact ( icon ) vsave = vmultc ( icon ) k = icon 170 kp = k + 1 kw = iact ( kp ) sp = 0.0_wp do i = 1 , n sp = sp + z ( i , k ) * a ( i , kw ) end do temp = sqrt ( sp * sp + zdota ( kp ) ** 2 ) alpha = zdota ( kp ) / temp beta = sp / temp zdota ( kp ) = alpha * zdota ( k ) zdota ( k ) = temp do i = 1 , n temp = alpha * z ( i , kp ) + beta * z ( i , k ) z ( i , kp ) = alpha * z ( i , k ) - beta * z ( i , kp ) z ( i , k ) = temp end do iact ( k ) = kw vmultc ( k ) = vmultc ( kp ) k = kp if ( k < nact ) go to 170 iact ( k ) = isave vmultc ( k ) = vsave end if temp = 0.0_wp do i = 1 , n temp = temp + z ( i , nact ) * a ( i , kk ) end do if ( temp == 0.0_wp ) go to 490 zdota ( nact ) = temp vmultc ( icon ) = 0.0_wp vmultc ( nact ) = ratio ! !     Update IACT and ensure that the objective function continues to be !     treated as the last active constraint when MCON>M. ! 210 iact ( icon ) = iact ( nact ) iact ( nact ) = kk if ( mcon > m . and . kk /= mcon ) then k = nact - 1 sp = 0.0_wp do i = 1 , n sp = sp + z ( i , k ) * a ( i , kk ) end do temp = sqrt ( sp * sp + zdota ( nact ) ** 2 ) alpha = zdota ( nact ) / temp beta = sp / temp zdota ( nact ) = alpha * zdota ( k ) zdota ( k ) = temp do i = 1 , n temp = alpha * z ( i , nact ) + beta * z ( i , k ) z ( i , nact ) = alpha * z ( i , k ) - beta * z ( i , nact ) z ( i , k ) = temp end do iact ( nact ) = iact ( k ) iact ( k ) = kk temp = vmultc ( k ) vmultc ( k ) = vmultc ( nact ) vmultc ( nact ) = temp end if ! !     If stage one is in progress, then set SDIRN to the direction of the next !     change to the current vector of variables. ! if ( mcon > m ) go to 320 kk = iact ( nact ) temp = 0.0_wp do i = 1 , n temp = temp + sdirn ( i ) * a ( i , kk ) end do temp = temp - 1.0_wp temp = temp / zdota ( nact ) do i = 1 , n sdirn ( i ) = sdirn ( i ) - temp * z ( i , nact ) end do go to 340 ! !     Delete the constraint that has the index IACT(ICON) from the active set. ! 260 if ( icon < nact ) then isave = iact ( icon ) vsave = vmultc ( icon ) k = icon 270 kp = k + 1 kk = iact ( kp ) sp = 0.0_wp do i = 1 , n sp = sp + z ( i , k ) * a ( i , kk ) end do temp = sqrt ( sp * sp + zdota ( kp ) ** 2 ) alpha = zdota ( kp ) / temp beta = sp / temp zdota ( kp ) = alpha * zdota ( k ) zdota ( k ) = temp do i = 1 , n temp = alpha * z ( i , kp ) + beta * z ( i , k ) z ( i , kp ) = alpha * z ( i , k ) - beta * z ( i , kp ) z ( i , k ) = temp end do iact ( k ) = kk vmultc ( k ) = vmultc ( kp ) k = kp if ( k < nact ) go to 270 iact ( k ) = isave vmultc ( k ) = vsave end if nact = nact - 1 ! !     If stage one is in progress, then set SDIRN to the direction of the next !     change to the current vector of variables. ! if ( mcon > m ) go to 320 temp = 0.0_wp do i = 1 , n temp = temp + sdirn ( i ) * z ( i , nact + 1 ) end do do i = 1 , n sdirn ( i ) = sdirn ( i ) - temp * z ( i , nact + 1 ) end do go to 340 ! !     Pick the next search direction of stage two. ! 320 temp = 1.0_wp / zdota ( nact ) do i = 1 , n sdirn ( i ) = temp * z ( i , nact ) end do ! !     Calculate the step to the boundary of the trust region or take the step !     that reduces RESMAX to zero. The two statements below that include the !     factor 1.0E-6 prevent some harmless underflows that occurred in a test !     calculation. Further, we skip the step if it could be zero within a !     reasonable tolerance for computer rounding errors. ! 340 dd = rho * rho sd = 0.0_wp ss = 0.0_wp do i = 1 , n if ( abs ( dx ( i )) >= 1.0e-6_wp * rho ) dd = dd - dx ( i ) ** 2 sd = sd + dx ( i ) * sdirn ( i ) ss = ss + sdirn ( i ) ** 2 end do if ( dd <= 0.0_wp ) go to 490 temp = sqrt ( ss * dd ) if ( abs ( sd ) >= 1.0e-6_wp * temp ) temp = sqrt ( ss * dd + sd * sd ) stpful = dd / ( temp + sd ) step = stpful if ( mcon == m ) then acca = step + 0.1_wp * resmax accb = step + 0.2_wp * resmax if ( step >= acca . or . acca >= accb ) go to 480 step = min ( step , resmax ) end if ! !     Set DXNEW to the new variables if STEP is the steplength, and reduce !     RESMAX to the corresponding maximum residual if stage one is being done. !     Because DXNEW will be changed during the calculation of some Lagrange !     multipliers, it will be restored to the following value later. ! do i = 1 , n dxnew ( i ) = dx ( i ) + step * sdirn ( i ) end do if ( mcon == m ) then resold = resmax resmax = 0.0_wp do k = 1 , nact kk = iact ( k ) temp = b ( kk ) do i = 1 , n temp = temp - a ( i , kk ) * dxnew ( i ) end do resmax = max ( resmax , temp ) end do end if ! !     Set VMULTD to the VMULTC vector that would occur if DX became DXNEW. A !     device is included to force VMULTD(K)=0.0 if deviations from this value !     can be attributed to computer rounding errors. First calculate the new !     Lagrange multipliers. ! k = nact 390 zdotw = 0.0_wp zdwabs = 0.0_wp do i = 1 , n temp = z ( i , k ) * dxnew ( i ) zdotw = zdotw + temp zdwabs = zdwabs + abs ( temp ) end do acca = zdwabs + 0.1_wp * abs ( zdotw ) accb = zdwabs + 0.2_wp * abs ( zdotw ) if ( zdwabs >= acca . or . acca >= accb ) zdotw = 0.0_wp vmultd ( k ) = zdotw / zdota ( k ) if ( k >= 2 ) then kk = iact ( k ) do i = 1 , n dxnew ( i ) = dxnew ( i ) - vmultd ( k ) * a ( i , kk ) end do k = k - 1 go to 390 end if if ( mcon > m ) vmultd ( nact ) = max ( 0.0_wp , vmultd ( nact )) ! !     Complete VMULTC by finding the new constraint residuals. ! do i = 1 , n dxnew ( i ) = dx ( i ) + step * sdirn ( i ) end do if ( mcon > nact ) then kl = nact + 1 do k = kl , mcon kk = iact ( k ) sum = resmax - b ( kk ) sumabs = resmax + abs ( b ( kk )) do i = 1 , n temp = a ( i , kk ) * dxnew ( i ) sum = sum + temp sumabs = sumabs + abs ( temp ) end do acca = sumabs + 0.1_wp * abs ( sum ) accb = sumabs + 0.2_wp * abs ( sum ) if ( sumabs >= acca . or . acca >= accb ) sum = 0.0_wp vmultd ( k ) = sum end do end if ! !     Calculate the fraction of the step from DX to DXNEW that will be taken. ! ratio = 1.0_wp icon = 0 do k = 1 , mcon if ( vmultd ( k ) < 0.0_wp ) then temp = vmultc ( k ) / ( vmultc ( k ) - vmultd ( k )) if ( temp < ratio ) then ratio = temp icon = k end if end if end do ! !     Update DX, VMULTC and RESMAX. ! temp = 1.0_wp - ratio do i = 1 , n dx ( i ) = temp * dx ( i ) + ratio * dxnew ( i ) end do do k = 1 , mcon vmultc ( k ) = max ( 0.0_wp , temp * vmultc ( k ) + ratio * vmultd ( k )) end do if ( mcon == m ) resmax = resold + ratio * ( resmax - resold ) ! !     If the full step is not acceptable then begin another iteration. !     Otherwise switch to stage two or end the calculation. ! if ( icon > 0 ) go to 70 if ( step == stpful ) return 480 mcon = m + 1 icon = mcon iact ( mcon ) = mcon vmultc ( mcon ) = 0.0_wp go to 60 ! !     We employ any freedom that may be available to reduce the objective !     function before returning a DX whose length is less than RHO. ! 490 if ( mcon == m ) go to 480 ifull = 0 end subroutine trstlp !***************************************************************************************** !> !  Test routine for [[cobyla]]. ! !  From: Report DAMTP 1992/NA5. subroutine cobyla_test () implicit none real ( wp ), dimension ( 10 ) :: x , xopt integer :: nprob , n , m , i , icase , iprint , maxfun real ( wp ) :: rhobeg , rhoend , temp , tempa , tempb , tempc , tempd do nprob = 1 , 10 if ( nprob == 1 ) then ! !     minimization of a simple quadratic function of two variables. ! print 10 10 format ( / 7 x , 'Output from test problem 1 (Simple quadratic)' ) n = 2 m = 0 xopt ( 1 ) = - 1.0_wp xopt ( 2 ) = 0.0_wp else if ( nprob == 2 ) then ! !     Easy two dimensional minimization in unit circle. ! print 20 20 format ( / 7 x , 'Output from test problem 2 (2D unit circle ' ,& 'calculation)' ) n = 2 m = 1 xopt ( 1 ) = sqrt ( 0.5_wp ) xopt ( 2 ) = - xopt ( 1 ) else if ( nprob == 3 ) then ! !     Easy three dimensional minimization in ellipsoid. ! print 30 30 format ( / 7 x , 'Output from test problem 3 (3D ellipsoid ' ,& 'calculation)' ) n = 3 m = 1 xopt ( 1 ) = 1.0_wp / sqrt ( 3.0_wp ) xopt ( 2 ) = 1.0_wp / sqrt ( 6.0_wp ) xopt ( 3 ) = - 1.0_wp / 3.0_wp else if ( nprob == 4 ) then ! !     Weak version of Rosenbrock's problem. ! print 40 40 format ( / 7 x , 'Output from test problem 4 (Weak Rosenbrock)' ) n = 2 m = 0 xopt ( 1 ) = - 1.0_wp xopt ( 2 ) = 1.0_wp else if ( nprob == 5 ) then ! !     Intermediate version of Rosenbrock's problem. ! print 50 50 format ( / 7 x , 'Output from test problem 5 (Intermediate ' , 'Rosenbrock)' ) n = 2 m = 0 xopt ( 1 ) = - 1.0_wp xopt ( 2 ) = 1.0_wp else if ( nprob == 6 ) then ! !     This problem is taken from Fletcher's book Practical Methods of !     Optimization and has the equation number (9.1.15). ! print 60 60 format ( / 7 x , 'Output from test problem 6 (Equation ' ,& '(9.1.15) in Fletcher)' ) n = 2 m = 2 xopt ( 1 ) = sqrt ( 0.5_wp ) xopt ( 2 ) = xopt ( 1 ) else if ( nprob == 7 ) then ! !     This problem is taken from Fletcher's book Practical Methods of !     Optimization and has the equation number (14.4.2). ! print 70 70 format ( / 7 x , 'Output from test problem 7 (Equation ' ,& '(14.4.2) in Fletcher)' ) n = 3 m = 3 xopt ( 1 ) = 0.0_wp xopt ( 2 ) = - 3.0_wp xopt ( 3 ) = - 3.0_wp else if ( nprob == 8 ) then ! !     This problem is taken from page 66 of Hock and Schittkowski's book Test !     Examples for Nonlinear Programming Codes. It is their test problem Number !     43, and has the name Rosen-Suzuki. ! print 80 80 format ( / 7 x , 'Output from test problem 8 (Rosen-Suzuki)' ) n = 4 m = 3 xopt ( 1 ) = 0.0_wp xopt ( 2 ) = 1.0_wp xopt ( 3 ) = 2.0_wp xopt ( 4 ) = - 1.0_wp else if ( nprob == 9 ) then ! !     This problem is taken from page 111 of Hock and Schittkowski's !     book Test Examples for Nonlinear Programming Codes. It is their !     test problem Number 100. ! print 90 90 format ( / 7 x , 'Output from test problem 9 (Hock and ' ,& 'Schittkowski 100)' ) n = 7 m = 4 xopt ( 1 ) = 2.330499_wp xopt ( 2 ) = 1.951372_wp xopt ( 3 ) = - 0.4775414_wp xopt ( 4 ) = 4.365726_wp xopt ( 5 ) = - 0.624487_wp xopt ( 6 ) = 1.038131_wp xopt ( 7 ) = 1.594227_wp else if ( nprob == 10 ) then ! !     This problem is taken from page 415 of Luenberger's book Applied !     Nonlinear Programming. It is to maximize the area of a hexagon of !     unit diameter. ! print 100 100 format ( / 7 x , 'Output from test problem 10 (Hexagon area)' ) n = 9 m = 14 end if do icase = 1 , 2 do i = 1 , n x ( i ) = 1.0_wp end do rhobeg = 0.5_wp rhoend = 0.001_wp if ( icase == 2 ) rhoend = 0.0001_wp iprint = 1 maxfun = 2000 call cobyla ( n , m , x , rhobeg , rhoend , iprint , maxfun , calcfc ) if ( nprob == 10 ) then tempa = x ( 1 ) + x ( 3 ) + x ( 5 ) + x ( 7 ) tempb = x ( 2 ) + x ( 4 ) + x ( 6 ) + x ( 8 ) tempc = 0.5_wp / sqrt ( tempa * tempa + tempb * tempb ) tempd = tempc * sqrt ( 3.0_wp ) xopt ( 1 ) = tempd * tempa + tempc * tempb xopt ( 2 ) = tempd * tempb - tempc * tempa xopt ( 3 ) = tempd * tempa - tempc * tempb xopt ( 4 ) = tempd * tempb + tempc * tempa do i = 1 , 4 xopt ( i + 4 ) = xopt ( i ) end do xopt ( 9 ) = 0.0_wp end if temp = 0.0_wp do i = 1 , n temp = temp + ( x ( i ) - xopt ( i )) ** 2 end do print 150 , sqrt ( temp ) 150 format ( / 5 x , 'Least squares error in variables =' , 1 pe16 . 6 ) end do print 170 170 format ( 2 x , '----------------------------------------------' ,& '--------------------' ) end do contains subroutine calcfc ( n , m , x , f , con ) implicit none integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( * ), intent ( in ) :: x real ( wp ), intent ( out ) :: f real ( wp ), dimension ( * ), intent ( out ) :: con if ( nprob == 1 ) then ! !     Test problem 1 (Simple quadratic) ! f = 1 0.0_wp * ( x ( 1 ) + 1.0_wp ) ** 2 + x ( 2 ) ** 2 else if ( nprob == 2 ) then ! !    Test problem 2 (2D unit circle calculation) ! f = x ( 1 ) * x ( 2 ) con ( 1 ) = 1.0_wp - x ( 1 ) ** 2 - x ( 2 ) ** 2 else if ( nprob == 3 ) then ! !     Test problem 3 (3D ellipsoid calculation) ! f = x ( 1 ) * x ( 2 ) * x ( 3 ) con ( 1 ) = 1.0_wp - x ( 1 ) ** 2 - 2.0_wp * x ( 2 ) ** 2 - 3.0_wp * x ( 3 ) ** 2 else if ( nprob == 4 ) then ! !     Test problem 4 (Weak Rosenbrock) ! f = ( x ( 1 ) ** 2 - x ( 2 )) ** 2 + ( 1.0_wp + x ( 1 )) ** 2 else if ( nprob == 5 ) then ! !     Test problem 5 (Intermediate Rosenbrock) ! f = 1 0.0_wp * ( x ( 1 ) ** 2 - x ( 2 )) ** 2 + ( 1.0_wp + x ( 1 )) ** 2 else if ( nprob == 6 ) then ! !     Test problem 6 (Equation (9.1.15) in Fletcher's book) ! f = - x ( 1 ) - x ( 2 ) con ( 1 ) = x ( 2 ) - x ( 1 ) ** 2 con ( 2 ) = 1.0_wp - x ( 1 ) ** 2 - x ( 2 ) ** 2 else if ( nprob == 7 ) then ! !     Test problem 7 (Equation (14.4.2) in Fletcher's book) ! f = x ( 3 ) con ( 1 ) = 5.0_wp * x ( 1 ) - x ( 2 ) + x ( 3 ) con ( 2 ) = x ( 3 ) - x ( 1 ) ** 2 - x ( 2 ) ** 2 - 4.0_wp * x ( 2 ) con ( 3 ) = x ( 3 ) - 5.0_wp * x ( 1 ) - x ( 2 ) else if ( nprob == 8 ) then ! !     Test problem 8 (Rosen-Suzuki) ! f = x ( 1 ) ** 2 + x ( 2 ) ** 2 + 2.0_wp * x ( 3 ) ** 2 + x ( 4 ) ** 2 - 5.0_wp * & & x ( 1 ) - 5.0_wp * x ( 2 ) - 2 1.0_wp * x ( 3 ) + 7.0_wp * x ( 4 ) con ( 1 ) = 8.0_wp - x ( 1 ) ** 2 - x ( 2 ) ** 2 - x ( 3 ) ** 2 - x ( 4 ) ** 2 - x & & ( 1 ) + x ( 2 ) - x ( 3 ) + x ( 4 ) con ( 2 ) = 1 0.0_wp - x ( 1 ) ** 2 - 2.0_wp * x ( 2 ) ** 2 - x ( 3 ) ** 2 - & & 2.0_wp * x ( 4 ) ** 2 + x ( 1 ) + x ( 4 ) con ( 3 ) = 5.0_wp - 2.0_wp * x ( 1 ) ** 2 - x ( 2 ) ** 2 - x ( 3 ) ** 2 - 2.0_wp & & * x ( 1 ) + x ( 2 ) + x ( 4 ) else if ( nprob == 9 ) then ! !     Test problem 9 (Hock and Schittkowski 100) ! f = ( x ( 1 ) - 1 0.0_wp ) ** 2 + 5.0_wp * ( x ( 2 ) - 1 2.0_wp ) ** 2 + x ( 3 ) ** 4 + & & 3.0_wp * ( x ( 4 ) - 1 1.0_wp ) ** 2 + 1 0.0_wp * x ( 5 ) ** 6 + 7.0_wp * x ( 6 ) ** & & 2 + x ( 7 ) ** 4 - 4.0_wp * x ( 6 ) * x ( 7 ) - 1 0.0_wp * x ( 6 ) - 8.0_wp * x & & ( 7 ) con ( 1 ) = 12 7.0_wp - 2.0_wp * x ( 1 ) ** 2 - 3.0_wp * x ( 2 ) ** 4 - x ( 3 ) - & & 4.0_wp * x ( 4 ) ** 2 - 5.0_wp * x ( 5 ) con ( 2 ) = 28 2.0_wp - 7.0_wp * x ( 1 ) - 3.0_wp * x ( 2 ) - 1 0.0_wp * x ( 3 ) ** & & 2 - x ( 4 ) + x ( 5 ) con ( 3 ) = 19 6.0_wp - 2 3.0_wp * x ( 1 ) - x ( 2 ) ** 2 - 6.0_wp * x ( 6 ) ** 2 + & & 8.0_wp * x ( 7 ) con ( 4 ) = - 4.0_wp * x ( 1 ) ** 2 - x ( 2 ) ** 2 + 3.0_wp * x ( 1 ) * x ( 2 ) - & & 2.0_wp * x ( 3 ) ** 2 - 5.0_wp * x ( 6 ) + 1 1.0_wp * x ( 7 ) else if ( nprob == 10 ) then ! !     Test problem 10 (Hexagon area) ! f = - 0.5_wp * & ( x ( 1 ) * x ( 4 ) - x ( 2 ) * x ( 3 ) + x ( 3 ) * x ( 9 ) - x ( 5 ) * x ( 9 ) + x ( 5 ) * x ( 8 ) - x ( 6 ) * x ( 7 )) con ( 1 ) = 1.0_wp - x ( 3 ) ** 2 - x ( 4 ) ** 2 con ( 2 ) = 1.0_wp - x ( 9 ) ** 2 con ( 3 ) = 1.0_wp - x ( 5 ) ** 2 - x ( 6 ) ** 2 con ( 4 ) = 1.0_wp - x ( 1 ) ** 2 - ( x ( 2 ) - x ( 9 )) ** 2 con ( 5 ) = 1.0_wp - ( x ( 1 ) - x ( 5 )) ** 2 - ( x ( 2 ) - x ( 6 )) ** 2 con ( 6 ) = 1.0_wp - ( x ( 1 ) - x ( 7 )) ** 2 - ( x ( 2 ) - x ( 8 )) ** 2 con ( 7 ) = 1.0_wp - ( x ( 3 ) - x ( 5 )) ** 2 - ( x ( 4 ) - x ( 6 )) ** 2 con ( 8 ) = 1.0_wp - ( x ( 3 ) - x ( 7 )) ** 2 - ( x ( 4 ) - x ( 8 )) ** 2 con ( 9 ) = 1.0_wp - x ( 7 ) ** 2 - ( x ( 8 ) - x ( 9 )) ** 2 con ( 10 ) = x ( 1 ) * x ( 4 ) - x ( 2 ) * x ( 3 ) con ( 11 ) = x ( 3 ) * x ( 9 ) con ( 12 ) = - x ( 5 ) * x ( 9 ) con ( 13 ) = x ( 5 ) * x ( 8 ) - x ( 6 ) * x ( 7 ) con ( 14 ) = x ( 9 ) end if end subroutine calcfc end subroutine cobyla_test !***************************************************************************************** end module cobyla_module","tags":"","loc":"sourcefile/cobyla.f90.html"},{"title":"powellopt.f90 – PowellOpt","text":"This file depends on sourcefile~~powellopt.f90~~EfferentGraph sourcefile~powellopt.f90 powellopt.f90 sourcefile~bobyqa.f90 bobyqa.f90 sourcefile~powellopt.f90->sourcefile~bobyqa.f90 sourcefile~cobyla.f90 cobyla.f90 sourcefile~powellopt.f90->sourcefile~cobyla.f90 sourcefile~lincoa.f90 lincoa.f90 sourcefile~powellopt.f90->sourcefile~lincoa.f90 sourcefile~newuoa.f90 newuoa.f90 sourcefile~powellopt.f90->sourcefile~newuoa.f90 sourcefile~uobyqa.f90 uobyqa.f90 sourcefile~powellopt.f90->sourcefile~uobyqa.f90 sourcefile~kind_module.f90 kind_module.f90 sourcefile~bobyqa.f90->sourcefile~kind_module.f90 sourcefile~cobyla.f90->sourcefile~kind_module.f90 sourcefile~lincoa.f90->sourcefile~kind_module.f90 sourcefile~newuoa.f90->sourcefile~kind_module.f90 sourcefile~uobyqa.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  PowellOpt Module module powellopt use bobyqa_module use cobyla_module use lincoa_module use newuoa_module use uobyqa_module implicit none public end module powellopt !*****************************************************************************************","tags":"","loc":"sourcefile/powellopt.f90.html"},{"title":"kind_module.f90 – PowellOpt","text":"Files dependent on this one sourcefile~~kind_module.f90~~AfferentGraph sourcefile~kind_module.f90 kind_module.f90 sourcefile~bobyqa.f90 bobyqa.f90 sourcefile~bobyqa.f90->sourcefile~kind_module.f90 sourcefile~cobyla.f90 cobyla.f90 sourcefile~cobyla.f90->sourcefile~kind_module.f90 sourcefile~lincoa.f90 lincoa.f90 sourcefile~lincoa.f90->sourcefile~kind_module.f90 sourcefile~newuoa.f90 newuoa.f90 sourcefile~newuoa.f90->sourcefile~kind_module.f90 sourcefile~uobyqa.f90 uobyqa.f90 sourcefile~uobyqa.f90->sourcefile~kind_module.f90 sourcefile~powellopt.f90 powellopt.f90 sourcefile~powellopt.f90->sourcefile~bobyqa.f90 sourcefile~powellopt.f90->sourcefile~cobyla.f90 sourcefile~powellopt.f90->sourcefile~lincoa.f90 sourcefile~powellopt.f90->sourcefile~newuoa.f90 sourcefile~powellopt.f90->sourcefile~uobyqa.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Kind definitions for the other modules. module kind_module use iso_fortran_env implicit none private ! default real precision: !integer,parameter,public :: wp = real32   !! single precision integer , parameter , public :: wp = real64 !! double precision [default] !integer,parameter,public :: wp = real128  !! quad precision end module kind_module !*****************************************************************************************","tags":"","loc":"sourcefile/kind_module.f90.html"},{"title":"lincoa.f90 – PowellOpt","text":"This file depends on sourcefile~~lincoa.f90~~EfferentGraph sourcefile~lincoa.f90 lincoa.f90 sourcefile~kind_module.f90 kind_module.f90 sourcefile~lincoa.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lincoa.f90~~AfferentGraph sourcefile~lincoa.f90 lincoa.f90 sourcefile~powellopt.f90 powellopt.f90 sourcefile~powellopt.f90->sourcefile~lincoa.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  LINCOA: **LIN**early **C**onstrained **O**ptimization **A**lgorithm ! !  The purpose of LINCOA is to seek the least value of a function F of several variables !  subject to general linear inequality constraints on the variables, !  when derivatives of F are not available. ! !# History !  * M.J.D. Powell, December 6th, 2013 : There are no !    restrictions on or charges for the use of the software. I hope that the time !    and effort I have spent on developing the package will be helpful to much !    research and to many applications. !  * Jacob Williams, July 2015 : refactoring of the code into modern Fortran. module lincoa_module use kind_module , only : wp private abstract interface subroutine func ( n , x , f ) !! calfun interface import :: wp implicit none integer :: n real ( wp ) :: x ( * ) real ( wp ) :: f end subroutine func end interface public :: lincoa public :: lincoa_test contains !***************************************************************************************** !> !  This subroutine seeks the least value of a function of many variables, !  subject to general linear inequality constraints, by a trust region !  method that forms quadratic models by interpolation. ! !  LINCOA solves the following optimization problem: !``` !   Minimize F(X(1),X(2),...X(N)) subject to: !   A * X <= B !``` ! !  Usually there !  is much freedom in each new model after satisfying the interpolation !  conditions, which is taken up by minimizing the Frobenius norm of !  the change to the second derivative matrix of the model. One new !  function value is calculated on each iteration, usually at a point !  where the current model predicts a reduction in the least value so !  far of the objective function subject to the linear constraints. !  Alternatively, a new vector of variables may be chosen to replace !  an interpolation point that may be too far away for reliability, and !  then the new point does not have to satisfy the linear constraints. subroutine lincoa ( n , npt , m , a , ia , b , x , rhobeg , rhoend , iprint , maxfun , calfun ) implicit none integer , intent ( in ) :: n !! the number of variables. must be at least 2. integer , intent ( in ) :: npt !! the number of interpolation conditions, which is !! required to be in the interval [N+2,(N+1)(N+2)/2]. Typical choices !! of the author are NPT=N+6 and NPT=2*N+1. Larger values tend to be !! highly inefficent when the number of variables is substantial, due !! to the amount of work and extra difficulty of adjusting more points. integer , intent ( in ) :: m !! the number of linear inequality constraints. integer , intent ( in ) :: ia !! the first dimension of the array A, which must be at least N. real ( wp ), dimension ( ia , * ), intent ( in ) :: a !! a matrix whose columns are the constraint gradients, which are !! required to be nonzero. real ( wp ), dimension ( * ), intent ( in ) :: b !! the vector of right hand sides of the constraints, the J-th !! constraint being that the scalar product of A(.,J) with X(.) is at !! most B(J). The initial vector X(.) is made feasible by increasing !! the value of B(J) if necessary. real ( wp ), dimension ( * ), intent ( inout ) :: x !! the vector of variables. Initial values of X(1),X(2),...,X(N) !! must be supplied. If they do not satisfy the constraints, then B !! is increased as mentioned above. X contains on return the variables !! that have given the least calculated F subject to the constraints. real ( wp ), intent ( in ) :: rhobeg !! RHOBEG and RHOEND must be set to the initial and final values of a !! trust region radius, so both must be positive with RHOEND<=RHOBEG. !! Typically, RHOBEG should be about one tenth of the greatest expected !! change to a variable, and RHOEND should indicate the accuracy that !! is required in the final values of the variables. real ( wp ), intent ( in ) :: rhoend !! RHOBEG and RHOEND must be set to the initial and final values of a !! trust region radius, so both must be positive with RHOEND<=RHOBEG. !! Typically, RHOBEG should be about one tenth of the greatest expected !! change to a variable, and RHOEND should indicate the accuracy that !! is required in the final values of the variables. integer , intent ( in ) :: iprint !! The value of IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, the best !! feasible vector of variables so far and the corresponding value of !! the objective function are printed whenever RHO is reduced, where !! RHO is the current lower bound on the trust region radius. Further, !! each new value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! an upper bound on the number of calls of CALFUN, !! its value being at least NPT+1. procedure ( func ) :: calfun !! It must set !! F to the value of the objective function for the variables X(1), !! X(2),...,X(N). The value of the argument F is positive when CALFUN !! is called if and only if the current X satisfies the constraints real ( wp ), parameter :: zero = 0.0_wp real ( wp ), dimension (:), allocatable :: w integer , dimension ( n ) :: iact !to avoid type mismatch error - JW real ( wp ) :: smallx , sum , temp integer :: np , nptm , iamat , ib , iflag , i , iac , ibmat , ifv , igo , ihq , ipq , ipqw ,& iqf , irc , isp , istp , iw , ixb , ixn , ixo , ixp , ixs , irf , izmat , j , ndim !     W is an array used for working space. Its length must be at least !       M*(2+N) + NPT*(4+N+NPT) + N*(9+3*N) + MAX [ M+3*N, 2*M+N, 2*NPT ]. !       On return, W(1) is set to the final value of F, and W(2) is set to !       the total number of function evaluations plus 0.5. allocate ( w ( M * ( 2 + N ) + NPT * ( 4 + N + NPT ) + N * ( 9 + 3 * N ) + MAX ( M + 3 * N , 2 * M + N , 2 * NPT ))) ! !     Check that N, NPT and MAXFUN are acceptable. ! smallx = 1.0e-6_wp * rhoend np = n + 1 nptm = npt - np if ( n <= 1 ) then print 10 10 format ( / 4 x , 'Return from LINCOA because N is less than 2.' ) return end if if ( npt < n + 2 . or . npt > (( n + 2 ) * np ) / 2 ) then print 20 20 format ( / 4 x , 'Return from LINCOA because NPT is not in' ,& ' the required interval.' ) return end if if ( maxfun <= npt ) then print 30 30 format ( / 4 x , 'Return from LINCOA because MAXFUN is less' , ' than NPT+1.' ) return end if ! !     Normalize the constraints, and copy the resultant constraint matrix !       and right hand sides into working space, after increasing the right !       hand sides if necessary so that the starting point is feasible. ! iamat = max ( m + 3 * n , 2 * m + n , 2 * npt ) + 1 ib = iamat + m * n iflag = 0 if ( m > 0 ) then iw = iamat - 1 do j = 1 , m sum = zero temp = zero do i = 1 , n sum = sum + a ( i , j ) * x ( i ) temp = temp + a ( i , j ) ** 2 end do if ( temp == zero ) then print 50 50 format ( / 4 x , 'Return from LINCOA because the gradient of' ,& ' a constraint is zero.' ) return end if temp = sqrt ( temp ) if ( sum - b ( j ) > smallx * temp ) iflag = 1 w ( ib + j - 1 ) = max ( b ( j ), sum ) / temp do i = 1 , n iw = iw + 1 w ( iw ) = a ( i , j ) / temp end do end do end if if ( iflag == 1 ) then if ( iprint > 0 ) print 70 70 format ( / 4 x , 'LINCOA has made the initial X feasible by' ,& ' increasing part(s) of B.' ) end if ! !     Partition the working space array, so that different parts of it can be !     treated separately by the subroutine that performs the main calculation. ! ndim = npt + n ixb = ib + m ixp = ixb + n ifv = ixp + n * npt ixs = ifv + npt ixo = ixs + n igo = ixo + n ihq = igo + n ipq = ihq + ( n * np ) / 2 ibmat = ipq + npt izmat = ibmat + ndim * n istp = izmat + npt * nptm isp = istp + n ixn = isp + npt + npt iac = ixn + n irc = iac + n iqf = irc + m irf = iqf + n * n ipqw = irf + ( n * np ) / 2 ! !     The above settings provide a partition of W for subroutine LINCOB. ! call lincob ( n , npt , m , w ( iamat ), w ( ib ), x , rhobeg , rhoend , iprint , maxfun , & w ( ixb ), w ( ixp ), w ( ifv ), w ( ixs ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), & w ( ibmat ), w ( izmat ), ndim , w ( istp ), w ( isp ), w ( ixn ), iact , w ( irc ), & w ( iqf ), w ( irf ), w ( ipqw ), w , calfun ) deallocate ( w ) end subroutine lincoa !***************************************************************************************** subroutine lincob ( n , npt , m , amat , b , x , rhobeg , rhoend , iprint , maxfun , xbase , xpt , & fval , xsav , xopt , gopt , hq , pq , bmat , zmat , ndim , step , sp , xnew , & iact , rescon , qfac , rfac , pqw , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension amat ( n , * ), b ( * ), x ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xsav ( * ), & xopt ( * ), gopt ( * ), hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), & step ( * ), sp ( * ), xnew ( * ), iact ( * ), rescon ( * ), qfac ( n , * ), rfac ( * ), & pqw ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, M, X, RHOBEG, RHOEND, IPRINT and MAXFUN are !       identical to the corresponding arguments in SUBROUTINE LINCOA. !     AMAT is a matrix whose columns are the constraint gradients, scaled !       so that they have unit length. !     B contains on entry the right hand sides of the constraints, scaled !       as above, but later B is modified for variables relative to XBASE. !     XBASE holds a shift of origin that should reduce the contributions !       from rounding errors to values of the model and Lagrange functions. !     XPT contains the interpolation point coordinates relative to XBASE. !     FVAL holds the values of F at the interpolation points. !     XSAV holds the best feasible vector of variables so far, without any !       shift of origin. !     XOPT is set to XSAV-XBASE, which is the displacement from XBASE of !       the feasible vector of variables that provides the least calculated !       F so far, this vector being the current trust region centre. !     GOPT holds the gradient of the quadratic model at XSAV = XBASE+XOPT. !     HQ holds the explicit second derivatives of the quadratic model. !     PQ contains the parameters of the implicit second derivatives of the !       quadratic model. !     BMAT holds the last N columns of the big inverse matrix H. !     ZMAT holds the factorization of the leading NPT by NPT submatrix !       of H, this factorization being ZMAT times Diag(DZ) times ZMAT&#94;T, !       where the elements of DZ are plus or minus one, as specified by IDZ. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     STEP is employed for trial steps from XOPT. It is also used for working !       space when XBASE is shifted and in PRELIM. !     SP is reserved for the scalar products XOPT&#94;T XPT(K,.), K=1,2,...,NPT, !       followed by STEP&#94;T XPT(K,.), K=1,2,...,NPT. !     XNEW is the displacement from XBASE of the vector of variables for !       the current calculation of F, except that SUBROUTINE TRSTEP uses it !       for working space. !     IACT is an integer array for the indices of the active constraints. !     RESCON holds useful information about the constraint residuals. Every !       nonnegative RESCON(J) is the residual of the J-th constraint at the !       current trust region centre. Otherwise, if RESCON(J) is negative, the !       J-th constraint holds as a strict inequality at the trust region !       centre, its residual being at least |RESCON(J)|; further, the value !       of |RESCON(J)| is at least the current trust region radius DELTA. !     QFAC is the orthogonal part of the QR factorization of the matrix of !       active constraint gradients, these gradients being ordered in !       accordance with IACT. When NACT is less than N, columns are added !       to QFAC to complete an N by N orthogonal matrix, which is important !       for keeping calculated steps sufficiently close to the boundaries !       of the active constraints. !     RFAC is the upper triangular part of this QR factorization, beginning !       with the first diagonal element, followed by the two elements in the !       upper triangular part of the second column and so on. !     PQW is used for working space, mainly for storing second derivative !       coefficients of quadratic functions. Its length is NPT+N. !     The array W is also used for working space. The required number of !       elements, namely MAX[M+3*N,2*M+N,2*NPT], is set in LINCOA. ! !     Set some constants. ! real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: tenth = 0.1_wp real ( wp ), parameter :: zero = 0.0_wp np = n + 1 nh = ( n * np ) / 2 nptm = npt - np ! !     Set the elements of XBASE, XPT, FVAL, XSAV, XOPT, GOPT, HQ, PQ, BMAT, !       ZMAT and SP for the first iteration. An important feature is that, !       if the interpolation point XPT(K,.) is not feasible, where K is any !       integer from [1,NPT], then a change is made to XPT(K,.) if necessary !       so that the constraint violation is at least 0.2*RHOBEG. Also KOPT !       is set so that XPT(KOPT,.) is the initial trust region centre. ! call prelim ( n , npt , m , amat , b , x , rhobeg , iprint , xbase , xpt , fval , xsav , xopt , & gopt , kopt , hq , pq , bmat , zmat , idz , ndim , sp , rescon , step , pqw , w , & calfun ) ! !     Begin the iterative procedure. ! nf = npt fopt = fval ( kopt ) rho = rhobeg delta = rho ifeas = 0 nact = 0 itest = 3 10 knew = 0 nvala = 0 nvalb = 0 ! !     Shift XBASE if XOPT may be too far from XBASE. First make the changes !       to BMAT that do not depend on ZMAT. ! 20 fsave = fopt xoptsq = zero do i = 1 , n xoptsq = xoptsq + xopt ( i ) ** 2 end do if ( xoptsq >= 1.0e4_wp * delta * delta ) then qoptsq = 0.25_wp * xoptsq do k = 1 , npt sum = zero do i = 1 , n sum = sum + xpt ( k , i ) * xopt ( i ) end do sum = sum - half * xoptsq w ( npt + k ) = sum sp ( k ) = zero do i = 1 , n xpt ( k , i ) = xpt ( k , i ) - half * xopt ( i ) step ( i ) = bmat ( k , i ) w ( i ) = sum * xpt ( k , i ) + qoptsq * xopt ( i ) ip = npt + i do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + step ( i ) * w ( j ) + w ( i ) * step ( j ) end do end do end do ! !     Then the revisions of BMAT that depend on ZMAT are calculated. ! do k = 1 , nptm sumz = zero do i = 1 , npt sumz = sumz + zmat ( i , k ) w ( i ) = w ( npt + i ) * zmat ( i , k ) end do do j = 1 , n sum = qoptsq * sumz * xopt ( j ) do i = 1 , npt sum = sum + w ( i ) * xpt ( i , j ) end do step ( j ) = sum if ( k < idz ) sum = - sum do i = 1 , npt bmat ( i , j ) = bmat ( i , j ) + sum * zmat ( i , k ) end do end do do i = 1 , n ip = i + npt temp = step ( i ) if ( k < idz ) temp = - temp do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + temp * step ( j ) end do end do end do ! !     Update the right hand sides of the constraints. ! if ( m > 0 ) then do j = 1 , m temp = zero do i = 1 , n temp = temp + amat ( i , j ) * xopt ( i ) end do b ( j ) = b ( j ) - temp end do end if ! !     The following instructions complete the shift of XBASE, including the !       changes to the parameters of the quadratic model. ! ih = 0 do j = 1 , n w ( j ) = zero do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) xpt ( k , j ) = xpt ( k , j ) - half * xopt ( j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + xopt ( i ) * w ( j ) bmat ( npt + i , j ) = bmat ( npt + j , i ) end do end do do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) xopt ( j ) = zero xpt ( kopt , j ) = zero end do end if ! !     In the case KNEW=0, generate the next trust region step by calling !       TRSTEP, where SNORM is the current trust region radius initially. !       The final value of SNORM is the length of the calculated step, !       except that SNORM is zero on return if the projected gradient is !       unsuitable for starting the conjugate gradient iterations. ! delsav = delta ksave = knew if ( knew == 0 ) then snorm = delta do i = 1 , n xnew ( i ) = gopt ( i ) end do call trstep ( n , npt , m , amat , b , xpt , hq , pq , nact , iact , rescon , qfac , rfac , & snorm , step , xnew , w , w ( m + 1 ), pqw , pqw ( np ), w ( m + np )) ! !     A trust region step is applied whenever its length, namely SNORM, is at !       least HALF*DELTA. It is also applied if its length is at least 0.1999 !       times DELTA and if a line search of TRSTEP has caused a change to the !       active set. Otherwise there is a branch below to label 530 or 560. ! temp = half * delta if ( xnew ( 1 ) >= half ) temp = 0.1999_wp * delta if ( snorm <= temp ) then delta = half * delta if ( delta <= 1.4_wp * rho ) delta = rho nvala = nvala + 1 nvalb = nvalb + 1 temp = snorm / rho if ( delsav > rho ) temp = one if ( temp >= half ) nvala = zero if ( temp >= tenth ) nvalb = zero if ( delsav > rho ) go to 530 if ( nvala < 5 . and . nvalb < 3 ) go to 530 if ( snorm > zero ) ksave = - 1 go to 560 end if nvala = zero nvalb = zero ! !     Alternatively, KNEW is positive. Then the model step is calculated !       within a trust region of radius DEL, after setting the gradient at !       XBASE and the second derivative parameters of the KNEW-th Lagrange !       function in W(1) to W(N) and in PQW(1) to PQW(NPT), respectively. ! else del = max ( tenth * delta , rho ) do i = 1 , n w ( i ) = bmat ( knew , i ) end do do k = 1 , npt pqw ( k ) = zero end do do j = 1 , nptm temp = zmat ( knew , j ) if ( j < idz ) temp = - temp do k = 1 , npt pqw ( k ) = pqw ( k ) + temp * zmat ( k , j ) end do end do call qmstep ( n , npt , m , amat , b , xpt , xopt , nact , iact , rescon , qfac , kopt , & knew , del , step , w , pqw , w ( np ), w ( np + m ), ifeas ) end if ! !     Set VQUAD to the change to the quadratic model when the move STEP is !       made from XOPT. If STEP is a trust region step, then VQUAD should be !       negative. If it is nonnegative due to rounding errors in this case, !       there is a branch to label 530 to try to improve the model. ! vquad = zero ih = 0 do j = 1 , n vquad = vquad + step ( j ) * gopt ( j ) do i = 1 , j ih = ih + 1 temp = step ( i ) * step ( j ) if ( i == j ) temp = half * temp vquad = vquad + temp * hq ( ih ) end do end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * step ( j ) sp ( npt + k ) = temp end do vquad = vquad + half * pq ( k ) * temp * temp end do if ( ksave == 0 . and . vquad >= zero ) go to 530 ! !     Calculate the next value of the objective function. The difference !       between the actual new value of F and the value predicted by the !       model is recorded in DIFF. ! 220 nf = nf + 1 if ( nf > maxfun ) then nf = nf - 1 if ( iprint > 0 ) print 230 230 format ( / 4 x , 'Return from LINCOA because CALFUN has been' ,& ' called MAXFUN times.' ) go to 600 end if xdiff = zero do i = 1 , n xnew ( i ) = xopt ( i ) + step ( i ) x ( i ) = xbase ( i ) + xnew ( i ) xdiff = xdiff + ( x ( i ) - xsav ( i )) ** 2 end do xdiff = sqrt ( xdiff ) if ( ksave ==- 1 ) xdiff = rho if ( xdiff <= tenth * rho . or . xdiff >= delta + delta ) then ifeas = 0 if ( iprint > 0 ) print 250 250 format ( / 4 x , 'Return from LINCOA because rounding errors' ,& ' prevent reasonable changes to X.' ) go to 600 end if if ( ksave <= 0 ) ifeas = 1 f = real ( ifeas , wp ) call calfun ( n , x , f ) if ( iprint == 3 ) then print 260 , nf , f , ( x ( i ), i = 1 , n ) 260 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( ksave ==- 1 ) go to 600 diff = f - fopt - vquad ! !     If X is feasible, then set DFFALT to the difference between the new !       value of F and the value predicted by the alternative model. ! if ( ifeas == 1 . and . itest < 3 ) then do k = 1 , npt pqw ( k ) = zero w ( k ) = fval ( k ) - fval ( kopt ) end do do j = 1 , nptm sum = zero do i = 1 , npt sum = sum + w ( i ) * zmat ( i , j ) end do if ( j < idz ) sum = - sum do k = 1 , npt pqw ( k ) = pqw ( k ) + sum * zmat ( k , j ) end do end do vqalt = zero do k = 1 , npt sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * step ( j ) end do vqalt = vqalt + sum * w ( k ) vqalt = vqalt + pqw ( k ) * sp ( npt + k ) * ( half * sp ( npt + k ) + sp ( k )) end do dffalt = f - fopt - vqalt end if if ( itest == 3 ) then dffalt = diff itest = 0 end if ! !     Pick the next value of DELTA after a trust region step. ! if ( ksave == 0 ) then ratio = ( f - fopt ) / vquad if ( ratio <= tenth ) then delta = half * delta else if ( ratio <= 0.7_wp ) then delta = max ( half * delta , snorm ) else temp = sqrt ( 2.0_wp ) * delta delta = max ( half * delta , snorm + snorm ) delta = min ( delta , temp ) end if if ( delta <= 1.4_wp * rho ) delta = rho end if ! !     Update BMAT, ZMAT and IDZ, so that the KNEW-th interpolation point !       can be moved. If STEP is a trust region step, then KNEW is zero at !       present, but a positive value is picked by subroutine UPDATE. ! call update ( n , npt , xpt , bmat , zmat , idz , ndim , sp , step , kopt , knew , pqw , w ) if ( knew == 0 ) then if ( iprint > 0 ) print 320 320 format ( / 4 x , & 'Return from LINCOA because the denominator of the updating formula is zero.' ) go to 600 end if ! !     If ITEST is increased to 3, then the next quadratic model is the !       one whose second derivative matrix is least subject to the new !       interpolation conditions. Otherwise the new model is constructed !       by the symmetric Broyden method in the usual way. ! if ( ifeas == 1 ) then itest = itest + 1 if ( abs ( dffalt ) >= tenth * abs ( diff )) itest = 0 end if ! !     Update the second derivatives of the model by the symmetric Broyden !       method, using PQW for the second derivative parameters of the new !       KNEW-th Lagrange function. The contribution from the old parameter !       PQ(KNEW) is included in the second derivative matrix HQ. W is used !       later for the gradient of the new KNEW-th Lagrange function. ! if ( itest < 3 ) then do k = 1 , npt pqw ( k ) = zero end do do j = 1 , nptm temp = zmat ( knew , j ) if ( temp /= zero ) then if ( j < idz ) temp = - temp do k = 1 , npt pqw ( k ) = pqw ( k ) + temp * zmat ( k , j ) end do end if end do ih = 0 do i = 1 , n w ( i ) = bmat ( knew , i ) temp = pq ( knew ) * xpt ( knew , i ) do j = 1 , i ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * xpt ( knew , j ) end do end do pq ( knew ) = zero do k = 1 , npt pq ( k ) = pq ( k ) + diff * pqw ( k ) end do end if ! !     Include the new interpolation point with the corresponding updates of !       SP. Also make the changes of the symmetric Broyden method to GOPT at !       the old XOPT if ITEST is less than 3. ! fval ( knew ) = f sp ( knew ) = sp ( kopt ) + sp ( npt + kopt ) ssq = zero do i = 1 , n xpt ( knew , i ) = xnew ( i ) ssq = ssq + step ( i ) ** 2 end do sp ( npt + knew ) = sp ( npt + kopt ) + ssq if ( itest < 3 ) then do k = 1 , npt temp = pqw ( k ) * sp ( k ) do i = 1 , n w ( i ) = w ( i ) + temp * xpt ( k , i ) end do end do do i = 1 , n gopt ( i ) = gopt ( i ) + diff * w ( i ) end do end if ! !     Update FOPT, XSAV, XOPT, KOPT, RESCON and SP if the new F is the !       least calculated value so far with a feasible vector of variables. ! if ( f < fopt . and . ifeas == 1 ) then fopt = f do j = 1 , n xsav ( j ) = x ( j ) xopt ( j ) = xnew ( j ) end do kopt = knew snorm = sqrt ( ssq ) do j = 1 , m if ( rescon ( j ) >= delta + snorm ) then rescon ( j ) = snorm - rescon ( j ) else rescon ( j ) = rescon ( j ) + snorm if ( rescon ( j ) + delta > zero ) then temp = b ( j ) do i = 1 , n temp = temp - xopt ( i ) * amat ( i , j ) end do temp = max ( temp , zero ) if ( temp >= delta ) temp = - temp rescon ( j ) = temp end if end if end do do k = 1 , npt sp ( k ) = sp ( k ) + sp ( npt + k ) end do ! !     Also revise GOPT when symmetric Broyden updating is applied. ! if ( itest < 3 ) then ih = 0 do j = 1 , n do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * step ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * step ( j ) end do end do do k = 1 , npt temp = pq ( k ) * sp ( npt + k ) do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if end if ! !     Replace the current model by the least Frobenius norm interpolant if !       this interpolant gives substantial reductions in the predictions !       of values of F at feasible points. ! if ( itest == 3 ) then do k = 1 , npt pq ( k ) = zero w ( k ) = fval ( k ) - fval ( kopt ) end do do j = 1 , nptm sum = zero do i = 1 , npt sum = sum + w ( i ) * zmat ( i , j ) end do if ( j < idz ) sum = - sum do k = 1 , npt pq ( k ) = pq ( k ) + sum * zmat ( k , j ) end do end do do j = 1 , n gopt ( j ) = zero do i = 1 , npt gopt ( j ) = gopt ( j ) + w ( i ) * bmat ( i , j ) end do end do do k = 1 , npt temp = pq ( k ) * sp ( k ) do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do do ih = 1 , nh hq ( ih ) = zero end do end if ! !     If a trust region step has provided a sufficient decrease in F, then !       branch for another trust region calculation. Every iteration that !       takes a model step is followed by an attempt to take a trust region !       step. ! knew = 0 if ( ksave > 0 ) go to 20 if ( ratio >= tenth ) go to 20 ! !     Alternatively, find out if the interpolation points are close enough !       to the best point so far. ! 530 distsq = max ( delta * delta , 4.0_wp * rho * rho ) do k = 1 , npt sum = zero do j = 1 , n sum = sum + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( sum > distsq ) then knew = k distsq = sum end if end do ! !     If KNEW is positive, then branch back for the next iteration, which !       will generate a \"model step\". Otherwise, if the current iteration !       has reduced F, or if DELTA was above its lower bound when the last !       trust region step was calculated, then try a \"trust region\" step !       instead. ! if ( knew > 0 ) go to 20 knew = 0 if ( fopt < fsave ) go to 20 if ( delsav > rho ) go to 20 ! !     The calculations with the current value of RHO are complete. !       Pick the next value of RHO. ! 560 if ( rho > rhoend ) then delta = half * rho if ( rho > 25 0.0_wp * rhoend ) then rho = tenth * rho else if ( rho <= 1 6.0_wp * rhoend ) then rho = rhoend else rho = sqrt ( rho * rhoend ) end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) print 570 570 format ( 5 x ) print 580 , rho , nf 580 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 590 , fopt , ( xbase ( i ) + xopt ( i ), i = 1 , n ) 590 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if go to 10 end if ! !     Return from the calculation, after branching to label 220 for another !       Newton-Raphson step if it has not been tried before. ! if ( ksave ==- 1 ) go to 220 600 if ( fopt <= f . or . ifeas == 0 ) then do i = 1 , n x ( i ) = xsav ( i ) end do f = fopt end if if ( iprint >= 1 ) then print 620 , nf 620 format ( / 4 x , 'At the return from LINCOA' , 5 x ,& 'Number of function values =' , i6 ) print 590 , f , ( x ( i ), i = 1 , n ) end if w ( 1 ) = f w ( 2 ) = real ( nf , wp ) + half end subroutine lincob subroutine getact ( n , m , amat , b , nact , iact , qfac , rfac , snorm , resnew , resact , g , & dw , vlam , w ) implicit real ( wp ) ( a - h , o - z ) dimension amat ( n , * ), b ( * ), iact ( * ), qfac ( n , * ), rfac ( * ), resnew ( * ), & resact ( * ), g ( * ), dw ( * ), vlam ( * ), w ( * ) ! !     N, M, AMAT, B, NACT, IACT, QFAC and RFAC are the same as the terms !       with these names in SUBROUTINE LINCOB. The current values must be !       set on entry. NACT, IACT, QFAC and RFAC are kept up to date when !       GETACT changes the current active set. !     SNORM, RESNEW, RESACT, G and DW are the same as the terms with these !       names in SUBROUTINE TRSTEP. The elements of RESNEW and RESACT are !       also kept up to date. !     VLAM and W are used for working space, the vector VLAM being reserved !       for the Lagrange multipliers of the calculation. Their lengths must !       be at least N. !     The main purpose of GETACT is to pick the current active set. It is !       defined by the property that the projection of -G into the space !       orthogonal to the active constraint normals is as large as possible, !       subject to this projected steepest descent direction moving no closer !       to the boundary of every constraint whose current residual is at most !       0.2*SNORM. On return, the settings in NACT, IACT, QFAC and RFAC are !       all appropriate to this choice of active set. !     Occasionally this projected direction is zero, and then the final value !       of W(1) is set to zero. Otherwise, the direction itself is returned !       in DW, and W(1) is set to the square of the length of the direction. ! !     Set some constants and a temporary VLAM. ! real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: tiny = 1.0e-60_wp real ( wp ), parameter :: zero = 0.0_wp tdel = 0.2_wp * snorm ddsav = zero do i = 1 , n ddsav = ddsav + g ( i ) ** 2 vlam ( i ) = zero end do ddsav = ddsav + ddsav ! !     Set the initial QFAC to the identity matrix in the case NACT=0. ! if ( nact == 0 ) then do i = 1 , n do j = 1 , n qfac ( i , j ) = zero end do qfac ( i , i ) = one end do go to 100 end if ! !     Remove any constraints from the initial active set whose residuals !       exceed TDEL. ! iflag = 1 ic = nact 40 if ( resact ( ic ) > tdel ) go to 800 50 ic = ic - 1 if ( ic > 0 ) go to 40 ! !     Remove any constraints from the initial active set whose Lagrange !       multipliers are nonnegative, and set the surviving multipliers. ! iflag = 2 60 if ( nact == 0 ) go to 100 ic = nact 70 temp = zero do i = 1 , n temp = temp + qfac ( i , ic ) * g ( i ) end do idiag = ( ic * ic + ic ) / 2 if ( ic < nact ) then jw = idiag + ic do j = ic + 1 , nact temp = temp - rfac ( jw ) * vlam ( j ) jw = jw + j end do end if if ( temp >= zero ) go to 800 vlam ( ic ) = temp / rfac ( idiag ) ic = ic - 1 if ( ic > 0 ) go to 70 ! !     Set the new search direction D. Terminate if the 2-norm of D is zero !       or does not decrease, or if NACT=N holds. The situation NACT=N !       occurs for sufficiently large SNORM if the origin is in the convex !       hull of the constraint gradients. ! 100 if ( nact == n ) go to 290 do j = nact + 1 , n w ( j ) = zero do i = 1 , n w ( j ) = w ( j ) + qfac ( i , j ) * g ( i ) end do end do dd = zero do i = 1 , n dw ( i ) = zero do j = nact + 1 , n dw ( i ) = dw ( i ) - w ( j ) * qfac ( i , j ) end do dd = dd + dw ( i ) ** 2 end do if ( dd >= ddsav ) go to 290 if ( dd == zero ) go to 300 ddsav = dd dnorm = sqrt ( dd ) ! !     Pick the next integer L or terminate, a positive value of L being !       the index of the most violated constraint. The purpose of CTOL !       below is to estimate whether a positive value of VIOLMX may be !       due to computer rounding errors. ! l = 0 if ( m > 0 ) then test = dnorm / snorm violmx = zero do j = 1 , m if ( resnew ( j ) > zero . and . resnew ( j ) <= tdel ) then sum = zero do i = 1 , n sum = sum + amat ( i , j ) * dw ( i ) end do if ( sum > test * resnew ( j )) then if ( sum > violmx ) then l = j violmx = sum end if end if end if end do ctol = zero temp = 0.01_wp * dnorm if ( violmx > zero . and . violmx < temp ) then if ( nact > 0 ) then do k = 1 , nact j = iact ( k ) sum = zero do i = 1 , n sum = sum + dw ( i ) * amat ( i , j ) end do ctol = max ( ctol , abs ( sum )) end do end if end if end if w ( 1 ) = one if ( l == 0 ) go to 300 if ( violmx <= 1 0.0_wp * ctol ) go to 300 ! !     Apply Givens rotations to the last (N-NACT) columns of QFAC so that !       the first (NACT+1) columns of QFAC are the ones required for the !       addition of the L-th constraint, and add the appropriate column !       to RFAC. ! nactp = nact + 1 idiag = ( nactp * nactp - nactp ) / 2 rdiag = zero do j = n , 1 , - 1 sprod = zero do i = 1 , n sprod = sprod + qfac ( i , j ) * amat ( i , l ) end do if ( j <= nact ) then rfac ( idiag + j ) = sprod else if ( abs ( rdiag ) <= 1.0e-20_wp * abs ( sprod )) then rdiag = sprod else temp = sqrt ( sprod * sprod + rdiag * rdiag ) cosv = sprod / temp sinv = rdiag / temp rdiag = temp do i = 1 , n temp = cosv * qfac ( i , j ) + sinv * qfac ( i , j + 1 ) qfac ( i , j + 1 ) = - sinv * qfac ( i , j ) + cosv * qfac ( i , j + 1 ) qfac ( i , j ) = temp end do end if end if end do if ( rdiag < zero ) then do i = 1 , n qfac ( i , nactp ) = - qfac ( i , nactp ) end do end if rfac ( idiag + nactp ) = abs ( rdiag ) nact = nactp iact ( nact ) = l resact ( nact ) = resnew ( l ) vlam ( nact ) = zero resnew ( l ) = zero ! !     Set the components of the vector VMU in W. ! 220 w ( nact ) = one / rfac (( nact * nact + nact ) / 2 ) ** 2 if ( nact > 1 ) then do i = nact - 1 , 1 , - 1 idiag = ( i * i + i ) / 2 jw = idiag + i sum = zero do j = i + 1 , nact sum = sum - rfac ( jw ) * w ( j ) jw = jw + j end do w ( i ) = sum / rfac ( idiag ) end do end if ! !     Calculate the multiple of VMU to subtract from VLAM, and update VLAM. ! vmult = violmx ic = 0 j = 1 250 if ( j < nact ) then if ( vlam ( j ) >= vmult * w ( j )) then ic = j vmult = vlam ( j ) / w ( j ) end if j = j + 1 go to 250 end if do j = 1 , nact vlam ( j ) = vlam ( j ) - vmult * w ( j ) end do if ( ic > 0 ) vlam ( ic ) = zero violmx = max ( violmx - vmult , zero ) if ( ic == 0 ) violmx = zero ! !     Reduce the active set if necessary, so that all components of the !       new VLAM are negative, with resetting of the residuals of the !       constraints that become inactive. ! iflag = 3 ic = nact 270 if ( vlam ( ic ) < zero ) go to 280 resnew ( iact ( ic )) = max ( resact ( ic ), tiny ) go to 800 280 ic = ic - 1 if ( ic > 0 ) go to 270 ! !     Calculate the next VMU if VIOLMX is positive. Return if NACT=N holds, !       as then the active constraints imply D=0. Otherwise, go to label !       100, to calculate the new D and to test for termination. ! if ( violmx > zero ) go to 220 if ( nact < n ) go to 100 290 dd = zero 300 w ( 1 ) = dd return ! !     These instructions rearrange the active constraints so that the new !       value of IACT(NACT) is the old value of IACT(IC). A sequence of !       Givens rotations is applied to the current QFAC and RFAC. Then NACT !       is reduced by one. ! 800 resnew ( iact ( ic )) = max ( resact ( ic ), tiny ) jc = ic 810 if ( jc < nact ) then jcp = jc + 1 idiag = jc * jcp / 2 jw = idiag + jcp temp = sqrt ( rfac ( jw - 1 ) ** 2 + rfac ( jw ) ** 2 ) cval = rfac ( jw ) / temp sval = rfac ( jw - 1 ) / temp rfac ( jw - 1 ) = sval * rfac ( idiag ) rfac ( jw ) = cval * rfac ( idiag ) rfac ( idiag ) = temp if ( jcp < nact ) then do j = jcp + 1 , nact temp = sval * rfac ( jw + jc ) + cval * rfac ( jw + jcp ) rfac ( jw + jcp ) = cval * rfac ( jw + jc ) - sval * rfac ( jw + jcp ) rfac ( jw + jc ) = temp jw = jw + j end do end if jdiag = idiag - jc do i = 1 , n if ( i < jc ) then temp = rfac ( idiag + i ) rfac ( idiag + i ) = rfac ( jdiag + i ) rfac ( jdiag + i ) = temp end if temp = sval * qfac ( i , jc ) + cval * qfac ( i , jcp ) qfac ( i , jcp ) = cval * qfac ( i , jc ) - sval * qfac ( i , jcp ) qfac ( i , jc ) = temp end do iact ( jc ) = iact ( jcp ) resact ( jc ) = resact ( jcp ) vlam ( jc ) = vlam ( jcp ) jc = jcp go to 810 end if nact = nact - 1 go to ( 50 , 60 , 280 ), iflag end subroutine getact subroutine prelim ( n , npt , m , amat , b , x , rhobeg , iprint , xbase , xpt , fval , xsav , & xopt , gopt , kopt , hq , pq , bmat , zmat , idz , ndim , sp , rescon , step , pqw , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension amat ( n , * ), b ( * ), x ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xsav ( * ),& xopt ( * ), gopt ( * ), hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sp ( * ), rescon ( * ),& step ( * ), pqw ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, M, AMAT, B, X, RHOBEG, IPRINT, XBASE, XPT, FVAL, !       XSAV, XOPT, GOPT, HQ, PQ, BMAT, ZMAT, NDIM, SP and RESCON are the !       same as the corresponding arguments in SUBROUTINE LINCOB. !     KOPT is set to the integer such that XPT(KOPT,.) is the initial trust !       region centre. !     IDZ is going to be set to one, so that every element of Diag(DZ) is !       one in the product ZMAT times Diag(DZ) times ZMAT&#94;T, which is the !       factorization of the leading NPT by NPT submatrix of H. !     STEP, PQW and W are used for working space, the arrays STEP and PQW !       being taken from LINCOB. The length of W must be at least N+NPT. ! !     SUBROUTINE PRELIM provides the elements of XBASE, XPT, BMAT and ZMAT !       for the first iteration, an important feature being that, if any of !       of the columns of XPT is an infeasible point, then the largest of !       the constraint violations there is at least 0.2*RHOBEG. It also sets !       the initial elements of FVAL, XOPT, GOPT, HQ, PQ, SP and RESCON. ! !     Set some constants. ! real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: zero = 0.0_wp nptm = npt - n - 1 rhosq = rhobeg * rhobeg recip = one / rhosq reciq = sqrt ( half ) / rhosq test = 0.2_wp * rhobeg idz = 1 kbase = 1 ! !     Set the initial elements of XPT, BMAT, SP and ZMAT to zero. ! do j = 1 , n xbase ( j ) = x ( j ) do k = 1 , npt xpt ( k , j ) = zero end do do i = 1 , ndim bmat ( i , j ) = zero end do end do do k = 1 , npt sp ( k ) = zero do j = 1 , npt - n - 1 zmat ( k , j ) = zero end do end do ! !     Set the nonzero coordinates of XPT(K,.), K=1,2,...,min[2*N+1,NPT], !       but they may be altered later to make a constraint violation !       sufficiently large. The initial nonzero elements of BMAT and of !       the first min[N,NPT-N-1] columns of ZMAT are set also. ! do j = 1 , n xpt ( j + 1 , j ) = rhobeg if ( j < npt - n ) then jp = n + j + 1 xpt ( jp , j ) = - rhobeg bmat ( j + 1 , j ) = half / rhobeg bmat ( jp , j ) = - half / rhobeg zmat ( 1 , j ) = - reciq - reciq zmat ( j + 1 , j ) = reciq zmat ( jp , j ) = reciq else bmat ( 1 , j ) = - one / rhobeg bmat ( j + 1 , j ) = one / rhobeg bmat ( npt + j , j ) = - half * rhosq end if end do ! !     Set the remaining initial nonzero elements of XPT and ZMAT when the !       number of interpolation points exceeds 2*N+1. ! if ( npt > 2 * n + 1 ) then do k = n + 1 , npt - n - 1 itemp = ( k - 1 ) / n ipt = k - itemp * n jpt = ipt + itemp if ( jpt > n ) jpt = jpt - n xpt ( n + k + 1 , ipt ) = rhobeg xpt ( n + k + 1 , jpt ) = rhobeg zmat ( 1 , k ) = recip zmat ( ipt + 1 , k ) = - recip zmat ( jpt + 1 , k ) = - recip zmat ( n + k + 1 , k ) = recip end do end if ! !     Update the constraint right hand sides to allow for the shift XBASE. ! if ( m > 0 ) then do j = 1 , m temp = zero do i = 1 , n temp = temp + amat ( i , j ) * xbase ( i ) end do b ( j ) = b ( j ) - temp end do end if ! !     Go through the initial points, shifting every infeasible point if !       necessary so that its constraint violation is at least 0.2*RHOBEG. ! do nf = 1 , npt feas = one bigv = zero j = 0 80 j = j + 1 if ( j <= m . and . nf >= 2 ) then resid = - b ( j ) do i = 1 , n resid = resid + xpt ( nf , i ) * amat ( i , j ) end do if ( resid <= bigv ) go to 80 bigv = resid jsav = j if ( resid <= test ) then feas = - one go to 80 end if feas = zero end if if ( feas < zero ) then do i = 1 , n step ( i ) = xpt ( nf , i ) + ( test - bigv ) * amat ( i , jsav ) end do do k = 1 , npt sp ( npt + k ) = zero do j = 1 , n sp ( npt + k ) = sp ( npt + k ) + xpt ( k , j ) * step ( j ) end do end do call update ( n , npt , xpt , bmat , zmat , idz , ndim , sp , step , kbase , nf , pqw , w ) do i = 1 , n xpt ( nf , i ) = step ( i ) end do end if ! !     Calculate the objective function at the current interpolation point, !       and set KOPT to the index of the first trust region centre. ! do j = 1 , n x ( j ) = xbase ( j ) + xpt ( nf , j ) end do f = feas call calfun ( n , x , f ) if ( iprint == 3 ) then print 140 , nf , f , ( x ( i ), i = 1 , n ) 140 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( nf == 1 ) then kopt = 1 else if ( f < fval ( kopt ) . and . feas > zero ) then kopt = nf end if fval ( nf ) = f end do ! !     Set PQ for the first quadratic model. ! do j = 1 , nptm w ( j ) = zero do k = 1 , npt w ( j ) = w ( j ) + zmat ( k , j ) * fval ( k ) end do end do do k = 1 , npt pq ( k ) = zero do j = 1 , nptm pq ( k ) = pq ( k ) + zmat ( k , j ) * w ( j ) end do end do ! !     Set XOPT, SP, GOPT and HQ for the first quadratic model. ! do j = 1 , n xopt ( j ) = xpt ( kopt , j ) xsav ( j ) = xbase ( j ) + xopt ( j ) gopt ( j ) = zero end do do k = 1 , npt sp ( k ) = zero do j = 1 , n sp ( k ) = sp ( k ) + xpt ( k , j ) * xopt ( j ) end do temp = pq ( k ) * sp ( k ) do j = 1 , n gopt ( j ) = gopt ( j ) + fval ( k ) * bmat ( k , j ) + temp * xpt ( k , j ) end do end do do i = 1 , ( n * n + n ) / 2 hq ( i ) = zero end do ! !     Set the initial elements of RESCON. ! do j = 1 , m temp = b ( j ) do i = 1 , n temp = temp - xopt ( i ) * amat ( i , j ) end do temp = max ( temp , zero ) if ( temp >= rhobeg ) temp = - temp rescon ( j ) = temp end do end subroutine prelim subroutine qmstep ( n , npt , m , amat , b , xpt , xopt , nact , iact , rescon , qfac , kopt , & knew , del , step , gl , pqw , rstat , w , ifeas ) implicit real ( wp ) ( a - h , o - z ) dimension amat ( n , * ), b ( * ), xpt ( npt , * ), xopt ( * ), iact ( * ), rescon ( * ), & qfac ( n , * ), step ( * ), gl ( * ), pqw ( * ), rstat ( * ), w ( * ) ! !     N, NPT, M, AMAT, B, XPT, XOPT, NACT, IACT, RESCON, QFAC, KOPT are the !       same as the terms with these names in SUBROUTINE LINCOB. !     KNEW is the index of the interpolation point that is going to be moved. !     DEL is the current restriction on the length of STEP, which is never !       greater than the current trust region radius DELTA. !     STEP will be set to the required step from XOPT to the new point. !     GL must be set on entry to the gradient of LFUNC at XBASE, where LFUNC !       is the KNEW-th Lagrange function. It is used also for some other !       gradients of LFUNC. !     PQW provides the second derivative parameters of LFUNC. !     RSTAT and W are used for working space. Their lengths must be at least !       M and N, respectively. RSTAT(J) is set to -1.0, 0.0, or 1.0 if the !       J-th constraint is irrelevant, active, or both inactive and relevant, !       respectively. !     IFEAS will be set to 0 or 1 if XOPT+STEP is infeasible or feasible. ! !     STEP is chosen to provide a relatively large value of the modulus of !       LFUNC(XOPT+STEP), subject to ||STEP|| .LE. DEL. A projected STEP is !       calculated too, within the trust region, that does not alter the !       residuals of the active constraints. The projected step is preferred !       if its value of | LFUNC(XOPT+STEP) | is at least one fifth of the !       original one, but the greatest violation of a linear constraint must !       be at least 0.2*DEL, in order to keep the interpolation points apart. !       The remedy when the maximum constraint violation is too small is to !       restore the original step, which is perturbed if necessary so that !       its maximum constraint violation becomes 0.2*DEL. ! !     Set some constants. ! real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: tenth = 0.1_wp real ( wp ), parameter :: zero = 0.0_wp test = 0.2_wp * del ! !     Replace GL by the gradient of LFUNC at the trust region centre, and !       set the elements of RSTAT. ! do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = pqw ( k ) * temp do i = 1 , n gl ( i ) = gl ( i ) + temp * xpt ( k , i ) end do end do if ( m > 0 ) then do j = 1 , m rstat ( j ) = one if ( abs ( rescon ( j )) >= del ) rstat ( j ) = - one end do do k = 1 , nact rstat ( iact ( k )) = zero end do end if ! !     Find the greatest modulus of LFUNC on a line through XOPT and !       another interpolation point within the trust region. ! iflag = 0 vbig = zero do k = 1 , npt if ( k == kopt ) cycle ss = zero sp = zero do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) ss = ss + temp * temp sp = sp + gl ( i ) * temp end do stp = - del / sqrt ( ss ) if ( k == knew ) then if ( sp * ( sp - one ) < zero ) stp = - stp vlag = abs ( stp * sp ) + stp * stp * abs ( sp - one ) else vlag = abs ( stp * ( one - stp ) * sp ) end if if ( vlag > vbig ) then ksav = k stpsav = stp vbig = vlag end if end do ! !     Set STEP to the move that gives the greatest modulus calculated above. !       This move may be replaced by a steepest ascent step from XOPT. ! gg = zero do i = 1 , n gg = gg + gl ( i ) ** 2 step ( i ) = stpsav * ( xpt ( ksav , i ) - xopt ( i )) end do vgrad = del * sqrt ( gg ) if ( vgrad <= tenth * vbig ) go to 220 ! !     Make the replacement if it provides a larger value of VBIG. ! ghg = zero do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * gl ( j ) end do ghg = ghg + pqw ( k ) * temp * temp end do vnew = vgrad + abs ( half * del * del * ghg / gg ) if ( vnew > vbig ) then vbig = vnew stp = del / sqrt ( gg ) if ( ghg < zero ) stp = - stp do i = 1 , n step ( i ) = stp * gl ( i ) end do end if if ( nact == 0 . or . nact == n ) go to 220 ! !     Overwrite GL by its projection. Then set VNEW to the greatest !       value of |LFUNC| on the projected gradient from XOPT subject to !       the trust region bound. If VNEW is sufficiently large, then STEP !       may be changed to a move along the projected gradient. ! do k = nact + 1 , n w ( k ) = zero do i = 1 , n w ( k ) = w ( k ) + gl ( i ) * qfac ( i , k ) end do end do gg = zero do i = 1 , n gl ( i ) = zero do k = nact + 1 , n gl ( i ) = gl ( i ) + qfac ( i , k ) * w ( k ) end do gg = gg + gl ( i ) ** 2 end do vgrad = del * sqrt ( gg ) if ( vgrad <= tenth * vbig ) go to 220 ghg = zero do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * gl ( j ) end do ghg = ghg + pqw ( k ) * temp * temp end do vnew = vgrad + abs ( half * del * del * ghg / gg ) ! !     Set W to the possible move along the projected gradient. ! stp = del / sqrt ( gg ) if ( ghg < zero ) stp = - stp ww = zero do i = 1 , n w ( i ) = stp * gl ( i ) ww = ww + w ( i ) ** 2 end do ! !     Set STEP to W if W gives a sufficiently large value of the modulus !       of the Lagrange function, and if W either preserves feasibility !       or gives a constraint violation of at least 0.2*DEL. The purpose !       of CTOL below is to provide a check on feasibility that includes !       a tolerance for contributions from computer rounding errors. ! if ( vnew / vbig >= 0.2_wp ) then ifeas = 1 bigv = zero j = 0 170 j = j + 1 if ( j <= m ) then if ( rstat ( j ) == one ) then temp = - rescon ( j ) do i = 1 , n temp = temp + w ( i ) * amat ( i , j ) end do bigv = max ( bigv , temp ) end if if ( bigv < test ) go to 170 ifeas = 0 end if ctol = zero temp = 0.01_wp * sqrt ( ww ) if ( bigv > zero . and . bigv < temp ) then do k = 1 , nact j = iact ( k ) sum = zero do i = 1 , n sum = sum + w ( i ) * amat ( i , j ) end do ctol = max ( ctol , abs ( sum )) end do end if if ( bigv <= 1 0.0_wp * ctol . or . bigv >= test ) then do i = 1 , n step ( i ) = w ( i ) end do return end if end if ! !     Calculate the greatest constraint violation at XOPT+STEP with STEP at !       its original value. Modify STEP if this violation is unacceptable. ! 220 ifeas = 1 bigv = zero resmax = zero j = 0 230 j = j + 1 if ( j <= m ) then if ( rstat ( j ) < zero ) go to 230 temp = - rescon ( j ) do i = 1 , n temp = temp + step ( i ) * amat ( i , j ) end do resmax = max ( resmax , temp ) if ( temp < test ) then if ( temp <= bigv ) go to 230 bigv = temp jsav = j ifeas = - 1 go to 230 end if ifeas = 0 end if if ( ifeas ==- 1 ) then do i = 1 , n step ( i ) = step ( i ) + ( test - bigv ) * amat ( i , jsav ) end do ifeas = 0 end if ! !     Return the calculated STEP and the value of IFEAS. ! end subroutine qmstep subroutine trstep ( n , npt , m , amat , b , xpt , hq , pq , nact , iact , rescon , qfac , rfac , & snorm , step , g , resnew , resact , d , dw , w ) implicit real ( wp ) ( a - h , o - z ) dimension amat ( n , * ), b ( * ), xpt ( npt , * ), hq ( * ), pq ( * ), iact ( * ), rescon ( * ), & qfac ( n , * ), rfac ( * ), step ( * ), g ( * ), resnew ( * ), resact ( * ), d ( * ), dw ( * ), w & ( * ) ! !     N, NPT, M, AMAT, B, XPT, HQ, PQ, NACT, IACT, RESCON, QFAC and RFAC !       are the same as the terms with these names in LINCOB. If RESCON(J) !       is negative, then |RESCON(J)| must be no less than the trust region !       radius, so that the J-th constraint can be ignored. !     SNORM is set to the trust region radius DELTA initially. On the !       return, however, it is the length of the calculated STEP, which is !       set to zero if the constraints do not allow a long enough step. !     STEP is the total calculated step so far from the trust region centre, !       its final value being given by the sequence of CG iterations, which !       terminate if the trust region boundary is reached. !     G must be set on entry to the gradient of the quadratic model at the !       trust region centre. It is used as working space, however, and is !       always the gradient of the model at the current STEP, except that !       on return the value of G(1) is set to ONE instead of to ZERO if !       and only if GETACT is called more than once. !     RESNEW, RESACT, D, DW and W are used for working space. A negative !       value of RESNEW(J) indicates that the J-th constraint does not !       restrict the CG steps of the current trust region calculation, a !       zero value of RESNEW(J) indicates that the J-th constraint is active, !       and otherwise RESNEW(J) is set to the greater of TINY and the actual !       residual of the J-th constraint for the current STEP. RESACT holds !       the residuals of the active constraints, which may be positive. !       D is the search direction of each line search. DW is either another !       search direction or the change in gradient along D. The length of W !       must be at least MAX[M,2*N]. ! !     Set some numbers for the conjugate gradient iterations. ! real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: tiny = 1.0e-60_wp real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: ctest = 0.01_wp snsq = snorm * snorm ! !     Set the initial elements of RESNEW, RESACT and STEP. ! if ( m > 0 ) then do j = 1 , m resnew ( j ) = rescon ( j ) if ( rescon ( j ) >= snorm ) then resnew ( j ) = - one else if ( rescon ( j ) >= zero ) then resnew ( j ) = max ( resnew ( j ), tiny ) end if end do if ( nact > 0 ) then do k = 1 , nact resact ( k ) = rescon ( iact ( k )) resnew ( iact ( k )) = zero end do end if end if do i = 1 , n step ( i ) = zero end do ss = zero reduct = zero ncall = 0 ! !     GETACT picks the active set for the current STEP. It also sets DW to !       the vector closest to -G that is orthogonal to the normals of the !       active constraints. DW is scaled to have length 0.2*SNORM, as then !       a move of DW from STEP is allowed by the linear constraints. ! 40 ncall = ncall + 1 call getact ( n , m , amat , b , nact , iact , qfac , rfac , snorm , resnew , resact , g , dw , & w , w ( n + 1 )) if ( w ( n + 1 ) == zero ) go to 320 scale = 0.2_wp * snorm / sqrt ( w ( n + 1 )) do i = 1 , n dw ( i ) = scale * dw ( i ) end do ! !     If the modulus of the residual of an active constraint is substantial, !       then set D to the shortest move from STEP to the boundaries of the !       active constraints. ! resmax = zero if ( nact > 0 ) then do k = 1 , nact resmax = max ( resmax , resact ( k )) end do end if gamma = zero if ( resmax > 1.0e-4_wp * snorm ) then ir = 0 do k = 1 , nact temp = resact ( k ) if ( k >= 2 ) then do i = 1 , k - 1 ir = ir + 1 temp = temp - rfac ( ir ) * w ( i ) end do end if ir = ir + 1 w ( k ) = temp / rfac ( ir ) end do do i = 1 , n d ( i ) = zero do k = 1 , nact d ( i ) = d ( i ) + w ( k ) * qfac ( i , k ) end do end do ! !     The vector D that has just been calculated is also the shortest move !       from STEP+DW to the boundaries of the active constraints. Set GAMMA !       to the greatest steplength of this move that satisfies the trust !       region bound. ! rhs = snsq ds = zero dd = zero do i = 1 , n sum = step ( i ) + dw ( i ) rhs = rhs - sum * sum ds = ds + d ( i ) * sum dd = dd + d ( i ) ** 2 end do if ( rhs > zero ) then temp = sqrt ( ds * ds + dd * rhs ) if ( ds <= zero ) then gamma = ( temp - ds ) / dd else gamma = rhs / ( temp + ds ) end if end if ! !     Reduce the steplength GAMMA if necessary so that the move along D !       also satisfies the linear constraints. ! j = 0 110 if ( gamma > zero ) then j = j + 1 if ( resnew ( j ) > zero ) then ad = zero adw = zero do i = 1 , n ad = ad + amat ( i , j ) * d ( i ) adw = adw + amat ( i , j ) * dw ( i ) end do if ( ad > zero ) then temp = max (( resnew ( j ) - adw ) / ad , zero ) gamma = min ( gamma , temp ) end if end if if ( j < m ) go to 110 end if gamma = min ( gamma , one ) end if ! !     Set the next direction for seeking a reduction in the model function !       subject to the trust region bound and the linear constraints. ! if ( gamma <= zero ) then do i = 1 , n d ( i ) = dw ( i ) end do icount = nact else do i = 1 , n d ( i ) = dw ( i ) + gamma * d ( i ) end do icount = nact - 1 end if alpbd = one ! !     Set ALPHA to the steplength from STEP along D to the trust region !       boundary. Return if the first derivative term of this step is !       sufficiently small or if no further progress is possible. ! 150 icount = icount + 1 rhs = snsq - ss if ( rhs <= zero ) go to 320 dg = zero ds = zero dd = zero do i = 1 , n dg = dg + d ( i ) * g ( i ) ds = ds + d ( i ) * step ( i ) dd = dd + d ( i ) ** 2 end do if ( dg >= zero ) go to 320 temp = sqrt ( rhs * dd + ds * ds ) if ( ds <= zero ) then alpha = ( temp - ds ) / dd else alpha = rhs / ( temp + ds ) end if if ( - alpha * dg <= ctest * reduct ) go to 320 ! !     Set DW to the change in gradient along D. ! ih = 0 do j = 1 , n dw ( j ) = zero do i = 1 , j ih = ih + 1 if ( i < j ) dw ( j ) = dw ( j ) + hq ( ih ) * d ( i ) dw ( i ) = dw ( i ) + hq ( ih ) * d ( j ) end do end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * d ( j ) end do temp = pq ( k ) * temp do i = 1 , n dw ( i ) = dw ( i ) + temp * xpt ( k , i ) end do end do ! !     Set DGD to the curvature of the model along D. Then reduce ALPHA if !       necessary to the value that minimizes the model. ! dgd = zero do i = 1 , n dgd = dgd + d ( i ) * dw ( i ) end do alpht = alpha if ( dg + alpha * dgd > zero ) then alpha = - dg / dgd end if ! !     Make a further reduction in ALPHA if necessary to preserve feasibility, !       and put some scalar products of D with constraint gradients in W. ! alphm = alpha jsav = 0 if ( m > 0 ) then do j = 1 , m ad = zero if ( resnew ( j ) > zero ) then do i = 1 , n ad = ad + amat ( i , j ) * d ( i ) end do if ( alpha * ad > resnew ( j )) then alpha = resnew ( j ) / ad jsav = j end if end if w ( j ) = ad end do end if alpha = max ( alpha , alpbd ) alpha = min ( alpha , alphm ) if ( icount == nact ) alpha = min ( alpha , one ) ! !     Update STEP, G, RESNEW, RESACT and REDUCT. ! ss = zero do i = 1 , n step ( i ) = step ( i ) + alpha * d ( i ) ss = ss + step ( i ) ** 2 g ( i ) = g ( i ) + alpha * dw ( i ) end do if ( m > 0 ) then do j = 1 , m if ( resnew ( j ) > zero ) then resnew ( j ) = max ( resnew ( j ) - alpha * w ( j ), tiny ) end if end do end if if ( icount == nact . and . nact > 0 ) then do k = 1 , nact resact ( k ) = ( one - gamma ) * resact ( k ) end do end if reduct = reduct - alpha * ( dg + half * alpha * dgd ) ! !     Test for termination. Branch to label 40 if there is a new active !       constraint and if the distance from STEP to the trust region !       boundary is at least 0.2*SNORM. ! if ( alpha == alpht ) go to 320 temp = - alphm * ( dg + half * alphm * dgd ) if ( temp <= ctest * reduct ) go to 320 if ( jsav > 0 ) then if ( ss <= 0.64_wp * snsq ) go to 40 go to 320 end if if ( icount == n ) go to 320 ! !     Calculate the next search direction, which is conjugate to the !       previous one except in the case ICOUNT=NACT. ! if ( nact > 0 ) then do j = nact + 1 , n w ( j ) = zero do i = 1 , n w ( j ) = w ( j ) + g ( i ) * qfac ( i , j ) end do end do do i = 1 , n temp = zero do j = nact + 1 , n temp = temp + qfac ( i , j ) * w ( j ) end do w ( n + i ) = temp end do else do i = 1 , n w ( n + i ) = g ( i ) end do end if if ( icount == nact ) then beta = zero else wgd = zero do i = 1 , n wgd = wgd + w ( n + i ) * dw ( i ) end do beta = wgd / dgd end if do i = 1 , n d ( i ) = - w ( n + i ) + beta * d ( i ) end do alpbd = zero go to 150 ! !     Return from the subroutine. ! 320 snorm = zero if ( reduct > zero ) snorm = sqrt ( ss ) g ( 1 ) = zero if ( ncall > 1 ) g ( 1 ) = one end subroutine trstep subroutine update ( n , npt , xpt , bmat , zmat , idz , ndim , sp , step , kopt , knew , vlag , w ) implicit real ( wp ) ( a - h , o - z ) dimension xpt ( npt , * ), bmat ( ndim , * ), zmat ( npt , * ), sp ( * ), step ( * ), vlag ( * ), & w ( * ) ! !     The arguments N, NPT, XPT, BMAT, ZMAT, IDZ, NDIM ,SP and STEP are !       identical to the corresponding arguments in SUBROUTINE LINCOB. !     KOPT is such that XPT(KOPT,.) is the current trust region centre. !     KNEW on exit is usually positive, and then it is the index of an !       interpolation point to be moved to the position XPT(KOPT,.)+STEP(.). !       It is set on entry either to its final value or to 0. In the latter !       case, the final value of KNEW is chosen to maximize the denominator !       of the matrix updating formula times a weighting factor. !     VLAG and W are used for working space, the first NPT+N elements of !       both of these vectors being required. ! !     The arrays BMAT and ZMAT with IDZ are updated, the new matrices being !       the ones that are suitable after the shift of the KNEW-th point to !       the new position XPT(KOPT,.)+STEP(.). A return with KNEW set to zero !       occurs if the calculation fails due to a zero denominator in the !       updating formula, which should never happen. ! !     Set some constants. ! real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: zero = 0.0_wp nptm = npt - n - 1 ! !     Calculate VLAG and BETA for the current choice of STEP. The first NPT !       elements of VLAG are set to the values of the Lagrange functions at !       XPT(KOPT,.)+STEP(.). The first NPT components of W_check are held !       in W, where W_check is defined in a paper on the updating method. ! do k = 1 , npt w ( k ) = sp ( npt + k ) * ( half * sp ( npt + k ) + sp ( k )) sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * step ( j ) end do vlag ( k ) = sum end do beta = zero do k = 1 , nptm sum = zero do i = 1 , npt sum = sum + zmat ( i , k ) * w ( i ) end do if ( k < idz ) then beta = beta + sum * sum sum = - sum else beta = beta - sum * sum end if do i = 1 , npt vlag ( i ) = vlag ( i ) + sum * zmat ( i , k ) end do end do bsum = zero dx = zero ssq = zero do j = 1 , n sum = zero do i = 1 , npt sum = sum + w ( i ) * bmat ( i , j ) end do bsum = bsum + sum * step ( j ) jp = npt + j do k = 1 , n sum = sum + bmat ( jp , k ) * step ( k ) end do vlag ( jp ) = sum bsum = bsum + sum * step ( j ) dx = dx + step ( j ) * xpt ( kopt , j ) ssq = ssq + step ( j ) ** 2 end do beta = dx * dx + ssq * ( sp ( kopt ) + dx + dx + half * ssq ) + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     If KNEW is zero initially, then pick the index of the interpolation !       point to be deleted, by maximizing the absolute value of the !       denominator of the updating formula times a weighting factor. ! if ( knew == 0 ) then denmax = zero do k = 1 , npt hdiag = zero do j = 1 , nptm temp = one if ( j < idz ) temp = - one hdiag = hdiag + temp * zmat ( k , j ) ** 2 end do denabs = abs ( beta * hdiag + vlag ( k ) ** 2 ) distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xpt ( kopt , j )) ** 2 end do temp = denabs * distsq * distsq if ( temp > denmax ) then denmax = temp knew = k end if end do end if ! !     Apply the rotations that put zeros in the KNEW-th row of ZMAT. ! jl = 1 if ( nptm >= 2 ) then do j = 2 , nptm if ( j == idz ) then jl = idz else if ( zmat ( knew , j ) /= zero ) then temp = sqrt ( zmat ( knew , jl ) ** 2 + zmat ( knew , j ) ** 2 ) tempa = zmat ( knew , jl ) / temp tempb = zmat ( knew , j ) / temp do i = 1 , npt temp = tempa * zmat ( i , jl ) + tempb * zmat ( i , j ) zmat ( i , j ) = tempa * zmat ( i , j ) - tempb * zmat ( i , jl ) zmat ( i , jl ) = temp end do zmat ( knew , j ) = zero end if end do end if ! !     Put the first NPT components of the KNEW-th column of the Z Z&#94;T matrix !       into W, and calculate the parameters of the updating formula. ! tempa = zmat ( knew , 1 ) if ( idz >= 2 ) tempa = - tempa if ( jl > 1 ) tempb = zmat ( knew , jl ) do i = 1 , npt w ( i ) = tempa * zmat ( i , 1 ) if ( jl > 1 ) w ( i ) = w ( i ) + tempb * zmat ( i , jl ) end do alpha = w ( knew ) tau = vlag ( knew ) tausq = tau * tau denom = alpha * beta + tausq vlag ( knew ) = vlag ( knew ) - one if ( denom == zero ) then knew = 0 return end if sqrtdn = sqrt ( abs ( denom )) ! !     Complete the updating of ZMAT when there is only one nonzero element !       in the KNEW-th row of the new matrix ZMAT. IFLAG is set to one when !       the value of IDZ is going to be reduced. ! iflag = 0 if ( jl == 1 ) then tempa = tau / sqrtdn tempb = zmat ( knew , 1 ) / sqrtdn do i = 1 , npt zmat ( i , 1 ) = tempa * zmat ( i , 1 ) - tempb * vlag ( i ) end do if ( denom < zero ) then if ( idz == 1 ) then idz = 2 else iflag = 1 end if end if else ! !     Complete the updating of ZMAT in the alternative case. ! ja = 1 if ( beta >= zero ) ja = jl jb = jl + 1 - ja temp = zmat ( knew , jb ) / denom tempa = temp * beta tempb = temp * tau temp = zmat ( knew , ja ) scala = one / sqrt ( abs ( beta ) * temp * temp + tausq ) scalb = scala * sqrtdn do i = 1 , npt zmat ( i , ja ) = scala * ( tau * zmat ( i , ja ) - temp * vlag ( i )) zmat ( i , jb ) = scalb * ( zmat ( i , jb ) - tempa * w ( i ) - tempb * vlag ( i )) end do if ( denom <= zero ) then if ( beta < zero ) then idz = idz + 1 else iflag = 1 end if end if end if ! !     Reduce IDZ when the diagonal part of the ZMAT times Diag(DZ) times !       ZMAT&#94;T factorization gains another positive element. Then exchange !       the first and IDZ-th columns of ZMAT. ! if ( iflag == 1 ) then idz = idz - 1 do i = 1 , npt temp = zmat ( i , 1 ) zmat ( i , 1 ) = zmat ( i , idz ) zmat ( i , idz ) = temp end do end if ! !     Finally, update the matrix BMAT. ! do j = 1 , n jp = npt + j w ( jp ) = bmat ( knew , j ) tempa = ( alpha * vlag ( jp ) - tau * w ( jp )) / denom tempb = ( - beta * w ( jp ) - tau * vlag ( jp )) / denom do i = 1 , jp bmat ( i , j ) = bmat ( i , j ) + tempa * vlag ( i ) + tempb * w ( i ) if ( i > npt ) bmat ( jp , i - npt ) = bmat ( i , j ) end do end do end subroutine update !***************************************************************************************** !> !  Test problem for [[lincoa]]. ! !  Calculate the tetrahedron of least volume that encloses the points !  `(XP(J),YP(J),ZP(J)), J=1,2,...,NP`. Our method requires the origin !  to be strictly inside the convex hull of these points. There are !  twelve variables that define the four faces of each tetrahedron !  that is considered. Each face has the form `ALPHA*X+BETA*Y+GAMMA*Z=1`, !  the variables `X(3K-2)`, `X(3K-1)` and `X(3K)` being the values of `ALPHA`, !  `BETA` and `GAMMA` for the K-th face, K=1,2,3,4. Let the set T contain !  all points in three dimensions that can be reached from the origin !  without crossing a face. Because the volume of T may be infinite, !  the objective function is the smaller of FMAX and the volume of T, !  where FMAX is set to an upper bound on the final volume initially. !  There are 4*NP linear constraints on the variables, namely that each !  of the given points `(XP(J),YP(J),ZP(J))` shall be in T. Let `XS = min !  XP(J)`, `YS = min YP(J)`, `ZS = min ZP(J)` and `SS = max XP(J)+YP(J)+ZP(J)`, !  where J runs from 1 to NP. The initial values of the variables are !  `X(1)=1/XS`, `X(5)=1/YS`, `X(9)=1/ZS`, `X(2)=X(3)=X(4)=X(6)=X(7)=X(8)=0` !  and `X(10)=X(11)=X(12)=1/SS`, which satisfy the linear constraints, !  and which provide the bound `FMAX=(SS-XS-YS-ZS)**3/6`. Other details !  of the test calculation are given below, including the choice of !  the data points `(XP(J),YP(J),ZP(J)), J=1,2,...,NP`. The smaller final !  value of the objective function in the case NPT=35 shows that the !  problem has local minima. subroutine lincoa_test () implicit none real ( wp ) :: xp ( 50 ), yp ( 50 ), zp ( 50 ), a ( 12 , 200 ), b ( 200 ), x ( 12 ) integer :: ia , n , np , j , iw , iprint , jcase , k , i , maxfun , npt , m real ( wp ) :: sumx , sumy , sumz , theta , fmax , rhobeg , rhoend , ss , xs , ys , zs ! !     Set some constants. ! real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: two = 2.0_wp real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: pi = 4.0_wp * atan ( one ) ia = 12 n = 12 ! !     Set the data points. ! np = 50 sumx = zero sumy = zero sumz = zero do j = 1 , np theta = real ( j - 1 , wp ) * pi / real ( np - 1 , wp ) xp ( j ) = cos ( theta ) * cos ( two * theta ) sumx = sumx + xp ( j ) yp ( j ) = sin ( theta ) * cos ( two * theta ) sumy = sumy + yp ( j ) zp ( j ) = sin ( two * theta ) sumz = sumz + zp ( j ) end do sumx = sumx / real ( np , wp ) sumy = sumy / real ( np , wp ) sumz = sumz / real ( np , wp ) do j = 1 , np xp ( j ) = xp ( j ) - sumx yp ( j ) = yp ( j ) - sumy zp ( j ) = zp ( j ) - sumz end do ! !     Set the linear constraints. ! m = 4 * np do k = 1 , m b ( k ) = one do i = 1 , n a ( i , k ) = zero end do end do do j = 1 , np do i = 1 , 4 k = 4 * j + i - 4 iw = 3 * i a ( iw - 2 , k ) = xp ( j ) a ( iw - 1 , k ) = yp ( j ) a ( iw , k ) = zp ( j ) end do end do ! !     Set the initial vector of variables. The JCASE=1,6 loop gives six !       different choices of NPT when LINCOA is called. ! xs = zero ys = zero zs = zero ss = zero do j = 1 , np xs = min ( xs , xp ( j )) ys = min ( ys , yp ( j )) zs = min ( zs , zp ( j )) ss = max ( ss , xp ( j ) + yp ( j ) + zp ( j )) end do fmax = ( ss - xs - ys - zs ) ** 3 / 6.0_wp do jcase = 1 , 6 do i = 2 , 8 x ( i ) = zero end do x ( 1 ) = one / xs x ( 5 ) = one / ys x ( 9 ) = one / zs x ( 10 ) = one / ss x ( 11 ) = one / ss x ( 12 ) = one / ss ! !     Call of LINCOA, which provides the printing given at the end of this !       note. ! npt = 5 * jcase + 10 rhobeg = 1.0_wp rhoend = 1.0e-6_wp iprint = 1 maxfun = 10000 print 70 , npt , rhoend 70 format ( / / 4 x , 'Output from LINCOA with  NPT =' , i4 , '  and  RHOEND =' , 1 & & pd12 . 4 ) call lincoa ( n , npt , m , a , ia , b , x , rhobeg , rhoend , iprint , maxfun , calfun ) end do contains subroutine calfun ( n , x , f ) implicit none integer :: n real ( wp ) :: x ( * ) real ( wp ) :: f real ( wp ) :: v12 , v13 , v14 , v23 , v24 , v34 , del1 , del2 , del3 , del4 , temp f = fmax v12 = x ( 1 ) * x ( 5 ) - x ( 4 ) * x ( 2 ) v13 = x ( 1 ) * x ( 8 ) - x ( 7 ) * x ( 2 ) v14 = x ( 1 ) * x ( 11 ) - x ( 10 ) * x ( 2 ) v23 = x ( 4 ) * x ( 8 ) - x ( 7 ) * x ( 5 ) v24 = x ( 4 ) * x ( 11 ) - x ( 10 ) * x ( 5 ) v34 = x ( 7 ) * x ( 11 ) - x ( 10 ) * x ( 8 ) del1 = v23 * x ( 12 ) - v24 * x ( 9 ) + v34 * x ( 6 ) if ( del1 <= zero ) return del2 = - v34 * x ( 3 ) - v13 * x ( 12 ) + v14 * x ( 9 ) if ( del2 <= zero ) return del3 = - v14 * x ( 6 ) + v24 * x ( 3 ) + v12 * x ( 12 ) if ( del3 <= zero ) return del4 = - v12 * x ( 9 ) + v13 * x ( 6 ) - v23 * x ( 3 ) if ( del4 <= zero ) return temp = ( del1 + del2 + del3 + del4 ) ** 3 / ( del1 * del2 * del3 * del4 ) f = min ( temp / 6.0_wp , fmax ) end subroutine calfun end subroutine lincoa_test !***************************************************************************************** end module lincoa_module","tags":"","loc":"sourcefile/lincoa.f90.html"},{"title":"uobyqa.f90 – PowellOpt","text":"This file depends on sourcefile~~uobyqa.f90~~EfferentGraph sourcefile~uobyqa.f90 uobyqa.f90 sourcefile~kind_module.f90 kind_module.f90 sourcefile~uobyqa.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~uobyqa.f90~~AfferentGraph sourcefile~uobyqa.f90 uobyqa.f90 sourcefile~powellopt.f90 powellopt.f90 sourcefile~powellopt.f90->sourcefile~uobyqa.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  UOBYQA: **U**nconstrained **O**ptimization **BY** **Q**uadratic **A**pproximation ! !  The purpose of UOBYQA is to seek the least value of a function F of several variables, !  when derivatives are not available. !  It uses a trust region method that forms quadratic models by interpolation. ! !# References ! !  * \"UOBYQA: unconstrained optimization by !    quadratic approximation\" by M.J.D. Powell, Report DAMTP 2000/NA14, !    University of Cambridge. !  * \"[UOBYQA: unconstrained optimization by quadratic !    approximation](http://link.springer.com/article/10.1007%2Fs101070100290)\" by !    M.J.D. Powell, Mathematical Programming Series B, Volume !    92, pages 555-582 (2002). ! !# History !  * M.J.D. Powell : It is hoped that the software will !    be helpful to much future research and to many applications. !    There are no restrictions on or charges for its use. !  * Jacob Williams, July 2015 : refactoring of the code into modern Fortran. module uobyqa_module use kind_module , only : wp private real ( wp ), parameter :: half = 0.5_wp , one = 1.0_wp , tenth = 0.1_wp , & zero = 0.0_wp , quart = 0.25_wp , two = 2.0_wp , halfrt = sqrt ( half ) abstract interface subroutine func ( n , x , f ) !! calfun interface import :: wp implicit none integer :: n real ( wp ) :: x ( * ) real ( wp ) :: f end subroutine func end interface public :: uobyqa public :: uobyqa_test contains !***************************************************************************************** !***************************************************************************************** !> !  This subroutine seeks the least value of a function of many variables, !  by a trust region method that forms quadratic models by interpolation. subroutine uobyqa ( n , x , rhobeg , rhoend , iprint , maxfun , calfun ) implicit none integer , intent ( in ) :: n !! the number of variables and must be at least two real ( wp ), intent ( inout ), dimension ( * ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). They !! will be changed to the values that give the least calculated F. real ( wp ), intent ( in ) :: rhobeg !! RHOBEG and RHOEND must be set to the initial and final values of a trust !! region radius, so both must be positive with RHOEND<=RHOBEG. Typically !! RHOBEG should be about one tenth of the greatest expected change to a !! variable, and RHOEND should indicate the accuracy that is required in !! the final values of the variables. real ( wp ), intent ( in ) :: rhoend !! RHOBEG and RHOEND must be set to the initial and final values of a trust !! region radius, so both must be positive with RHOEND<=RHOBEG. Typically !! RHOBEG should be about one tenth of the greatest expected change to a !! variable, and RHOEND should indicate the accuracy that is required in !! the final values of the variables. integer , intent ( in ) :: iprint !! The value of IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, each new !! value of RHO is printed, with the best vector of variables so far and !! the corresponding value of the objective function. Further, each new !! value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! upper bound on the number of calls of CALFUN. procedure ( func ) :: calfun !! It must set F to the value of the objective !! function for the variables X(1),X(2),...,X(N). real ( wp ), dimension (:), allocatable :: w integer :: npt , ixb , ixo , ixn , ixp , ipq , ipl , ih , ig , id , ivl , iw ! Partition the working space array, so that different parts of it can be ! treated separately by the subroutine that performs the main calculation. npt = ( n * n + 3 * n + 2 ) / 2 ixb = 1 ixo = ixb + n ixn = ixo + n ixp = ixn + n ipq = ixp + n * npt ipl = ipq + npt - 1 ih = ipl + ( npt - 1 ) * npt ig = ih + n * n id = ig + n ivl = ih iw = id + n ! The array W will be used for working space allocate ( w (( N ** 4 + 8 * N ** 3 + 23 * N ** 2 + 42 * N + max ( 2 * N ** 2 + 4 , 18 * N )) / 4 )) call uobyqb ( n , x , rhobeg , rhoend , iprint , maxfun , npt , w ( ixb ), w ( ixo ), w ( ixn ), & w ( ixp ), w ( ipq ), w ( ipl ), w ( ih ), w ( ig ), w ( id ), w ( ivl ), w ( iw ), calfun ) deallocate ( w ) end subroutine uobyqa !***************************************************************************************** subroutine uobyqb ( n , x , rhobeg , rhoend , iprint , maxfun , npt , xbase , xopt , xnew , xpt , & pq , pl , h , g , d , vlag , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension x ( * ), xbase ( * ), xopt ( * ), xnew ( * ), xpt ( npt , * ), pq ( * ), pl ( npt , * ), & h ( n , * ), g ( * ), d ( * ), vlag ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, X, RHOBEG, RHOEND, IPRINT and MAXFUN are identical to !       the corresponding arguments in SUBROUTINE UOBYQA. !     NPT is set by UOBYQA to (N*N+3*N+2)/2 for the above dimension statement. !     XBASE will contain a shift of origin that reduces the contributions from !       rounding errors to values of the model and Lagrange functions. !     XOPT will be set to the displacement from XBASE of the vector of !       variables that provides the least calculated F so far. !     XNEW will be set to the displacement from XBASE of the vector of !       variables for the current calculation of F. !     XPT will contain the interpolation point coordinates relative to XBASE. !     PQ will contain the parameters of the quadratic model. !     PL will contain the parameters of the Lagrange functions. !     H will provide the second derivatives that TRSTEP and LAGMAX require. !     G will provide the first derivatives that TRSTEP and LAGMAX require. !     D is reserved for trial steps from XOPT, except that it will contain !       diagonal second derivatives during the initialization procedure. !     VLAG will contain the values of the Lagrange functions at a new point X. !     The array W will be used for working space. Its length must be at least !     max [ 6*N, ( N**2 + 3*N + 2 ) / 2 ]. ! !     Set some constants. ! tol = 0.01_wp nnp = n + n + 1 nptm = npt - 1 nftest = max ( maxfun , 1 ) ! !     Initialization. NF is the number of function calculations so far. ! rho = rhobeg rhosq = rho * rho nf = 0 do i = 1 , n xbase ( i ) = x ( i ) do k = 1 , npt xpt ( k , i ) = zero end do end do do k = 1 , npt do j = 1 , nptm pl ( k , j ) = zero end do end do ! !     The branch to label 120 obtains a new value of the objective function !     and then there is a branch back to label 50, because the new function !     value is needed to form the initial quadratic model. The least function !     value so far and its index are noted below. ! 30 do i = 1 , n x ( i ) = xbase ( i ) + xpt ( nf + 1 , i ) end do go to 120 50 if ( nf == 1 ) then fopt = f kopt = nf fbase = f j = 0 jswitch = - 1 ih = n else if ( f < fopt ) then fopt = f kopt = nf end if end if ! !     Form the gradient and diagonal second derivatives of the initial !     quadratic model and Lagrange functions. ! if ( nf <= nnp ) then jswitch = - jswitch if ( jswitch > 0 ) then if ( j >= 1 ) then ih = ih + j if ( w ( j ) < zero ) then d ( j ) = ( fsave + f - two * fbase ) / rhosq pq ( j ) = ( fsave - f ) / ( two * rho ) pl ( 1 , ih ) = - two / rhosq pl ( nf - 1 , j ) = half / rho pl ( nf - 1 , ih ) = one / rhosq else pq ( j ) = ( 4.0_wp * fsave - 3.0_wp * fbase - f ) / ( two * rho ) d ( j ) = ( fbase + f - two * fsave ) / rhosq pl ( 1 , j ) = - 1.5_wp / rho pl ( 1 , ih ) = one / rhosq pl ( nf - 1 , j ) = two / rho pl ( nf - 1 , ih ) = - two / rhosq end if pq ( ih ) = d ( j ) pl ( nf , j ) = - half / rho pl ( nf , ih ) = one / rhosq end if ! !     Pick the shift from XBASE to the next initial interpolation point !     that provides diagonal second derivatives. ! if ( j < n ) then j = j + 1 xpt ( nf + 1 , j ) = rho end if else fsave = f if ( f < fbase ) then w ( j ) = rho xpt ( nf + 1 , j ) = two * rho else w ( j ) = - rho xpt ( nf + 1 , j ) = - rho end if end if if ( nf < nnp ) go to 30 ! !     Form the off-diagonal second derivatives of the initial quadratic model. ! ih = n ip = 1 iq = 2 end if ih = ih + 1 if ( nf > nnp ) then temp = one / ( w ( ip ) * w ( iq )) tempa = f - fbase - w ( ip ) * pq ( ip ) - w ( iq ) * pq ( iq ) pq ( ih ) = ( tempa - half * rhosq * ( d ( ip ) + d ( iq ))) * temp pl ( 1 , ih ) = temp iw = ip + ip if ( w ( ip ) < zero ) iw = iw + 1 pl ( iw , ih ) = - temp iw = iq + iq if ( w ( iq ) < zero ) iw = iw + 1 pl ( iw , ih ) = - temp pl ( nf , ih ) = temp ! !     Pick the shift from XBASE to the next initial interpolation point !     that provides off-diagonal second derivatives. ! ip = ip + 1 end if if ( ip == iq ) then ih = ih + 1 ip = 1 iq = iq + 1 end if if ( nf < npt ) then xpt ( nf + 1 , ip ) = w ( ip ) xpt ( nf + 1 , iq ) = w ( iq ) go to 30 end if ! !     Set parameters to begin the iterations for the current RHO. ! sixthm = zero delta = rho 60 tworsq = ( two * rho ) ** 2 rhosq = rho * rho ! !     Form the gradient of the quadratic model at the trust region centre. ! 70 knew = 0 ih = n do j = 1 , n xopt ( j ) = xpt ( kopt , j ) g ( j ) = pq ( j ) do i = 1 , j ih = ih + 1 g ( i ) = g ( i ) + pq ( ih ) * xopt ( j ) if ( i < j ) g ( j ) = g ( j ) + pq ( ih ) * xopt ( i ) h ( i , j ) = pq ( ih ) end do end do ! !     Generate the next trust region step and test its length. Set KNEW !     to -1 if the purpose of the next F will be to improve conditioning, !     and also calculate a lower bound on the Hessian term of the model Q. ! call trstep ( n , g , h , delta , tol , d , w ( 1 ), w ( n + 1 ), w ( 2 * n + 1 ), w ( 3 * n + 1 ), w ( 4 * n + 1 ), & w ( 5 * n + 1 ), evalue ) temp = zero do i = 1 , n temp = temp + d ( i ) ** 2 end do dnorm = min ( delta , sqrt ( temp )) errtol = - one if ( dnorm < half * rho ) then knew = - 1 errtol = half * evalue * rho * rho if ( nf <= npt + 9 ) errtol = zero go to 290 end if ! !     Calculate the next value of the objective function. ! 100 do i = 1 , n xnew ( i ) = xopt ( i ) + d ( i ) x ( i ) = xbase ( i ) + xnew ( i ) end do 120 if ( nf >= nftest ) then if ( iprint > 0 ) print 130 130 format ( / 4 x , 'Return from UOBYQA because CALFUN has been' ,& ' called MAXFUN times' ) go to 420 end if nf = nf + 1 call calfun ( n , x , f ) if ( iprint == 3 ) then print 140 , nf , f , ( x ( i ), i = 1 , n ) 140 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( nf <= npt ) go to 50 if ( knew ==- 1 ) go to 420 ! !     Use the quadratic model to predict the change in F due to the step D, !     and find the values of the Lagrange functions at the new point. ! vquad = zero ih = n do j = 1 , n w ( j ) = d ( j ) vquad = vquad + w ( j ) * pq ( j ) do i = 1 , j ih = ih + 1 w ( ih ) = d ( i ) * xnew ( j ) + d ( j ) * xopt ( i ) if ( i == j ) w ( ih ) = half * w ( ih ) vquad = vquad + w ( ih ) * pq ( ih ) end do end do do k = 1 , npt temp = zero do j = 1 , nptm temp = temp + w ( j ) * pl ( k , j ) end do vlag ( k ) = temp end do vlag ( kopt ) = vlag ( kopt ) + one ! !     Update SIXTHM, which is a lower bound on one sixth of the greatest !     third derivative of F. ! diff = f - fopt - vquad sum = zero do k = 1 , npt temp = zero do i = 1 , n temp = temp + ( xpt ( k , i ) - xnew ( i )) ** 2 end do temp = sqrt ( temp ) sum = sum + abs ( temp * temp * temp * vlag ( k )) end do sixthm = max ( sixthm , abs ( diff ) / sum ) ! !     Update FOPT and XOPT if the new F is the least value of the objective !     function so far. Then branch if D is not a trust region step. ! fsave = fopt if ( f < fopt ) then fopt = f do i = 1 , n xopt ( i ) = xnew ( i ) end do end if ksave = knew if ( knew > 0 ) go to 240 ! !     Pick the next value of DELTA after a trust region step. ! if ( vquad >= zero ) then if ( iprint > 0 ) print 210 210 format ( / 4 x , 'Return from UOBYQA because a trust' ,& ' region step has failed to reduce Q' ) go to 420 end if ratio = ( f - fsave ) / vquad if ( ratio <= 0.1_wp ) then delta = half * dnorm else if ( ratio <= 0.7_wp ) then delta = max ( half * delta , dnorm ) else delta = max ( delta , 1.25_wp * dnorm , dnorm + rho ) end if if ( delta <= 1.5_wp * rho ) delta = rho ! !     Set KNEW to the index of the next interpolation point to be deleted. ! ktemp = 0 detrat = zero if ( f >= fsave ) then ktemp = kopt detrat = one end if do k = 1 , npt sum = zero do i = 1 , n sum = sum + ( xpt ( k , i ) - xopt ( i )) ** 2 end do temp = abs ( vlag ( k )) if ( sum > rhosq ) temp = temp * ( sum / rhosq ) ** 1.5_wp if ( temp > detrat . and . k /= ktemp ) then detrat = temp ddknew = sum knew = k end if end do if ( knew == 0 ) go to 290 ! !     Replace the interpolation point that has index KNEW by the point XNEW, !     and also update the Lagrange functions and the quadratic model. ! 240 do i = 1 , n xpt ( knew , i ) = xnew ( i ) end do temp = one / vlag ( knew ) do j = 1 , nptm pl ( knew , j ) = temp * pl ( knew , j ) pq ( j ) = pq ( j ) + diff * pl ( knew , j ) end do do k = 1 , npt if ( k /= knew ) then temp = vlag ( k ) do j = 1 , nptm pl ( k , j ) = pl ( k , j ) - temp * pl ( knew , j ) end do end if end do ! !     Update KOPT if F is the least calculated value of the objective !     function. Then branch for another trust region calculation. The !     case KSAVE>0 indicates that a model step has just been taken. ! if ( f < fsave ) then kopt = knew go to 70 end if if ( ksave > 0 ) go to 70 if ( dnorm > two * rho ) go to 70 if ( ddknew > tworsq ) go to 70 ! !     Alternatively, find out if the interpolation points are close !     enough to the best point so far. ! 290 do k = 1 , npt w ( k ) = zero do i = 1 , n w ( k ) = w ( k ) + ( xpt ( k , i ) - xopt ( i )) ** 2 end do end do 310 knew = - 1 distest = tworsq do k = 1 , npt if ( w ( k ) > distest ) then knew = k distest = w ( k ) end if end do ! !     If a point is sufficiently far away, then set the gradient and Hessian !     of its Lagrange function at the centre of the trust region, and find !     half the sum of squares of components of the Hessian. ! if ( knew > 0 ) then ih = n sumh = zero do j = 1 , n g ( j ) = pl ( knew , j ) do i = 1 , j ih = ih + 1 temp = pl ( knew , ih ) g ( j ) = g ( j ) + temp * xopt ( i ) if ( i < j ) then g ( i ) = g ( i ) + temp * xopt ( j ) sumh = sumh + temp * temp end if h ( i , j ) = temp end do sumh = sumh + half * temp * temp end do ! !     If ERRTOL is positive, test whether to replace the interpolation point !     with index KNEW, using a bound on the maximum modulus of its Lagrange !     function in the trust region. ! if ( errtol > zero ) then w ( knew ) = zero sumg = zero do i = 1 , n sumg = sumg + g ( i ) ** 2 end do estim = rho * ( sqrt ( sumg ) + rho * sqrt ( half * sumh )) wmult = sixthm * distest ** 1.5_wp if ( wmult * estim <= errtol ) go to 310 end if ! !     If the KNEW-th point may be replaced, then pick a D that gives a large !     value of the modulus of its Lagrange function within the trust region. !     Here the vector XNEW is used as temporary working space. ! call lagmax ( n , g , h , rho , d , xnew , vmax ) if ( errtol > zero ) then if ( wmult * vmax <= errtol ) go to 310 end if go to 100 end if if ( dnorm > rho ) go to 70 ! !     Prepare to reduce RHO by shifting XBASE to the best point so far, !     and make the corresponding changes to the gradients of the Lagrange !     functions and the quadratic model. ! if ( rho > rhoend ) then ih = n do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) do k = 1 , npt xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) end do do i = 1 , j ih = ih + 1 pq ( i ) = pq ( i ) + pq ( ih ) * xopt ( j ) if ( i < j ) then pq ( j ) = pq ( j ) + pq ( ih ) * xopt ( i ) do k = 1 , npt pl ( k , j ) = pl ( k , j ) + pl ( k , ih ) * xopt ( i ) end do end if do k = 1 , npt pl ( k , i ) = pl ( k , i ) + pl ( k , ih ) * xopt ( j ) end do end do end do ! !     Pick the next values of RHO and DELTA. ! delta = half * rho ratio = rho / rhoend if ( ratio <= 1 6.0_wp ) then rho = rhoend else if ( ratio <= 25 0.0_wp ) then rho = sqrt ( ratio ) * rhoend else rho = 0.1_wp * rho end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) print 390 390 format ( 5 x ) print 400 , rho , nf 400 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 410 , fopt , ( xbase ( i ), i = 1 , n ) 410 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if go to 60 end if ! !     Return from the calculation, after another Newton-Raphson step, if !     it is too short to have been tried before. ! if ( errtol >= zero ) go to 100 420 if ( fopt <= f ) then do i = 1 , n x ( i ) = xbase ( i ) + xopt ( i ) end do f = fopt end if if ( iprint >= 1 ) then print 440 , nf 440 format ( / 4 x , 'At the return from UOBYQA' , 5 x ,& 'Number of function values =' , i6 ) print 410 , f , ( x ( i ), i = 1 , n ) end if end subroutine uobyqb subroutine lagmax ( n , g , h , rho , d , v , vmax ) implicit real ( wp ) ( a - h , o - z ) dimension g ( * ), h ( n , * ), d ( * ), v ( * ) ! !     N is the number of variables of a quadratic objective function, Q say. !     G is the gradient of Q at the origin. !     H is the symmetric Hessian matrix of Q. Only the upper triangular and !       diagonal parts need be set. !     RHO is the trust region radius, and has to be positive. !     D will be set to the calculated vector of variables. !     The array V will be used for working space. !     VMAX will be set to |Q(0)-Q(D)|. ! !     Calculating the D that maximizes |Q(0)-Q(D)| subject to ||D|| .LEQ. RHO !     requires of order N**3 operations, but sometimes it is adequate if !     |Q(0)-Q(D)| is within about 0.9 of its greatest possible value. This !     subroutine provides such a solution in only of order N**2 operations, !     where the claim of accuracy has been tested by numerical experiments. ! !     Preliminary calculations. ! ! !     Pick V such that ||HV|| / ||V|| is large. ! hmax = zero do i = 1 , n sum = zero do j = 1 , n h ( j , i ) = h ( i , j ) sum = sum + h ( i , j ) ** 2 end do if ( sum > hmax ) then hmax = sum k = i end if end do do j = 1 , n v ( j ) = h ( k , j ) end do ! !     Set D to a vector in the subspace spanned by V and HV that maximizes !     |(D,HD)|/(D,D), except that we set D=HV if V and HV are nearly parallel. !     The vector that has the name D at label 60 used to be the vector W. ! vsq = zero vhv = zero dsq = zero do i = 1 , n vsq = vsq + v ( i ) ** 2 d ( i ) = zero do j = 1 , n d ( i ) = d ( i ) + h ( i , j ) * v ( j ) end do vhv = vhv + v ( i ) * d ( i ) dsq = dsq + d ( i ) ** 2 end do if ( vhv * vhv <= 0.9999_wp * dsq * vsq ) then temp = vhv / vsq wsq = zero do i = 1 , n d ( i ) = d ( i ) - temp * v ( i ) wsq = wsq + d ( i ) ** 2 end do whw = zero ratio = sqrt ( wsq / vsq ) do i = 1 , n temp = zero do j = 1 , n temp = temp + h ( i , j ) * d ( j ) end do whw = whw + temp * d ( i ) v ( i ) = ratio * v ( i ) end do vhv = ratio * ratio * vhv vhw = ratio * wsq temp = half * ( whw - vhv ) temp = temp + sign ( sqrt ( temp ** 2 + vhw ** 2 ), whw + vhv ) do i = 1 , n d ( i ) = vhw * v ( i ) + temp * d ( i ) end do end if ! !     We now turn our attention to the subspace spanned by G and D. A multiple !     of the current D is returned if that choice seems to be adequate. ! gg = zero gd = zero dd = zero dhd = zero do i = 1 , n gg = gg + g ( i ) ** 2 gd = gd + g ( i ) * d ( i ) dd = dd + d ( i ) ** 2 sum = zero do j = 1 , n sum = sum + h ( i , j ) * d ( j ) end do dhd = dhd + sum * d ( i ) end do temp = gd / gg vv = zero scale = sign ( rho / sqrt ( dd ), gd * dhd ) do i = 1 , n v ( i ) = d ( i ) - temp * g ( i ) vv = vv + v ( i ) ** 2 d ( i ) = scale * d ( i ) end do gnorm = sqrt ( gg ) if ( gnorm * dd <= 0.5e-2_wp * rho * abs ( dhd ) . or . vv / dd <= 1.0e-4_wp ) then vmax = abs ( scale * ( gd + half * scale * dhd )) return end if ! !     G and V are now orthogonal in the subspace spanned by G and D. Hence !     we generate an orthonormal basis of this subspace such that (D,HV) is !     negligible or zero, where D and V will be the basis vectors. ! ghg = zero vhg = zero vhv = zero do i = 1 , n sum = zero sumv = zero do j = 1 , n sum = sum + h ( i , j ) * g ( j ) sumv = sumv + h ( i , j ) * v ( j ) end do ghg = ghg + sum * g ( i ) vhg = vhg + sumv * g ( i ) vhv = vhv + sumv * v ( i ) end do vnorm = sqrt ( vv ) ghg = ghg / gg vhg = vhg / ( vnorm * gnorm ) vhv = vhv / vv if ( abs ( vhg ) <= 0.01_wp * max ( abs ( ghg ), abs ( vhv ))) then vmu = ghg - vhv wcos = one wsin = zero else temp = half * ( ghg - vhv ) vmu = temp + sign ( sqrt ( temp ** 2 + vhg ** 2 ), temp ) temp = sqrt ( vmu ** 2 + vhg ** 2 ) wcos = vmu / temp wsin = vhg / temp end if tempa = wcos / gnorm tempb = wsin / vnorm tempc = wcos / vnorm tempd = wsin / gnorm do i = 1 , n d ( i ) = tempa * g ( i ) + tempb * v ( i ) v ( i ) = tempc * v ( i ) - tempd * g ( i ) end do ! !     The final D is a multiple of the current D, V, D+V or D-V. We make the !     choice from these possibilities that is optimal. ! dlin = wcos * gnorm / rho vlin = - wsin * gnorm / rho tempa = abs ( dlin ) + half * abs ( vmu + vhv ) tempb = abs ( vlin ) + half * abs ( ghg - vmu ) tempc = halfrt * ( abs ( dlin ) + abs ( vlin )) + 0.25_wp * abs ( ghg + vhv ) if ( tempa >= tempb . and . tempa >= tempc ) then tempd = sign ( rho , dlin * ( vmu + vhv )) tempv = zero else if ( tempb >= tempc ) then tempd = zero tempv = sign ( rho , vlin * ( ghg - vmu )) else tempd = sign ( halfrt * rho , dlin * ( ghg + vhv )) tempv = sign ( halfrt * rho , vlin * ( ghg + vhv )) end if do i = 1 , n d ( i ) = tempd * d ( i ) + tempv * v ( i ) end do vmax = rho * rho * max ( tempa , tempb , tempc ) end subroutine lagmax subroutine trstep ( n , g , h , delta , tol , d , gg , td , tn , w , piv , z , evalue ) implicit real ( wp ) ( a - h , o - z ) dimension g ( * ), h ( n , * ), d ( * ), gg ( * ), td ( * ), tn ( * ), w ( * ), piv ( * ), z ( * ) ! !     N is the number of variables of a quadratic objective function, Q say. !     G is the gradient of Q at the origin. !     H is the Hessian matrix of Q. Only the upper triangular and diagonal !       parts need be set. The lower triangular part is used to store the !       elements of a Householder similarity transformation. !     DELTA is the trust region radius, and has to be positive. !     TOL is the value of a tolerance from the open interval (0,1). !     D will be set to the calculated vector of variables. !     The arrays GG, TD, TN, W, PIV and Z will be used for working space. !     EVALUE will be set to the least eigenvalue of H if and only if D is a !     Newton-Raphson step. Then EVALUE will be positive, but otherwise it !     will be set to zero. ! !     Let MAXRED be the maximum of Q(0)-Q(D) subject to ||D|| .LEQ. DELTA, !     and let ACTRED be the value of Q(0)-Q(D) that is actually calculated. !     We take the view that any D is acceptable if it has the properties ! !             ||D|| .LEQ. DELTA  and  ACTRED .LEQ. (1-TOL)*MAXRED. ! !     The calculation of D is done by the method of Section 2 of the paper !     by MJDP in the 1997 Dundee Numerical Analysis Conference Proceedings, !     after transforming H to tridiagonal form. ! !     Initialization. ! delsq = delta * delta evalue = zero nm = n - 1 do i = 1 , n d ( i ) = zero td ( i ) = h ( i , i ) do j = 1 , i h ( i , j ) = h ( j , i ) end do end do ! !     Apply Householder transformations to obtain a tridiagonal matrix that !     is similar to H, and put the elements of the Householder vectors in !     the lower triangular part of H. Further, TD and TN will contain the !     diagonal and other nonzero elements of the tridiagonal matrix. ! do k = 1 , nm kp = k + 1 sum = zero if ( kp < n ) then kpp = kp + 1 do i = kpp , n sum = sum + h ( i , k ) ** 2 end do end if if ( sum == zero ) then tn ( k ) = h ( kp , k ) h ( kp , k ) = zero else temp = h ( kp , k ) tn ( k ) = sign ( sqrt ( sum + temp * temp ), temp ) h ( kp , k ) = - sum / ( temp + tn ( k )) temp = sqrt ( two / ( sum + h ( kp , k ) ** 2 )) do i = kp , n w ( i ) = temp * h ( i , k ) h ( i , k ) = w ( i ) z ( i ) = td ( i ) * w ( i ) end do wz = zero do j = kp , nm jp = j + 1 do i = jp , n z ( i ) = z ( i ) + h ( i , j ) * w ( j ) z ( j ) = z ( j ) + h ( i , j ) * w ( i ) end do wz = wz + w ( j ) * z ( j ) end do wz = wz + w ( n ) * z ( n ) do j = kp , n td ( j ) = td ( j ) + w ( j ) * ( wz * w ( j ) - two * z ( j )) if ( j < n ) then jp = j + 1 do i = jp , n h ( i , j ) = h ( i , j ) - w ( i ) * z ( j ) - w ( j ) * ( z ( i ) - wz * w ( i )) end do end if end do end if end do ! !     Form GG by applying the similarity transformation to G. ! gsq = zero do i = 1 , n gg ( i ) = g ( i ) gsq = gsq + g ( i ) ** 2 end do gnorm = sqrt ( gsq ) do k = 1 , nm kp = k + 1 sum = zero do i = kp , n sum = sum + gg ( i ) * h ( i , k ) end do do i = kp , n gg ( i ) = gg ( i ) - sum * h ( i , k ) end do end do ! !     Begin the trust region calculation with a tridiagonal matrix by !     calculating the norm of H. Then treat the case when H is zero. ! hnorm = abs ( td ( 1 )) + abs ( tn ( 1 )) tdmin = td ( 1 ) tn ( n ) = zero do i = 2 , n temp = abs ( tn ( i - 1 )) + abs ( td ( i )) + abs ( tn ( i )) hnorm = max ( hnorm , temp ) tdmin = min ( tdmin , td ( i )) end do if ( hnorm == zero ) then if ( gnorm == zero ) return scale = delta / gnorm do i = 1 , n d ( i ) = - scale * gg ( i ) end do go to 370 end if ! !     Set the initial values of PAR and its bounds. ! parl = max ( zero , - tdmin , gnorm / delta - hnorm ) parlest = parl par = parl paru = zero paruest = zero posdef = zero iterc = 0 ! !     Calculate the pivots of the Cholesky factorization of (H+PAR*I). ! 140 iterc = iterc + 1 ksav = 0 piv ( 1 ) = td ( 1 ) + par k = 1 150 if ( piv ( k ) > zero ) then piv ( k + 1 ) = td ( k + 1 ) + par - tn ( k ) ** 2 / piv ( k ) else if ( piv ( k ) < zero . or . tn ( k ) /= zero ) go to 160 ksav = k piv ( k + 1 ) = td ( k + 1 ) + par end if k = k + 1 if ( k < n ) go to 150 if ( piv ( k ) < zero ) go to 160 if ( piv ( k ) == zero ) ksav = k ! !     Branch if all the pivots are positive, allowing for the case when !     G is zero. ! if ( ksav == 0 . and . gsq > zero ) go to 230 if ( gsq == zero ) then if ( par == zero ) go to 370 paru = par paruest = par if ( ksav == 0 ) go to 190 end if k = ksav ! !     Set D to a direction of nonpositive curvature of the given tridiagonal !     matrix, and thus revise PARLEST. ! 160 d ( k ) = one if ( abs ( tn ( k )) <= abs ( piv ( k ))) then dsq = one dhd = piv ( k ) else temp = td ( k + 1 ) + par if ( temp <= abs ( piv ( k ))) then d ( k + 1 ) = sign ( one , - tn ( k )) dhd = piv ( k ) + temp - two * abs ( tn ( k )) else d ( k + 1 ) = - tn ( k ) / temp dhd = piv ( k ) + tn ( k ) * d ( k + 1 ) end if dsq = one + d ( k + 1 ) ** 2 end if 170 if ( k > 1 ) then k = k - 1 if ( tn ( k ) /= zero ) then d ( k ) = - tn ( k ) * d ( k + 1 ) / piv ( k ) dsq = dsq + d ( k ) ** 2 go to 170 end if do i = 1 , k d ( i ) = zero end do end if parl = par parlest = par - dhd / dsq ! !     Terminate with D set to a multiple of the current D if the following !     test suggests that it suitable to do so. ! 190 temp = paruest if ( gsq == zero ) temp = temp * ( one - tol ) if ( paruest > zero . and . parlest >= temp ) then dtg = zero do i = 1 , n dtg = dtg + d ( i ) * gg ( i ) end do scale = - sign ( delta / sqrt ( dsq ), dtg ) do i = 1 , n d ( i ) = scale * d ( i ) end do go to 370 end if ! !     Pick the value of PAR for the next iteration. ! 220 if ( paru == zero ) then par = two * parlest + gnorm / delta else par = 0.5_wp * ( parl + paru ) par = max ( par , parlest ) end if if ( paruest > zero ) par = min ( par , paruest ) go to 140 ! !     Calculate D for the current PAR in the positive definite case. ! 230 w ( 1 ) = - gg ( 1 ) / piv ( 1 ) do i = 2 , n w ( i ) = ( - gg ( i ) - tn ( i - 1 ) * w ( i - 1 )) / piv ( i ) end do d ( n ) = w ( n ) do i = nm , 1 , - 1 d ( i ) = w ( i ) - tn ( i ) * d ( i + 1 ) / piv ( i ) end do ! !     Branch if a Newton-Raphson step is acceptable. ! dsq = zero wsq = zero do i = 1 , n dsq = dsq + d ( i ) ** 2 wsq = wsq + piv ( i ) * w ( i ) ** 2 end do if ( par == zero . and . dsq <= delsq ) go to 320 ! !     Make the usual test for acceptability of a full trust region step. ! dnorm = sqrt ( dsq ) phi = one / dnorm - one / delta temp = tol * ( one + par * dsq / wsq ) - dsq * phi * phi if ( temp >= zero ) then scale = delta / dnorm do i = 1 , n d ( i ) = scale * d ( i ) end do go to 370 end if if ( iterc >= 2 . and . par <= parl ) go to 370 if ( paru > zero . and . par >= paru ) go to 370 ! !     Complete the iteration when PHI is negative. ! if ( phi < zero ) then parlest = par if ( posdef == one ) then if ( phi <= phil ) go to 370 slope = ( phi - phil ) / ( par - parl ) parlest = par - phi / slope end if slope = one / gnorm if ( paru > zero ) slope = ( phiu - phi ) / ( paru - par ) temp = par - phi / slope if ( paruest > zero ) temp = min ( temp , paruest ) paruest = temp posdef = one parl = par phil = phi go to 220 end if ! !     If required, calculate Z for the alternative test for convergence. ! if ( posdef == zero ) then w ( 1 ) = one / piv ( 1 ) do i = 2 , n temp = - tn ( i - 1 ) * w ( i - 1 ) w ( i ) = ( sign ( one , temp ) + temp ) / piv ( i ) end do z ( n ) = w ( n ) do i = nm , 1 , - 1 z ( i ) = w ( i ) - tn ( i ) * z ( i + 1 ) / piv ( i ) end do wwsq = zero zsq = zero dtz = zero do i = 1 , n wwsq = wwsq + piv ( i ) * w ( i ) ** 2 zsq = zsq + z ( i ) ** 2 dtz = dtz + d ( i ) * z ( i ) end do ! !     Apply the alternative test for convergence. ! tempa = abs ( delsq - dsq ) tempb = sqrt ( dtz * dtz + tempa * zsq ) gam = tempa / ( sign ( tempb , dtz ) + dtz ) temp = tol * ( wsq + par * delsq ) - gam * gam * wwsq if ( temp >= zero ) then do i = 1 , n d ( i ) = d ( i ) + gam * z ( i ) end do go to 370 end if parlest = max ( parlest , par - wwsq / zsq ) end if ! !     Complete the iteration when PHI is positive. ! slope = one / gnorm if ( paru > zero ) then if ( phi >= phiu ) go to 370 slope = ( phiu - phi ) / ( paru - par ) end if parlest = max ( parlest , par - phi / slope ) paruest = par if ( posdef == one ) then slope = ( phi - phil ) / ( par - parl ) paruest = par - phi / slope end if paru = par phiu = phi go to 220 ! !     Set EVALUE to the least eigenvalue of the second derivative matrix if !     D is a Newton-Raphson step. SHFMAX will be an upper bound on EVALUE. ! 320 shfmin = zero pivot = td ( 1 ) shfmax = pivot do k = 2 , n pivot = td ( k ) - tn ( k - 1 ) ** 2 / pivot shfmax = min ( shfmax , pivot ) end do ! !     Find EVALUE by a bisection method, but occasionally SHFMAX may be !     adjusted by the rule of false position. ! ksave = 0 340 shift = 0.5_wp * ( shfmin + shfmax ) k = 1 temp = td ( 1 ) - shift 350 if ( temp > zero ) then piv ( k ) = temp if ( k < n ) then temp = td ( k + 1 ) - shift - tn ( k ) ** 2 / temp k = k + 1 go to 350 end if shfmin = shift else if ( k < ksave ) go to 360 if ( k == ksave ) then if ( pivksv == zero ) go to 360 if ( piv ( k ) - temp < temp - pivksv ) then pivksv = temp shfmax = shift else pivksv = zero shfmax = ( shift * piv ( k ) - shfmin * temp ) / ( piv ( k ) - temp ) end if else ksave = k pivksv = temp shfmax = shift end if end if if ( shfmin <= 0.99_wp * shfmax ) go to 340 360 evalue = shfmin ! !     Apply the inverse Householder transformations to D. ! 370 nm = n - 1 do k = nm , 1 , - 1 kp = k + 1 sum = zero do i = kp , n sum = sum + d ( i ) * h ( i , k ) end do do i = kp , n d ( i ) = d ( i ) - sum * h ( i , k ) end do end do end subroutine trstep !***************************************************************************************** !> !  The Chebyquad test problem (Fletcher, 1965) for N = 2,4,6,8. subroutine uobyqa_test () implicit none real ( wp ) :: x ( 10 ) integer :: iprint , maxfun , i , n real ( wp ) :: rhoend , rhobeg iprint = 2 maxfun = 5000 rhoend = 1.0e-8_wp do n = 2 , 8 , 2 do i = 1 , n x ( i ) = real ( i , wp ) / real ( n + 1 , wp ) end do rhobeg = 0.2_wp * x ( 1 ) print 20 , n 20 format ( / / 5 x , '******************' / 5 x , 'Results with N =' , i2 , / 5 x ,& '******************' ) call uobyqa ( n , x , rhobeg , rhoend , iprint , maxfun , calfun ) end do contains subroutine calfun ( n , x , f ) implicit none integer :: n real ( wp ) :: x ( * ) real ( wp ) :: f real ( wp ) :: y ( 10 , 10 ) real ( wp ) :: sum integer :: j , i , iw , np do j = 1 , n y ( 1 , j ) = 1.0_wp y ( 2 , j ) = 2.0_wp * x ( j ) - 1.0_wp end do do i = 2 , n do j = 1 , n y ( i + 1 , j ) = 2.0_wp * y ( 2 , j ) * y ( i , j ) - y ( i - 1 , j ) end do end do f = 0.0_wp np = n + 1 iw = 1 do i = 1 , np sum = 0.0_wp do j = 1 , n sum = sum + y ( i , j ) end do sum = sum / real ( n , wp ) if ( iw > 0 ) sum = sum + 1.0_wp / real ( i * i - 2 * i , wp ) iw = - iw f = f + sum * sum end do end subroutine calfun end subroutine uobyqa_test !***************************************************************************************** !***************************************************************************************** end module uobyqa_module !*****************************************************************************************","tags":"","loc":"sourcefile/uobyqa.f90.html"},{"title":"bobyqa.f90 – PowellOpt","text":"This file depends on sourcefile~~bobyqa.f90~~EfferentGraph sourcefile~bobyqa.f90 bobyqa.f90 sourcefile~kind_module.f90 kind_module.f90 sourcefile~bobyqa.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~bobyqa.f90~~AfferentGraph sourcefile~bobyqa.f90 bobyqa.f90 sourcefile~powellopt.f90 powellopt.f90 sourcefile~powellopt.f90->sourcefile~bobyqa.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  BOBYQA: **B**ound **O**ptimization **BY** **Q**uadratic **A**pproximation ! !  The purpose of BOBYQA is to seek the least value of a function F of several !  variables, when derivatives are not available. The constraints are the lower !  and upper bounds on every variable, which can be set to huge values for !  unconstrained variables. ! !  The algorithm is intended to change the variables to values that are close !  to a local minimum of F. The user, however, should assume responsibility for !  finding out if the calculations are satisfactory, by considering carefully !  the values of F that occur. ! !# References !  * \"[The BOBYQA algorithm for bound constrained optimization without !    derivatives](http://www.damtp.cam.ac.uk/user/na/NA_papers/NA2009_06.pdf)\". ! !# History !  * M.J.D. Powell (January 5th, 2009) -- There are no restrictions on or charges !    for the use of the software. I hope that the time and effort I have spent on !     developing the package will be helpful to much research and to many applications. !  * Jacob Williams, July 2015 : refactoring of the code into modern Fortran. module bobyqa_module use kind_module , only : wp private abstract interface subroutine func ( n , x , f ) !! calfun interface import :: wp implicit none integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( out ) :: f end subroutine func end interface public :: bobyqa public :: bobyqa_test contains !***************************************************************************************** !***************************************************************************************** !> !  This subroutine seeks the least value of a function of many variables, !  by applying a trust region method that forms quadratic models by !  interpolation. There is usually some freedom in the interpolation !  conditions, which is taken up by minimizing the Frobenius norm of !  the change to the second derivative of the model, beginning with the !  zero matrix. The values of the variables are constrained by upper and !  lower bounds. ! !  In addition to providing CALFUN, an initial vector of variables and !  the lower and upper bounds, the user has to set the values of the parameters !  ```RHOBEG```, ```RHOEND``` and ```NPT```. After scaling the individual variables !  if necessary, so that the magnitudes of their expected changes are similar, !  ```RHOBEG``` is the initial steplength for changes to the variables, a reasonable choice !  being the mesh size of a coarse grid search. Further, ```RHOEND``` should be suitable for !  a search on a very fine grid. Typically, the software calculates a vector !  of variables that is within distance ```10*RHOEND``` of a local minimum. Another !  consideration is that every trial vector of variables is forced to satisfy !  the lower and upper bounds, but there has to be room to make a search in all !  directions. Therefore an error return occurs if the difference between the !  bounds on any variable is less than ```2*RHOBEG```. The parameter ```NPT``` specifies !  the number of interpolation conditions on each quadratic model, the value !  ```NPT=2*N+1``` being recommended for a start, where ```N``` is the number of !  variables. It is often worthwhile to try other choices too, but much larger values !  tend to be inefficient, because the amount of routine work of each iteration is !  of magnitude ```NPT**2```, and because the achievement of adequate accuracy in some !  matrix calculations becomes more difficult. Some excellent numerical results !  have been found in the case ```NPT=N+6``` even with more than 100 variables. subroutine bobyqa ( n , npt , x , xl , xu , rhobeg , rhoend , iprint , maxfun , calfun ) implicit none integer , intent ( in ) :: n !! number of variables (must be at least two) integer , intent ( in ) :: npt !! number of interpolation conditions. Its value must be in !! the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not !! recommended. real ( wp ), dimension (:), intent ( inout ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). They !! will be changed to the values that give the least calculated F. real ( wp ), dimension (:), intent ( in ) :: xl !! lower bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( wp ), dimension (:), intent ( in ) :: xu !! upper bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( wp ), intent ( in ) :: rhobeg !! RHOBEG must be set to the initial value of a trust region radius. !! It must be positive, and typically should be about one tenth of the greatest !! expected change to a variable.  An error return occurs if any of !! the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real ( wp ), intent ( in ) :: rhoend !! RHOEND must be set to the final value of a trust !! region radius. It must be positive with RHOEND no greater than !! RHOBEG. Typically, RHOEND should indicate the !! accuracy that is required in the final values of the variables. integer , intent ( in ) :: iprint !! IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, each new !! value of RHO is printed, with the best vector of variables so far and !! the corresponding value of the objective function. Further, each new !! value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! an upper bound on the number of calls of CALFUN. procedure ( func ) :: calfun !! SUBROUTINE CALFUN (N,X,F) has to be provided by the user. It must set !! F to the value of the objective function for the current values of the !! variables X(1),X(2),...,X(N), which are generated automatically in a !! way that satisfies the bounds given in XL and XU. integer :: ibmat , id , ifv , igo , ihq , ipq , isl , isu , ivl , iw , ixa ,& ixb , ixn , ixo , ixp , izmat , j , jsl , jsu , ndim , np real ( wp ), dimension (:), allocatable :: w real ( wp ) :: temp real ( wp ), parameter :: zero = 0.0_wp ! The array W will be used for working space. allocate ( w (( NPT + 5 ) * ( NPT + N ) + 3 * N * ( N + 5 ) / 2 ) ) ! !     Return if the value of NPT is unacceptable. ! np = n + 1 if ( npt < n + 2 . or . npt > (( n + 2 ) * np ) / 2 ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because NPT is not in the required interval' return end if ! !     Partition the working space array, so that different parts of it can !     be treated separately during the calculation of BOBYQB. The partition !     requires the first (NPT+2)*(NPT+N)+3*N*(N+5)/2 elements of W plus the !     space that is taken by the last array in the argument list of BOBYQB. ! ndim = npt + n ixb = 1 ixp = ixb + n ifv = ixp + n * npt ixo = ifv + npt igo = ixo + n ihq = igo + n ipq = ihq + ( n * np ) / 2 ibmat = ipq + npt izmat = ibmat + ndim * n isl = izmat + npt * ( npt - np ) isu = isl + n ixn = isu + n ixa = ixn + n id = ixa + n ivl = id + n iw = ivl + ndim ! !     Return if there is insufficient space between the bounds. Modify the !     initial X if necessary in order to avoid conflicts between the bounds !     and the construction of the first quadratic model. The lower and upper !     bounds on moves from the updated X are set now, in the ISL and ISU !     partitions of W, in order to provide useful and exact information about !     components of X that become within distance RHOBEG from their bounds. ! do j = 1 , n temp = xu ( j ) - xl ( j ) if ( temp < rhobeg + rhobeg ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because one of the differences ' // & 'XU(I)-XL(I) is less than 2*RHOBEG.' return end if jsl = isl + j - 1 jsu = jsl + n w ( jsl ) = xl ( j ) - x ( j ) w ( jsu ) = xu ( j ) - x ( j ) if ( w ( jsl ) >=- rhobeg ) then if ( w ( jsl ) >= zero ) then x ( j ) = xl ( j ) w ( jsl ) = zero w ( jsu ) = temp else x ( j ) = xl ( j ) + rhobeg w ( jsl ) = - rhobeg w ( jsu ) = max ( xu ( j ) - x ( j ), rhobeg ) end if else if ( w ( jsu ) <= rhobeg ) then if ( w ( jsu ) <= zero ) then x ( j ) = xu ( j ) w ( jsl ) = - temp w ( jsu ) = zero else x ( j ) = xu ( j ) - rhobeg w ( jsl ) = min ( xl ( j ) - x ( j ), - rhobeg ) w ( jsu ) = rhobeg end if end if end do ! !     Make the call of BOBYQB. ! call bobyqb ( n , npt , x , xl , xu , rhobeg , rhoend , iprint , maxfun , w ( ixb ), w ( ixp ), & w ( ifv ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , w ( isl ), & w ( isu ), w ( ixn ), w ( ixa ), w ( id ), w ( ivl ), w ( iw ), calfun ) deallocate ( w ) end subroutine bobyqa subroutine bobyqb ( n , npt , x , xl , xu , rhobeg , rhoend , iprint , maxfun , xbase , xpt , & fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , xnew , xalt , & d , vlag , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), & gopt ( * ), hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & xnew ( * ), xalt ( * ), d ( * ), vlag ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN !       are identical to the corresponding arguments in SUBROUTINE BOBYQA. !     XBASE holds a shift of origin that should reduce the contributions !       from rounding errors to values of the model and Lagrange functions. !     XPT is a two-dimensional array that holds the coordinates of the !       interpolation points relative to XBASE. !     FVAL holds the values of F at the interpolation points. !     XOPT is set to the displacement from XBASE of the trust region centre. !     GOPT holds the gradient of the quadratic model at XBASE+XOPT. !     HQ holds the explicit second derivatives of the quadratic model. !     PQ contains the parameters of the implicit second derivatives of the !       quadratic model. !     BMAT holds the last N columns of H. !     ZMAT holds the factorization of the leading NPT by NPT submatrix of H, !       this factorization being ZMAT times ZMAT&#94;T, which provides both the !       correct rank and positive semi-definiteness. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     SL and SU hold the differences XL-XBASE and XU-XBASE, respectively. !       All the components of every XOPT are going to satisfy the bounds !       SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when !       XOPT is on a constraint boundary. !     XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the !       vector of variables for the next call of CALFUN. XNEW also satisfies !       the SL and SU constraints in the way that has just been mentioned. !     XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW !       in order to increase the denominator in the updating of UPDATE. !     D is reserved for a trial step from XOPT, which is usually XNEW-XOPT. !     VLAG contains the values of the Lagrange functions at a new point X. !       They are part of a product that requires VLAG to be of length NDIM. !     W is a one-dimensional array that is used for working space. Its length !       must be at least 3*NDIM = 3*(NPT+N). ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp ten = 1 0.0_wp tenth = 0.1_wp two = 2.0_wp zero = 0.0_wp np = n + 1 nptm = npt - np nh = ( n * np ) / 2 ! !     The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, with the corresponding values of !     of NF and KOPT, which are the number of calls of CALFUN so far and the !     index of the interpolation point at the trust region centre. Then the !     initial XOPT is set too. The branch to label 720 occurs if MAXFUN is !     less than NPT. GOPT will be updated if KOPT is different from KBASE. ! call prelim ( n , npt , x , xl , xu , rhobeg , iprint , maxfun , xbase , xpt , fval , gopt , & & hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun ) xoptsq = zero do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do fsave = fval ( 1 ) if ( nf < npt ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if kbase = 1 ! !     Complete the settings that are required for the iterative procedure. ! rho = rhobeg delta = rho nresc = nf ntrits = 0 diffa = zero diffb = zero itest = 0 nfsav = nf ! !     Update GOPT if necessary before the first iteration and after each !     call of RESCUE that makes a call of CALFUN. ! 20 if ( kopt /= kbase ) then ih = 0 do j = 1 , n do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * xopt ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * xopt ( j ) end do end do if ( nf > npt ) then do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if end if ! !     Generate the next point in the trust region that provides a small value !     of the quadratic model subject to the constraints on the variables. !     The integer NTRITS is set to the number \"trust region\" iterations that !     have occurred since the last \"alternative\" iteration. If the length !     of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to !     label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW. ! 60 call trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , w , w ( np ), & & w ( np + n ), w ( np + 2 * n ), w ( np + 3 * n ), dsq , crvmin ) dnorm = min ( delta , sqrt ( dsq )) if ( dnorm < half * rho ) then ntrits = - 1 distsq = ( ten * rho ) ** 2 if ( nf <= nfsav + 2 ) go to 650 ! !     The following choice between labels 650 and 680 depends on whether or !     not our work with the current RHO seems to be complete. Either RHO is !     decreased or termination occurs if the errors in the quadratic model at !     the last three interpolation points compare favourably with predictions !     of likely improvements to the model within distance HALF*RHO of XOPT. ! errbig = max ( diffa , diffb , diffc ) frhosq = 0.125_wp * rho * rho if ( crvmin > zero . and . errbig > frhosq * crvmin ) go to 650 bdtol = errbig / rho do j = 1 , n bdtest = bdtol if ( xnew ( j ) == sl ( j )) bdtest = w ( j ) if ( xnew ( j ) == su ( j )) bdtest = - w ( j ) if ( bdtest < bdtol ) then curv = hq (( j + j * j ) / 2 ) do k = 1 , npt curv = curv + pq ( k ) * xpt ( k , j ) ** 2 end do bdtest = bdtest + half * curv * rho if ( bdtest < bdtol ) go to 650 end if end do go to 680 end if ntrits = ntrits + 1 ! !     Severe cancellation is likely to occur if XOPT is too far from XBASE. !     If the following test holds, then XBASE is shifted so that XOPT becomes !     zero. The appropriate changes are made to BMAT and to the second !     derivatives of the current model, beginning with the changes to BMAT !     that do not depend on ZMAT. VLAG is used temporarily for working space. ! 90 if ( dsq <= 1.0e-3_wp * xoptsq ) then fracsq = 0.25_wp * xoptsq sumpq = zero do k = 1 , npt sumpq = sumpq + pq ( k ) sum = - half * xoptsq do i = 1 , n sum = sum + xpt ( k , i ) * xopt ( i ) end do w ( npt + k ) = sum temp = fracsq - half * sum do i = 1 , n w ( i ) = bmat ( k , i ) vlag ( i ) = sum * xpt ( k , i ) + temp * xopt ( i ) ip = npt + i do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + w ( i ) * vlag ( j ) + vlag ( i ) * w ( j ) end do end do end do ! !     Then the revisions of BMAT that depend on ZMAT are calculated. ! do jj = 1 , nptm sumz = zero sumw = zero do k = 1 , npt sumz = sumz + zmat ( k , jj ) vlag ( k ) = w ( npt + k ) * zmat ( k , jj ) sumw = sumw + vlag ( k ) end do do j = 1 , n sum = ( fracsq * sumz - half * sumw ) * xopt ( j ) do k = 1 , npt sum = sum + vlag ( k ) * xpt ( k , j ) end do w ( j ) = sum do k = 1 , npt bmat ( k , j ) = bmat ( k , j ) + sum * zmat ( k , jj ) end do end do do i = 1 , n ip = i + npt temp = w ( i ) do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + temp * w ( j ) end do end do end do ! !     The following instructions complete the shift, including the changes !     to the second derivative parameters of the quadratic model. ! ih = 0 do j = 1 , n w ( j ) = - half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + xopt ( i ) * w ( j ) bmat ( npt + i , j ) = bmat ( npt + j , i ) end do end do do i = 1 , n xbase ( i ) = xbase ( i ) + xopt ( i ) xnew ( i ) = xnew ( i ) - xopt ( i ) sl ( i ) = sl ( i ) - xopt ( i ) su ( i ) = su ( i ) - xopt ( i ) xopt ( i ) = zero end do xoptsq = zero end if if ( ntrits == 0 ) go to 210 go to 230 ! !     XBASE is also moved to XOPT by a call of RESCUE. This calculation is !     more expensive than the previous shift, because new matrices BMAT and !     ZMAT are generated from scratch, which may include the replacement of !     interpolation points whose positions seem to be causing near linear !     dependence in the interpolation conditions. Therefore RESCUE is called !     only if rounding errors have reduced by at least a factor of two the !     denominator of the formula for updating the H matrix. It provides a !     useful safeguard, but is not invoked in most applications of BOBYQA. ! 190 nfsav = nf kbase = kopt call rescue ( n , npt , xl , xu , iprint , maxfun , xbase , xpt , fval , xopt , gopt , hq , & & pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , w , w ( n + np ), w ( ndim + np ), & & calfun ) ! !     XOPT is updated now in case the branch below to label 720 is taken. !     Any updating of GOPT occurs after the branch below to label 20, which !     leads to a trust region iteration as does the branch to label 60. ! xoptsq = zero if ( kopt /= kbase ) then do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do end if if ( nf < 0 ) then nf = maxfun if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nresc = nf if ( nfsav < nf ) then nfsav = nf go to 20 end if if ( ntrits > 0 ) go to 60 ! !     Pick two alternative vectors of variables, relative to XBASE, that !     are suitable as new positions of the KNEW-th interpolation point. !     Firstly, XNEW is set to the point on a line through XOPT and another !     interpolation point that minimizes the predicted value of the next !     denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL !     and SU bounds. Secondly, XALT is set to the best feasible point on !     a constrained version of the Cauchy step of the KNEW-th Lagrange !     function, the corresponding value of the square of this function !     being returned in CAUCHY. The choice between these alternatives is !     going to be made when the denominator is calculated. ! 210 call altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , w , w ( np ), w ( ndim + 1 )) do i = 1 , n d ( i ) = xnew ( i ) - xopt ( i ) end do ! !     Calculate VLAG and BETA for the current choice of D. The scalar !     product of D with XPT(K,.) is going to be held in W(NPT+K) for !     use when VQUAD is calculated. ! 230 do k = 1 , npt suma = zero sumb = zero sum = zero do j = 1 , n suma = suma + xpt ( k , j ) * d ( j ) sumb = sumb + xpt ( k , j ) * xopt ( j ) sum = sum + bmat ( k , j ) * d ( j ) end do w ( k ) = suma * ( half * suma + sumb ) vlag ( k ) = sum w ( npt + k ) = suma end do beta = zero do jj = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , jj ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , jj ) end do end do dsq = zero bsum = zero dx = zero do j = 1 , n dsq = dsq + d ( j ) ** 2 sum = zero do k = 1 , npt sum = sum + w ( k ) * bmat ( k , j ) end do bsum = bsum + sum * d ( j ) jp = npt + j do i = 1 , n sum = sum + bmat ( jp , i ) * d ( i ) end do vlag ( jp ) = sum bsum = bsum + sum * d ( j ) dx = dx + d ( j ) * xopt ( j ) end do beta = dx * dx + dsq * ( xoptsq + dx + dx + half * dsq ) + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     If NTRITS is zero, the denominator may be increased by replacing !     the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if !     rounding errors have damaged the chosen denominator. ! if ( ntrits == 0 ) then denom = vlag ( knew ) ** 2 + alpha * beta if ( denom < cauchy . and . cauchy > zero ) then do i = 1 , n xnew ( i ) = xalt ( i ) d ( i ) = xnew ( i ) - xopt ( i ) end do cauchy = zero go to 230 end if if ( denom <= half * vlag ( knew ) ** 2 ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if ! !     Alternatively, if NTRITS is positive, then set KNEW to the index of !     the next interpolation point to be deleted to make room for a trust !     region step. Again RESCUE may be called if rounding errors have damaged !     the chosen denominator, which is the reason for attempting to select !     KNEW before calculating the next value of the objective function. ! else delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt if ( k == kopt ) cycle hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xopt ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if end if ! !     Put the variables for the next calculation of the objective function !       in XNEW, with any adjustments for the bounds. ! ! !     Calculate the value of the objective function at XBASE+XNEW, unless !       the limit on the number of calculations of F has been reached. ! 360 do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xnew ( i )), xu ( i )) if ( xnew ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xnew ( i ) == su ( i )) x ( i ) = xu ( i ) end do if ( nf >= maxfun ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nf = nf + 1 call calfun ( n , x ( 1 : n ), f ) if ( iprint == 3 ) then !             print 400, nf, f, (x(i), i=1, n) ! 400         format (/ 4 x, 'Function number', i6, '    F =', 1 pd18.10,& !             '   The corresponding X is:' / (2 x, 5d15.6)) write ( * , '(/4x,a,i6,a,1pd18.10,a/(2x,5d15.6))' ) & 'Function number' , nf , '    F =' , f , & '   The corresponding X is:' , ( x ( i ), i = 1 , n ) end if if ( ntrits ==- 1 ) then fsave = f go to 720 end if ! !     Use the quadratic model to predict the change in F due to the step D, !       and set DIFF to the error of this prediction. ! fopt = fval ( kopt ) vquad = zero ih = 0 do j = 1 , n vquad = vquad + d ( j ) * gopt ( j ) do i = 1 , j ih = ih + 1 temp = d ( i ) * d ( j ) if ( i == j ) temp = half * temp vquad = vquad + hq ( ih ) * temp end do end do do k = 1 , npt vquad = vquad + half * pq ( k ) * w ( npt + k ) ** 2 end do diff = f - fopt - vquad diffc = diffb diffb = diffa diffa = abs ( diff ) if ( dnorm > rho ) nfsav = nf ! !     Pick the next value of DELTA after a trust region step. ! if ( ntrits > 0 ) then if ( vquad >= zero ) then if ( iprint > 0 ) write ( * , '(/4x,a)' ) 'Return from BOBYQA because a trust' // & ' region step has failed to reduce Q.' go to 720 end if ratio = ( f - fopt ) / vquad if ( ratio <= tenth ) then delta = min ( half * delta , dnorm ) else if ( ratio <= 0.7_wp ) then delta = max ( half * delta , dnorm ) else delta = max ( half * delta , dnorm + dnorm ) end if if ( delta <= 1.5_wp * rho ) delta = rho ! !     Recalculate KNEW and DENOM if the new F is less than FOPT. ! if ( f < fopt ) then ksav = knew densav = denom delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xnew ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then knew = ksav denom = densav end if end if end if ! !     Update BMAT and ZMAT, so that the KNEW-th interpolation point can be !     moved. Also update the second derivative terms of the model. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) ih = 0 pqold = pq ( knew ) pq ( knew ) = zero do i = 1 , n temp = pqold * xpt ( knew , i ) do j = 1 , i ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * xpt ( knew , j ) end do end do do jj = 1 , nptm temp = diff * zmat ( knew , jj ) do k = 1 , npt pq ( k ) = pq ( k ) + temp * zmat ( k , jj ) end do end do ! !     Include the new interpolation point, and make the changes to GOPT at !     the old XOPT that are caused by the updating of the quadratic model. ! fval ( knew ) = f do i = 1 , n xpt ( knew , i ) = xnew ( i ) w ( i ) = bmat ( knew , i ) end do do k = 1 , npt suma = zero do jj = 1 , nptm suma = suma + zmat ( knew , jj ) * zmat ( k , jj ) end do sumb = zero do j = 1 , n sumb = sumb + xpt ( k , j ) * xopt ( j ) end do temp = suma * sumb do i = 1 , n w ( i ) = w ( i ) + temp * xpt ( k , i ) end do end do do i = 1 , n gopt ( i ) = gopt ( i ) + diff * w ( i ) end do ! !     Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT. ! if ( f < fopt ) then kopt = knew xoptsq = zero ih = 0 do j = 1 , n xopt ( j ) = xnew ( j ) xoptsq = xoptsq + xopt ( j ) ** 2 do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * d ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * d ( j ) end do end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * d ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if ! !     Calculate the parameters of the least Frobenius norm interpolant to !     the current data, the gradient of this interpolant at XOPT being put !     into VLAG(NPT+I), I=1,2,...,N. ! if ( ntrits > 0 ) then do k = 1 , npt vlag ( k ) = fval ( k ) - fval ( kopt ) w ( k ) = zero end do do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * vlag ( k ) end do do k = 1 , npt w ( k ) = w ( k ) + sum * zmat ( k , j ) end do end do do k = 1 , npt sum = zero do j = 1 , n sum = sum + xpt ( k , j ) * xopt ( j ) end do w ( k + npt ) = w ( k ) w ( k ) = sum * w ( k ) end do gqsq = zero gisq = zero do i = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , i ) * vlag ( k ) + xpt ( k , i ) * w ( k ) end do if ( xopt ( i ) == sl ( i )) then gqsq = gqsq + min ( zero , gopt ( i )) ** 2 gisq = gisq + min ( zero , sum ) ** 2 else if ( xopt ( i ) == su ( i )) then gqsq = gqsq + max ( zero , gopt ( i )) ** 2 gisq = gisq + max ( zero , sum ) ** 2 else gqsq = gqsq + gopt ( i ) ** 2 gisq = gisq + sum * sum end if vlag ( npt + i ) = sum end do ! !     Test whether to replace the new quadratic model by the least Frobenius !     norm interpolant, making the replacement if the test is satisfied. ! itest = itest + 1 if ( gqsq < ten * gisq ) itest = 0 if ( itest >= 3 ) then do i = 1 , max ( npt , nh ) if ( i <= n ) gopt ( i ) = vlag ( npt + i ) if ( i <= npt ) pq ( i ) = w ( npt + i ) if ( i <= nh ) hq ( i ) = zero itest = 0 end do end if end if ! !     If a trust region step has provided a sufficient decrease in F, then !     branch for another trust region calculation. The case NTRITS=0 occurs !     when the new interpolation point was reached by an alternative step. ! if ( ntrits == 0 ) go to 60 if ( f <= fopt + tenth * vquad ) go to 60 ! !     Alternatively, find out if the interpolation points are close enough !       to the best point so far. ! distsq = max (( two * delta ) ** 2 , ( ten * rho ) ** 2 ) 650 knew = 0 do k = 1 , npt sum = zero do j = 1 , n sum = sum + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( sum > distsq ) then knew = k distsq = sum end if end do ! !     If KNEW is positive, then ALTMOV finds alternative new positions for !     the KNEW-th interpolation point within distance ADELT of XOPT. It is !     reached via label 90. Otherwise, there is a branch to label 60 for !     another trust region iteration, unless the calculations with the !     current RHO are complete. ! if ( knew > 0 ) then dist = sqrt ( distsq ) if ( ntrits ==- 1 ) then delta = min ( tenth * delta , half * dist ) if ( delta <= 1.5_wp * rho ) delta = rho end if ntrits = 0 adelt = max ( min ( tenth * dist , delta ), rho ) dsq = adelt * adelt go to 90 end if if ( ntrits ==- 1 ) go to 680 if ( ratio > zero ) go to 60 if ( max ( delta , dnorm ) > rho ) go to 60 ! !     The calculations with the current value of RHO are complete. Pick the !       next values of RHO and DELTA. ! 680 if ( rho > rhoend ) then delta = half * rho ratio = rho / rhoend if ( ratio <= 1 6.0_wp ) then rho = rhoend else if ( ratio <= 25 0.0_wp ) then rho = sqrt ( ratio ) * rhoend else rho = tenth * rho end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) write ( * , '(5x)' ) '' print 700 , rho , nf 700 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 710 , fval ( kopt ), ( xbase ( i ) + xopt ( i ), i = 1 , n ) 710 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if ntrits = 0 nfsav = nf go to 60 end if ! !     Return from the calculation, after another Newton-Raphson step, if !       it is too short to have been tried before. ! if ( ntrits ==- 1 ) go to 360 720 if ( fval ( kopt ) <= fsave ) then do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xopt ( i )), xu ( i )) if ( xopt ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xopt ( i ) == su ( i )) x ( i ) = xu ( i ) end do f = fval ( kopt ) end if if ( iprint >= 1 ) then print 740 , nf 740 format ( / 4 x , 'At the return from BOBYQA' , 5 x ,& 'Number of function values =' , i6 ) print 710 , f , ( x ( i ), i = 1 , n ) end if return end subroutine bobyqb subroutine altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , glag , hcol , w ) implicit real ( wp ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & & xnew ( * ), xalt ( * ), glag ( * ), hcol ( * ), w ( * ) ! !     The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have !       the same meanings as the corresponding arguments of BOBYQB. !     KOPT is the index of the optimal interpolation point. !     KNEW is the index of the interpolation point that is going to be moved. !     ADELT is the current trust region bound. !     XNEW will be set to a suitable new position for the interpolation point !       XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region !       bounds and it should provide a large denominator in the next call of !       UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the !       straight lines through XOPT and another interpolation point. !     XALT also provides a large value of the modulus of the KNEW-th Lagrange !       function subject to the constraints that have been mentioned, its main !       difference from XNEW being that XALT-XOPT is a constrained version of !       the Cauchy step within the trust region. An exception is that XALT is !       not calculated if all components of GLAG (see below) are zero. !     ALPHA will be set to the KNEW-th diagonal element of the H matrix. !     CAUCHY will be set to the square of the KNEW-th Lagrange function at !       the step XALT-XOPT from XOPT for the vector XALT that is returned, !       except that CAUCHY is set to zero if XALT is not calculated. !     GLAG is a working space vector of length N for the gradient of the !       KNEW-th Lagrange function at XOPT. !     HCOL is a working space vector of length NPT for the second derivative !       coefficients of the KNEW-th Lagrange function. !     W is a working space vector of length 2N that is going to hold the !       constrained Cauchy step from XOPT of the Lagrange function, followed !       by the downhill version of XALT when the uphill step is calculated. ! !     Set the first NPT components of W to the leading elements of the !     KNEW-th column of the H matrix. ! half = 0.5_wp one = 1.0_wp zero = 0.0_wp const = one + sqrt ( 2.0_wp ) do k = 1 , npt hcol ( k ) = zero end do do j = 1 , npt - n - 1 temp = zmat ( knew , j ) do k = 1 , npt hcol ( k ) = hcol ( k ) + temp * zmat ( k , j ) end do end do alpha = hcol ( knew ) ha = half * alpha ! !     Calculate the gradient of the KNEW-th Lagrange function at XOPT. ! do i = 1 , n glag ( i ) = bmat ( knew , i ) end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = hcol ( k ) * temp do i = 1 , n glag ( i ) = glag ( i ) + temp * xpt ( k , i ) end do end do ! !     Search for a large denominator along the straight lines through XOPT !     and another interpolation point. SLBD and SUBD will be lower and upper !     bounds on the step along each of these lines in turn. PREDSQ will be !     set to the square of the predicted denominator for each line. PRESAV !     will be set to the largest admissible value of PREDSQ that occurs. ! presav = zero do k = 1 , npt if ( k == kopt ) cycle dderiv = zero distsq = zero do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) dderiv = dderiv + glag ( i ) * temp distsq = distsq + temp * temp end do subd = adelt / sqrt ( distsq ) slbd = - subd ilbd = 0 iubd = 0 sumin = min ( one , subd ) ! !     Revise SLBD and SUBD if necessary because of the bounds in SL and SU. ! do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) if ( temp > zero ) then if ( slbd * temp < sl ( i ) - xopt ( i )) then slbd = ( sl ( i ) - xopt ( i )) / temp ilbd = - i end if if ( subd * temp > su ( i ) - xopt ( i )) then subd = max ( sumin , ( su ( i ) - xopt ( i )) / temp ) iubd = i end if else if ( temp < zero ) then if ( slbd * temp > su ( i ) - xopt ( i )) then slbd = ( su ( i ) - xopt ( i )) / temp ilbd = i end if if ( subd * temp < sl ( i ) - xopt ( i )) then subd = max ( sumin , ( sl ( i ) - xopt ( i )) / temp ) iubd = - i end if end if end do ! !     Seek a large modulus of the KNEW-th Lagrange function when the index !     of the other interpolation point on the line through XOPT is KNEW. ! if ( k == knew ) then diff = dderiv - one step = slbd vlag = slbd * ( dderiv - slbd * diff ) isbd = ilbd temp = subd * ( dderiv - subd * diff ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if tempd = half * dderiv tempa = tempd - diff * slbd tempb = tempd - diff * subd if ( tempa * tempb < zero ) then temp = tempd * tempd / diff if ( abs ( temp ) > abs ( vlag )) then step = tempd / diff vlag = temp isbd = 0 end if end if ! !     Search along each of the other lines through XOPT and another point. ! else step = slbd vlag = slbd * ( one - slbd ) isbd = ilbd temp = subd * ( one - subd ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if if ( subd > half ) then if ( abs ( vlag ) < 0.25_wp ) then step = half vlag = 0.25_wp isbd = 0 end if end if vlag = vlag * dderiv end if ! !     Calculate PREDSQ for the current line search and maintain PRESAV. ! temp = step * ( one - step ) * distsq predsq = vlag * vlag * ( vlag * vlag + ha * temp * temp ) if ( predsq > presav ) then presav = predsq ksav = k stpsav = step ibdsav = isbd end if end do ! !     Construct XNEW in a way that satisfies the bound constraints exactly. ! do i = 1 , n temp = xopt ( i ) + stpsav * ( xpt ( ksav , i ) - xopt ( i )) xnew ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do if ( ibdsav < 0 ) xnew ( - ibdsav ) = sl ( - ibdsav ) if ( ibdsav > 0 ) xnew ( ibdsav ) = su ( ibdsav ) ! !     Prepare for the iterative method that assembles the constrained Cauchy !     step in W. The sum of squares of the fixed components of W is formed in !     WFIXSQ, and the free components of W are set to BIGSTP. ! bigstp = adelt + adelt iflag = 0 100 wfixsq = zero ggfree = zero do i = 1 , n w ( i ) = zero tempa = min ( xopt ( i ) - sl ( i ), glag ( i )) tempb = max ( xopt ( i ) - su ( i ), glag ( i )) if ( tempa > zero . or . tempb < zero ) then w ( i ) = bigstp ggfree = ggfree + glag ( i ) ** 2 end if end do if ( ggfree == zero ) then cauchy = zero return end if ! !     Investigate whether more components of W can be fixed. ! 120 temp = adelt * adelt - wfixsq if ( temp > zero ) then wsqsav = wfixsq step = sqrt ( temp / ggfree ) ggfree = zero do i = 1 , n if ( w ( i ) == bigstp ) then temp = xopt ( i ) - step * glag ( i ) if ( temp <= sl ( i )) then w ( i ) = sl ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else if ( temp >= su ( i )) then w ( i ) = su ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else ggfree = ggfree + glag ( i ) ** 2 end if end if end do if ( wfixsq > wsqsav . and . ggfree > zero ) go to 120 end if ! !     Set the remaining free components of W and all components of XALT, !     except that W may be scaled later. ! gw = zero do i = 1 , n if ( w ( i ) == bigstp ) then w ( i ) = - step * glag ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), xopt ( i ) + w ( i ))) else if ( w ( i ) == zero ) then xalt ( i ) = xopt ( i ) else if ( glag ( i ) > zero ) then xalt ( i ) = sl ( i ) else xalt ( i ) = su ( i ) end if gw = gw + glag ( i ) * w ( i ) end do ! !     Set CURV to the curvature of the KNEW-th Lagrange function along W. !     Scale W by a factor less than one if that can reduce the modulus of !     the Lagrange function at XOPT+W. Set CAUCHY to the final value of !     the square of this function. ! curv = zero do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * w ( j ) end do curv = curv + hcol ( k ) * temp * temp end do if ( iflag == 1 ) curv = - curv if ( curv >- gw . and . curv <- const * gw ) then scale = - gw / curv do i = 1 , n temp = xopt ( i ) + scale * w ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do cauchy = ( half * gw * scale ) ** 2 else cauchy = ( gw + half * curv ) ** 2 end if ! !     If IFLAG is zero, then XALT is calculated as before after reversing !     the sign of GLAG. Thus two XALT vectors become available. The one that !     is chosen is the one that gives the larger value of CAUCHY. ! if ( iflag == 0 ) then do i = 1 , n glag ( i ) = - glag ( i ) w ( n + i ) = xalt ( i ) end do csave = cauchy iflag = 1 go to 100 end if if ( csave > cauchy ) then do i = 1 , n xalt ( i ) = w ( n + i ) end do cauchy = csave end if end subroutine altmov subroutine prelim ( n , npt , x , xl , xu , rhobeg , iprint , maxfun , xbase , xpt , fval , gopt , & & hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), gopt ( * ), hq & & ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the !       same as the corresponding arguments in SUBROUTINE BOBYQA. !     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU !       are the same as the corresponding arguments in BOBYQB, the elements !       of SL and SU being set in BOBYQA. !     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but !       it is set by PRELIM to the gradient of the quadratic model at XBASE. !       If XOPT is nonzero, BOBYQB will change it to its usual value later. !     NF is maintaned as the number of calls of CALFUN so far. !     KOPT will be such that the least calculated value of F so far is at !       the point XPT(KOPT,.)+XBASE in the space of the variables. ! !     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, and it maintains the values of !     NF and KOPT. The vector X is also changed by PRELIM. ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp two = 2.0_wp zero = 0.0_wp rhosq = rhobeg * rhobeg recip = one / rhosq np = n + 1 ! !     Set XBASE to the initial vector of variables, and set the initial !     elements of XPT, BMAT, HQ, PQ and ZMAT to zero. ! do j = 1 , n xbase ( j ) = x ( j ) do k = 1 , npt xpt ( k , j ) = zero end do do i = 1 , ndim bmat ( i , j ) = zero end do end do do ih = 1 , ( n * np ) / 2 hq ( ih ) = zero end do do k = 1 , npt pq ( k ) = zero do j = 1 , npt - np zmat ( k , j ) = zero end do end do ! !     Begin the initialization procedure. NF becomes one more than the number !     of function values so far. The coordinates of the displacement of the !     next initial interpolation point from XBASE are set in XPT(NF+1,.). ! nf = 0 50 nfm = nf nfx = nf - n nf = nf + 1 if ( nfm <= 2 * n ) then if ( nfm >= 1 . and . nfm <= n ) then stepa = rhobeg if ( su ( nfm ) == zero ) stepa = - stepa xpt ( nf , nfm ) = stepa else if ( nfm > n ) then stepa = xpt ( nf - n , nfx ) stepb = - rhobeg if ( sl ( nfx ) == zero ) stepb = min ( two * rhobeg , su ( nfx )) if ( su ( nfx ) == zero ) stepb = max ( - two * rhobeg , sl ( nfx )) xpt ( nf , nfx ) = stepb end if else itemp = ( nfm - np ) / n jpt = nfm - itemp * n - n ipt = jpt + itemp if ( ipt > n ) then itemp = jpt jpt = ipt - n ipt = itemp end if xpt ( nf , ipt ) = xpt ( ipt + 1 , ipt ) xpt ( nf , jpt ) = xpt ( jpt + 1 , jpt ) end if ! !     Calculate the next value of F. The least function value so far and !     its index are required. ! do j = 1 , n x ( j ) = min ( max ( xl ( j ), xbase ( j ) + xpt ( nf , j )), xu ( j )) if ( xpt ( nf , j ) == sl ( j )) x ( j ) = xl ( j ) if ( xpt ( nf , j ) == su ( j )) x ( j ) = xu ( j ) end do call calfun ( n , x ( 1 : n ), f ) if ( iprint == 3 ) then print 70 , nf , f , ( x ( i ), i = 1 , n ) 70 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( nf ) = f if ( nf == 1 ) then fbeg = f kopt = 1 else if ( f < fval ( kopt )) then kopt = nf end if ! !     Set the nonzero initial elements of BMAT and the quadratic model in the !     cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions !     of the NF-th and (NF-N)-th interpolation points may be switched, in !     order that the function value at the first of them contributes to the !     off-diagonal second derivative terms of the initial quadratic model. ! if ( nf <= 2 * n + 1 ) then if ( nf >= 2 . and . nf <= n + 1 ) then gopt ( nfm ) = ( f - fbeg ) / stepa if ( npt < nf + n ) then bmat ( 1 , nfm ) = - one / stepa bmat ( nf , nfm ) = one / stepa bmat ( npt + nfm , nfm ) = - half * rhosq end if else if ( nf >= n + 2 ) then ih = ( nfx * ( nfx + 1 )) / 2 temp = ( f - fbeg ) / stepb diff = stepb - stepa hq ( ih ) = two * ( temp - gopt ( nfx )) / diff gopt ( nfx ) = ( gopt ( nfx ) * stepb - temp * stepa ) / diff if ( stepa * stepb < zero ) then if ( f < fval ( nf - n )) then fval ( nf ) = fval ( nf - n ) fval ( nf - n ) = f if ( kopt == nf ) kopt = nf - n xpt ( nf - n , nfx ) = stepb xpt ( nf , nfx ) = stepa end if end if bmat ( 1 , nfx ) = - ( stepa + stepb ) / ( stepa * stepb ) bmat ( nf , nfx ) = - half / xpt ( nf - n , nfx ) bmat ( nf - n , nfx ) = - bmat ( 1 , nfx ) - bmat ( nf , nfx ) zmat ( 1 , nfx ) = sqrt ( two ) / ( stepa * stepb ) zmat ( nf , nfx ) = sqrt ( half ) / rhosq zmat ( nf - n , nfx ) = - zmat ( 1 , nfx ) - zmat ( nf , nfx ) end if ! !     Set the off-diagonal second derivatives of the Lagrange functions and !     the initial quadratic model. ! else ih = ( ipt * ( ipt - 1 )) / 2 + jpt zmat ( 1 , nfx ) = recip zmat ( nf , nfx ) = recip zmat ( ipt + 1 , nfx ) = - recip zmat ( jpt + 1 , nfx ) = - recip temp = xpt ( nf , ipt ) * xpt ( nf , jpt ) hq ( ih ) = ( fbeg - fval ( ipt + 1 ) - fval ( jpt + 1 ) + f ) / temp end if if ( nf < npt . and . nf < maxfun ) go to 50 end subroutine prelim subroutine rescue ( n , npt , xl , xu , iprint , maxfun , xbase , xpt , fval , xopt , gopt , hq , & & pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , ptsaux , ptsid , w , calfun ) implicit real ( wp ) ( a - h , o - z ) dimension xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), gopt ( * ), & & hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), vlag ( * ), ptsaux & & ( 2 , * ), ptsid ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, XL, XU, IPRINT, MAXFUN, XBASE, XPT, FVAL, XOPT, !       GOPT, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU have the same meanings as !       the corresponding arguments of BOBYQB on the entry to RESCUE. !     NF is maintained as the number of calls of CALFUN so far, except that !       NF is set to -1 if the value of MAXFUN prevents further progress. !     KOPT is maintained so that FVAL(KOPT) is the least calculated function !       value. Its correct value must be given on entry. It is updated if a !       new least function value is found, but the corresponding changes to !       XOPT and GOPT have to be made later by the calling program. !     DELTA is the current trust region radius. !     VLAG is a working space vector that will be used for the values of the !       provisional Lagrange functions at each of the interpolation points. !       They are part of a product that requires VLAG to be of length NDIM. !     PTSAUX is also a working space array. For J=1,2,...,N, PTSAUX(1,J) and !       PTSAUX(2,J) specify the two positions of provisional interpolation !       points when a nonzero step is taken along e_J (the J-th coordinate !       direction) through XBASE+XOPT, as specified below. Usually these !       steps have length DELTA, but other lengths are chosen if necessary !       in order to satisfy the given bounds on the variables. !     PTSID is also a working space array. It has NPT components that denote !       provisional new positions of the original interpolation points, in !       case changes are needed to restore the linear independence of the !       interpolation conditions. The K-th point is a candidate for change !       if and only if PTSID(K) is nonzero. In this case let p and q be the !       integer parts of PTSID(K) and (PTSID(K)-p) multiplied by N+1. If p !       and q are both positive, the step from XBASE+XOPT to the new K-th !       interpolation point is PTSAUX(1,p)*e_p + PTSAUX(1,q)*e_q. Otherwise !       the step is PTSAUX(1,p)*e_p or PTSAUX(2,q)*e_q in the cases q=0 or !       p=0, respectively. !     The first NDIM+NPT elements of the array W are used for working space. !     The final elements of BMAT and ZMAT are set in a well-conditioned way !       to the values that are appropriate for the new interpolation points. !     The elements of GOPT, HQ and PQ are also revised to the values that are !       appropriate to the final quadratic model. ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp zero = 0.0_wp np = n + 1 sfrac = half / real ( np , wp ) nptm = npt - np ! !     Shift the interpolation points so that XOPT becomes the origin, and set !     the elements of ZMAT to zero. The value of SUMPQ is required in the !     updating of HQ below. The squares of the distances from XOPT to the !     other interpolation points are set at the end of W. Increments of WINC !     may be added later to these squares to balance the consideration of !     the choice of point that is going to become current. ! sumpq = zero winc = zero do k = 1 , npt distsq = zero do j = 1 , n xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) distsq = distsq + xpt ( k , j ) ** 2 end do sumpq = sumpq + pq ( k ) w ( ndim + k ) = distsq winc = max ( winc , distsq ) do j = 1 , nptm zmat ( k , j ) = zero end do end do ! !     Update HQ so that HQ and PQ define the second derivatives of the model !     after XBASE has been shifted to the trust region centre. ! ih = 0 do j = 1 , n w ( j ) = half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + w ( j ) * xopt ( i ) end do end do ! !     Shift XBASE, SL, SU and XOPT. Set the elements of BMAT to zero, and !     also set the elements of PTSAUX. ! do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) sl ( j ) = sl ( j ) - xopt ( j ) su ( j ) = su ( j ) - xopt ( j ) xopt ( j ) = zero ptsaux ( 1 , j ) = min ( delta , su ( j )) ptsaux ( 2 , j ) = max ( - delta , sl ( j )) if ( ptsaux ( 1 , j ) + ptsaux ( 2 , j ) < zero ) then temp = ptsaux ( 1 , j ) ptsaux ( 1 , j ) = ptsaux ( 2 , j ) ptsaux ( 2 , j ) = temp end if if ( abs ( ptsaux ( 2 , j )) < half * abs ( ptsaux ( 1 , j ))) then ptsaux ( 2 , j ) = half * ptsaux ( 1 , j ) end if do i = 1 , ndim bmat ( i , j ) = zero end do end do fbase = fval ( kopt ) ! !     Set the identifiers of the artificial interpolation points that are !     along a coordinate direction from XOPT, and set the corresponding !     nonzero elements of BMAT and ZMAT. ! ptsid ( 1 ) = sfrac do j = 1 , n jp = j + 1 jpn = jp + n ptsid ( jp ) = real ( j , wp ) + sfrac if ( jpn <= npt ) then ptsid ( jpn ) = real ( j , wp ) / real ( np , wp ) + sfrac temp = one / ( ptsaux ( 1 , j ) - ptsaux ( 2 , j )) bmat ( jp , j ) = - temp + one / ptsaux ( 1 , j ) bmat ( jpn , j ) = temp + one / ptsaux ( 2 , j ) bmat ( 1 , j ) = - bmat ( jp , j ) - bmat ( jpn , j ) zmat ( 1 , j ) = sqrt ( 2.0_wp ) / abs ( ptsaux ( 1 , j ) * ptsaux ( 2 , j )) zmat ( jp , j ) = zmat ( 1 , j ) * ptsaux ( 2 , j ) * temp zmat ( jpn , j ) = - zmat ( 1 , j ) * ptsaux ( 1 , j ) * temp else bmat ( 1 , j ) = - one / ptsaux ( 1 , j ) bmat ( jp , j ) = one / ptsaux ( 1 , j ) bmat ( j + npt , j ) = - half * ptsaux ( 1 , j ) ** 2 end if end do ! !     Set any remaining identifiers with their nonzero elements of ZMAT. ! if ( npt >= n + np ) then do k = 2 * np , npt iw = ( real ( k - np , wp ) - half ) / real ( n , wp ) ip = k - np - iw * n iq = ip + iw if ( iq > n ) iq = iq - n ptsid ( k ) = real ( ip , wp ) + real ( iq , wp ) / real ( np , wp ) + sfrac temp = one / ( ptsaux ( 1 , ip ) * ptsaux ( 1 , iq )) zmat ( 1 , k - np ) = temp zmat ( ip + 1 , k - np ) = - temp zmat ( iq + 1 , k - np ) = - temp zmat ( k , k - np ) = temp end do end if nrem = npt kold = 1 knew = kopt ! !     Reorder the provisional points in the way that exchanges PTSID(KOLD) !     with PTSID(KNEW). ! 80 do j = 1 , n temp = bmat ( kold , j ) bmat ( kold , j ) = bmat ( knew , j ) bmat ( knew , j ) = temp end do do j = 1 , nptm temp = zmat ( kold , j ) zmat ( kold , j ) = zmat ( knew , j ) zmat ( knew , j ) = temp end do ptsid ( kold ) = ptsid ( knew ) ptsid ( knew ) = zero w ( ndim + knew ) = zero nrem = nrem - 1 if ( knew /= kopt ) then temp = vlag ( kold ) vlag ( kold ) = vlag ( knew ) vlag ( knew ) = temp ! !     Update the BMAT and ZMAT matrices so that the status of the KNEW-th !     interpolation point can be changed from provisional to original. The !     subroutine returns if all the original points are reinstated. !     The nonnegative values of W(NDIM+K) are required in the search below. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) if ( nrem == 0 ) return do k = 1 , npt w ( ndim + k ) = abs ( w ( ndim + k )) end do end if ! !     Pick the index KNEW of an original interpolation point that has not !     yet replaced one of the provisional interpolation points, giving !     attention to the closeness to XOPT and to previous tries with KNEW. ! 120 dsqmin = zero do k = 1 , npt if ( w ( ndim + k ) > zero ) then if ( dsqmin == zero . or . w ( ndim + k ) < dsqmin ) then knew = k dsqmin = w ( ndim + k ) end if end if end do if ( dsqmin == zero ) go to 260 ! !     Form the W-vector of the chosen original interpolation point. ! do j = 1 , n w ( npt + j ) = xpt ( knew , j ) end do do k = 1 , npt sum = zero if ( k == kopt ) then continue else if ( ptsid ( k ) == zero ) then do j = 1 , n sum = sum + w ( npt + j ) * xpt ( k , j ) end do else ip = ptsid ( k ) if ( ip > 0 ) sum = w ( npt + ip ) * ptsaux ( 1 , ip ) iq = real ( np , wp ) * ptsid ( k ) - real ( ip * np , wp ) if ( iq > 0 ) then iw = 1 if ( ip == 0 ) iw = 2 sum = sum + w ( npt + iq ) * ptsaux ( iw , iq ) end if end if w ( k ) = half * sum * sum end do ! !     Calculate VLAG and BETA for the required updating of the H matrix if !     XPT(KNEW,.) is reinstated in the set of interpolation points. ! do k = 1 , npt sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * w ( npt + j ) end do vlag ( k ) = sum end do beta = zero do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , j ) end do end do bsum = zero distsq = zero do j = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , j ) * w ( k ) end do jp = j + npt bsum = bsum + sum * w ( jp ) do ip = npt + 1 , ndim sum = sum + bmat ( ip , j ) * w ( ip ) end do bsum = bsum + sum * w ( jp ) vlag ( jp ) = sum distsq = distsq + xpt ( knew , j ) ** 2 end do beta = half * distsq * distsq + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     KOLD is set to the index of the provisional interpolation point that is !     going to be deleted to make way for the KNEW-th original interpolation !     point. The choice of KOLD is governed by the avoidance of a small value !     of the denominator in the updating calculation of UPDATE. ! denom = zero vlmxsq = zero do k = 1 , npt if ( ptsid ( k ) /= zero ) then hdiag = zero do j = 1 , nptm hdiag = hdiag + zmat ( k , j ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 if ( den > denom ) then kold = k denom = den end if end if vlmxsq = max ( vlmxsq , vlag ( k ) ** 2 ) end do if ( denom <= 1.0e-2_wp * vlmxsq ) then w ( ndim + knew ) = - w ( ndim + knew ) - winc go to 120 end if go to 80 ! !     When label 260 is reached, all the final positions of the interpolation !     points have been chosen although any changes have not been included yet !     in XPT. Also the final BMAT and ZMAT matrices are complete, but, apart !     from the shift of XBASE, the updating of the quadratic model remains to !     be done. The following cycle through the new interpolation points begins !     by putting the new point in XPT(KPT,.) and by setting PQ(KPT) to zero, !     except that a RETURN occurs if MAXFUN prohibits another value of F. ! 260 do kpt = 1 , npt if ( ptsid ( kpt ) == zero ) cycle if ( nf >= maxfun ) then nf = - 1 return end if ih = 0 do j = 1 , n w ( j ) = xpt ( kpt , j ) xpt ( kpt , j ) = zero temp = pq ( kpt ) * w ( j ) do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * w ( i ) end do end do pq ( kpt ) = zero ip = ptsid ( kpt ) iq = real ( np , wp ) * ptsid ( kpt ) - real ( ip * np , wp ) if ( ip > 0 ) then xp = ptsaux ( 1 , ip ) xpt ( kpt , ip ) = xp end if if ( iq > 0 ) then xq = ptsaux ( 1 , iq ) if ( ip == 0 ) xq = ptsaux ( 2 , iq ) xpt ( kpt , iq ) = xq end if ! !     Set VQUAD to the value of the current model at the new point. ! vquad = fbase if ( ip > 0 ) then ihp = ( ip + ip * ip ) / 2 vquad = vquad + xp * ( gopt ( ip ) + half * xp * hq ( ihp )) end if if ( iq > 0 ) then ihq = ( iq + iq * iq ) / 2 vquad = vquad + xq * ( gopt ( iq ) + half * xq * hq ( ihq )) if ( ip > 0 ) then iw = max ( ihp , ihq ) - abs ( ip - iq ) vquad = vquad + xp * xq * hq ( iw ) end if end if do k = 1 , npt temp = zero if ( ip > 0 ) temp = temp + xp * xpt ( k , ip ) if ( iq > 0 ) temp = temp + xq * xpt ( k , iq ) vquad = vquad + half * pq ( k ) * temp * temp end do ! !     Calculate F at the new interpolation point, and set DIFF to the factor !     that is going to multiply the KPT-th Lagrange function when the model !     is updated to provide interpolation to the new function value. ! do i = 1 , n w ( i ) = min ( max ( xl ( i ), xbase ( i ) + xpt ( kpt , i )), xu ( i )) if ( xpt ( kpt , i ) == sl ( i )) w ( i ) = xl ( i ) if ( xpt ( kpt , i ) == su ( i )) w ( i ) = xu ( i ) end do nf = nf + 1 call calfun ( n , w ( 1 : n ), f ) if ( iprint == 3 ) then print 300 , nf , f , ( w ( i ), i = 1 , n ) 300 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( kpt ) = f if ( f < fval ( kopt )) kopt = kpt diff = f - vquad ! !     Update the quadratic model. The RETURN from the subroutine occurs when !     all the new interpolation points are included in the model. ! do i = 1 , n gopt ( i ) = gopt ( i ) + diff * bmat ( kpt , i ) end do do k = 1 , npt sum = zero do j = 1 , nptm sum = sum + zmat ( k , j ) * zmat ( kpt , j ) end do temp = diff * sum if ( ptsid ( k ) == zero ) then pq ( k ) = pq ( k ) + temp else ip = ptsid ( k ) iq = real ( np , wp ) * ptsid ( k ) - real ( ip * np , wp ) ihq = ( iq * iq + iq ) / 2 if ( ip == 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 2 , iq ) ** 2 else ihp = ( ip * ip + ip ) / 2 hq ( ihp ) = hq ( ihp ) + temp * ptsaux ( 1 , ip ) ** 2 if ( iq > 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 1 , iq ) ** 2 iw = max ( ihp , ihq ) - abs ( iq - ip ) hq ( iw ) = hq ( iw ) + temp * ptsaux ( 1 , ip ) * ptsaux ( 1 , iq ) end if end if end if end do ptsid ( kpt ) = zero end do end subroutine rescue subroutine trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , gnew , & & xbdi , s , hs , hred , dsq , crvmin ) implicit real ( wp ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), gopt ( * ), hq ( * ), pq ( * ), sl ( * ), su ( * ), xnew & & ( * ), d ( * ), gnew ( * ), xbdi ( * ), s ( * ), hs ( * ), hred ( * ) ! !     The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same !       meanings as the corresponding arguments of BOBYQB. !     DELTA is the trust region radius for the present calculation, which !       seeks a small value of the quadratic model within distance DELTA of !       XOPT subject to the bounds on the variables. !     XNEW will be set to a new vector of variables that is approximately !       the one that minimizes the quadratic model within the trust region !       subject to the SL and SU constraints on the variables. It satisfies !       as equations the bounds that become active during the calculation. !     D is the calculated trial step from XOPT, generated iteratively from an !       initial value of zero. Thus XNEW is XOPT+D after the final iteration. !     GNEW holds the gradient of the quadratic model at XOPT+D. It is updated !       when D is updated. !     XBDI is a working space vector. For I=1,2,...,N, the element XBDI(I) is !       set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the !       I-th variable has become fixed at a bound, the bound being SL(I) or !       SU(I) in the case XBDI(I)=-1.0 or XBDI(I)=1.0, respectively. This !       information is accumulated during the construction of XNEW. !     The arrays S, HS and HRED are also used for working space. They hold the !       current search direction, and the changes in the gradient of Q along S !       and the reduced D, respectively, where the reduced D is the same as D, !       except that the components of the fixed variables are zero. !     DSQ will be set to the square of the length of XNEW-XOPT. !     CRVMIN is set to zero if D reaches the trust region boundary. Otherwise !       it is set to the least curvature of H that occurs in the conjugate !       gradient searches that are not restricted by any constraints. The !       value CRVMIN=-1.0D0 is set, however, if all of these searches are !       constrained. ! !     A version of the truncated conjugate gradient is applied. If a line !     search is restricted by a constraint, then the procedure is restarted, !     the values of the variables that are at their bounds being fixed. If !     the trust region boundary is reached, then further changes may be made !     to D, each one being in the two dimensional space that is spanned !     by the current D and the gradient of Q at XOPT+D, staying on the trust !     region boundary. Termination occurs when the reduction in Q seems to !     be close to the greatest reduction that can be achieved. ! !     Set some constants. ! half = 0.5_wp one = 1.0_wp onemin = - 1.0_wp zero = 0.0_wp ! !     The sign of GOPT(I) gives the sign of the change to the I-th variable !     that will reduce Q from its value at XOPT. Thus XBDI(I) shows whether !     or not to fix the I-th variable at one of its bounds initially, with !     NACT being set to the number of fixed variables. D and GNEW are also !     set for the first iteration. DELSQ is the upper bound on the sum of !     squares of the free variables. QRED is the reduction in Q so far. ! iterc = 0 nact = 0 sqstp = zero do i = 1 , n xbdi ( i ) = zero if ( xopt ( i ) <= sl ( i )) then if ( gopt ( i ) >= zero ) xbdi ( i ) = onemin else if ( xopt ( i ) >= su ( i )) then if ( gopt ( i ) <= zero ) xbdi ( i ) = one end if if ( xbdi ( i ) /= zero ) nact = nact + 1 d ( i ) = zero gnew ( i ) = gopt ( i ) end do delsq = delta * delta qred = zero crvmin = onemin ! !     Set the next search direction of the conjugate gradient method. It is !     the steepest descent direction initially and when the iterations are !     restarted because a variable has just been fixed by a bound, and of !     course the components of the fixed variables are zero. ITERMAX is an !     upper bound on the indices of the conjugate gradient iterations. ! 20 beta = zero 30 stepsq = zero do i = 1 , n if ( xbdi ( i ) /= zero ) then s ( i ) = zero else if ( beta == zero ) then s ( i ) = - gnew ( i ) else s ( i ) = beta * s ( i ) - gnew ( i ) end if stepsq = stepsq + s ( i ) ** 2 end do if ( stepsq == zero ) go to 190 if ( beta == zero ) then gredsq = stepsq itermax = iterc + n - nact end if if ( gredsq * delsq <= 1.0e-4_wp * qred * qred ) go to 190 ! !     Multiply the search direction by the second derivative matrix of Q and !     calculate some scalars for the choice of steplength. Then set BLEN to !     the length of the the step to the trust region boundary and STPLEN to !     the steplength, ignoring the simple bounds. ! go to 210 50 resid = delsq ds = zero shs = zero do i = 1 , n if ( xbdi ( i ) == zero ) then resid = resid - d ( i ) ** 2 ds = ds + s ( i ) * d ( i ) shs = shs + s ( i ) * hs ( i ) end if end do if ( resid <= zero ) go to 90 temp = sqrt ( stepsq * resid + ds * ds ) if ( ds < zero ) then blen = ( temp - ds ) / stepsq else blen = resid / ( temp + ds ) end if stplen = blen if ( shs > zero ) then stplen = min ( blen , gredsq / shs ) end if ! ! !     Reduce STPLEN if necessary in order to preserve the simple bounds, !     letting IACT be the index of the new constrained variable. ! iact = 0 do i = 1 , n if ( s ( i ) /= zero ) then xsum = xopt ( i ) + d ( i ) if ( s ( i ) > zero ) then temp = ( su ( i ) - xsum ) / s ( i ) else temp = ( sl ( i ) - xsum ) / s ( i ) end if if ( temp < stplen ) then stplen = temp iact = i end if end if end do ! !     Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q. ! sdec = zero if ( stplen > zero ) then iterc = iterc + 1 temp = shs / stepsq if ( iact == 0 . and . temp > zero ) then crvmin = min ( crvmin , temp ) if ( crvmin == onemin ) crvmin = temp end if ggsav = gredsq gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + stplen * hs ( i ) if ( xbdi ( i ) == zero ) gredsq = gredsq + gnew ( i ) ** 2 d ( i ) = d ( i ) + stplen * s ( i ) end do sdec = max ( stplen * ( ggsav - half * stplen * shs ), zero ) qred = qred + sdec end if ! !     Restart the conjugate gradient method if it has hit a new bound. ! if ( iact > 0 ) then nact = nact + 1 xbdi ( iact ) = one if ( s ( iact ) < zero ) xbdi ( iact ) = onemin delsq = delsq - d ( iact ) ** 2 if ( delsq <= zero ) go to 90 go to 20 end if ! !     If STPLEN is less than BLEN, then either apply another conjugate !     gradient iteration or RETURN. ! if ( stplen < blen ) then if ( iterc == itermax ) go to 190 if ( sdec <= 0.01_wp * qred ) go to 190 beta = gredsq / ggsav go to 30 end if 90 crvmin = zero ! !     Prepare for the alternative iteration by calculating some scalars and !     by multiplying the reduced D by the second derivative matrix of Q. ! 100 if ( nact >= n - 1 ) go to 190 dredsq = zero dredg = zero gredsq = zero do i = 1 , n if ( xbdi ( i ) == zero ) then dredsq = dredsq + d ( i ) ** 2 dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 s ( i ) = d ( i ) else s ( i ) = zero end if end do itcsav = iterc go to 210 ! !     Let the search direction S be a linear combination of the reduced D !     and the reduced G that is orthogonal to the reduced D. ! 120 iterc = iterc + 1 temp = gredsq * dredsq - dredg * dredg if ( temp <= 1.0e-4_wp * qred * qred ) go to 190 temp = sqrt ( temp ) do i = 1 , n if ( xbdi ( i ) == zero ) then s ( i ) = ( dredg * d ( i ) - dredsq * gnew ( i )) / temp else s ( i ) = zero end if end do sredg = - temp ! !     By considering the simple bounds on the variables, calculate an upper !     bound on the tangent of half the angle of the alternative iteration, !     namely ANGBD, except that, if already a free variable has reached a !     bound, there is a branch back to label 100 after fixing that variable. ! angbd = one iact = 0 do i = 1 , n if ( xbdi ( i ) == zero ) then tempa = xopt ( i ) + d ( i ) - sl ( i ) tempb = su ( i ) - xopt ( i ) - d ( i ) if ( tempa <= zero ) then nact = nact + 1 xbdi ( i ) = onemin go to 100 else if ( tempb <= zero ) then nact = nact + 1 xbdi ( i ) = one go to 100 end if ratio = one ssq = d ( i ) ** 2 + s ( i ) ** 2 temp = ssq - ( xopt ( i ) - sl ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) - s ( i ) if ( angbd * temp > tempa ) then angbd = tempa / temp iact = i xsav = onemin end if end if temp = ssq - ( su ( i ) - xopt ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) + s ( i ) if ( angbd * temp > tempb ) then angbd = tempb / temp iact = i xsav = one end if end if end if end do ! !     Calculate HHD and some curvatures for the alternative iteration. ! go to 210 150 shs = zero dhs = zero dhd = zero do i = 1 , n if ( xbdi ( i ) == zero ) then shs = shs + s ( i ) * hs ( i ) dhs = dhs + d ( i ) * hs ( i ) dhd = dhd + d ( i ) * hred ( i ) end if end do ! !     Seek the greatest reduction in Q for a range of equally spaced values !     of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of !     the alternative iteration. ! redmax = zero isav = 0 redsav = zero iu = 1 7.0_wp * angbd + 3.1_wp do i = 1 , iu angt = angbd * real ( i , wp ) / real ( iu , wp ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) rednew = sth * ( angt * dredg - sredg - half * sth * temp ) if ( rednew > redmax ) then redmax = rednew isav = i rdprev = redsav else if ( i == isav + 1 ) then rdnext = rednew end if redsav = rednew end do ! !     Return if the reduction is zero. Otherwise, set the sine and cosine !     of the angle of the alternative iteration, and calculate SDEC. ! if ( isav == 0 ) go to 190 if ( isav < iu ) then temp = ( rdnext - rdprev ) / ( redmax + redmax - rdprev - rdnext ) angt = angbd * ( real ( isav , wp ) + half * temp ) / real ( iu , wp ) end if cth = ( one - angt * angt ) / ( one + angt * angt ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) sdec = sth * ( angt * dredg - sredg - half * sth * temp ) if ( sdec <= zero ) go to 190 ! !     Update GNEW, D and HRED. If the angle of the alternative iteration !     is restricted by a bound on a free variable, that variable is fixed !     at the bound. ! dredg = zero gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + ( cth - one ) * hred ( i ) + sth * hs ( i ) if ( xbdi ( i ) == zero ) then d ( i ) = cth * d ( i ) + sth * s ( i ) dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 end if hred ( i ) = cth * hred ( i ) + sth * hs ( i ) end do qred = qred + sdec if ( iact > 0 . and . isav == iu ) then nact = nact + 1 xbdi ( iact ) = xsav go to 100 end if ! !     If SDEC is sufficiently small, then RETURN after setting XNEW to !     XOPT+D, giving careful attention to the bounds. ! if ( sdec > 0.01_wp * qred ) go to 120 190 dsq = zero do i = 1 , n xnew ( i ) = max ( min ( xopt ( i ) + d ( i ), su ( i )), sl ( i )) if ( xbdi ( i ) == onemin ) xnew ( i ) = sl ( i ) if ( xbdi ( i ) == one ) xnew ( i ) = su ( i ) d ( i ) = xnew ( i ) - xopt ( i ) dsq = dsq + d ( i ) ** 2 end do return ! !     The following instructions multiply the current S-vector by the second !     derivative matrix of the quadratic model, putting the product in HS. !     They are reached from three different parts of the software above and !     they can be regarded as an external subroutine. ! 210 ih = 0 do j = 1 , n hs ( j ) = zero do i = 1 , j ih = ih + 1 if ( i < j ) hs ( j ) = hs ( j ) + hq ( ih ) * s ( i ) hs ( i ) = hs ( i ) + hq ( ih ) * s ( j ) end do end do do k = 1 , npt if ( pq ( k ) /= zero ) then temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * s ( j ) end do temp = temp * pq ( k ) do i = 1 , n hs ( i ) = hs ( i ) + temp * xpt ( k , i ) end do end if end do if ( crvmin /= zero ) go to 50 if ( iterc > itcsav ) go to 150 do i = 1 , n hred ( i ) = hs ( i ) end do go to 120 end subroutine trsbox subroutine update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) implicit real ( wp ) ( a - h , o - z ) dimension bmat ( ndim , * ), zmat ( npt , * ), vlag ( * ), w ( * ) ! !     The arrays BMAT and ZMAT are updated, as required by the new position !     of the interpolation point that has the index KNEW. The vector VLAG has !     N+NPT components, set on entry to the first NPT and last N components !     of the product Hw in equation (4.11) of the Powell (2006) paper on !     NEWUOA. Further, BETA is set on entry to the value of the parameter !     with that name, and DENOM is set to the denominator of the updating !     formula. Elements of ZMAT may be treated as zero if their moduli are !     at most ZTEST. The first NDIM elements of W are used for working space. ! !     Set some constants. ! one = 1.0_wp zero = 0.0_wp nptm = npt - n - 1 ztest = zero do k = 1 , npt do j = 1 , nptm ztest = max ( ztest , abs ( zmat ( k , j ))) end do end do ztest = 1.0e-20_wp * ztest ! !     Apply the rotations that put zeros in the KNEW-th row of ZMAT. ! jl = 1 do j = 2 , nptm if ( abs ( zmat ( knew , j )) > ztest ) then temp = sqrt ( zmat ( knew , 1 ) ** 2 + zmat ( knew , j ) ** 2 ) tempa = zmat ( knew , 1 ) / temp tempb = zmat ( knew , j ) / temp do i = 1 , npt temp = tempa * zmat ( i , 1 ) + tempb * zmat ( i , j ) zmat ( i , j ) = tempa * zmat ( i , j ) - tempb * zmat ( i , 1 ) zmat ( i , 1 ) = temp end do end if zmat ( knew , j ) = zero end do ! !     Put the first NPT components of the KNEW-th column of HLAG into W, !     and calculate the parameters of the updating formula. ! do i = 1 , npt w ( i ) = zmat ( knew , 1 ) * zmat ( i , 1 ) end do alpha = w ( knew ) tau = vlag ( knew ) vlag ( knew ) = vlag ( knew ) - one ! !     Complete the updating of ZMAT. ! temp = sqrt ( denom ) tempb = zmat ( knew , 1 ) / temp tempa = tau / temp do i = 1 , npt zmat ( i , 1 ) = tempa * zmat ( i , 1 ) - tempb * vlag ( i ) end do ! !     Finally, update the matrix BMAT. ! do j = 1 , n jp = npt + j w ( jp ) = bmat ( knew , j ) tempa = ( alpha * vlag ( jp ) - tau * w ( jp )) / denom tempb = ( - beta * w ( jp ) - tau * vlag ( jp )) / denom do i = 1 , jp bmat ( i , j ) = bmat ( i , j ) + tempa * vlag ( i ) + tempb * w ( i ) if ( i > npt ) bmat ( jp , i - npt ) = bmat ( i , j ) end do end do end subroutine update !***************************************************************************************** !> !  Test problem for [[bobyqa]], the objective function being the sum of !  the reciprocals of all pairwise distances between the points P_I, !  I=1,2,...,M in two dimensions, where M=N/2 and where the components !  of P_I are X(2*I-1) and X(2*I). Thus each vector X of N variables !  defines the M points P_I. The initial X gives equally spaced points !  on a circle. Four different choices of the pairs (N,NPT) are tried, !  namely (10,16), (10,21), (20,26) and (20,41). Convergence to a local !  minimum that is not global occurs in both the N=10 cases. The details !  of the results are highly sensitive to computer rounding errors. The !  choice IPRINT=2 provides the current X and optimal F so far whenever !  RHO is reduced. The bound constraints of the problem require every !  component of X to be in the interval [-1,1]. subroutine bobyqa_test () implicit none real ( wp ), dimension ( 100 ) :: x , xl , xu integer :: i , j , m , n , jcase , npt real ( wp ) :: temp real ( wp ), parameter :: twopi = 8.0_wp * atan ( 1.0_wp ) real ( wp ), parameter :: bdl = - 1.0_wp real ( wp ), parameter :: bdu = 1.0_wp integer , parameter :: iprint = 2 integer , parameter :: maxfun = 500000 real ( wp ), parameter :: rhobeg = 1.0e-1_wp real ( wp ), parameter :: rhoend = 1.0e-6_wp m = 5 do n = 2 * m do i = 1 , n xl ( i ) = bdl xu ( i ) = bdu end do do jcase = 1 , 2 npt = n + 6 if ( jcase == 2 ) npt = 2 * n + 1 print 30 , m , n , npt 30 format ( / / 5 x , '2D output with M =' , i4 , ',  N =' , i4 , '  and  NPT =' , i4 ) do j = 1 , m temp = real ( j , wp ) * twopi / real ( m , wp ) x ( 2 * j - 1 ) = cos ( temp ) x ( 2 * j ) = sin ( temp ) end do call bobyqa ( n , npt , x , xl , xu , rhobeg , rhoend , iprint , maxfun , calfun ) end do m = m + m if ( m > 10 ) exit end do contains subroutine calfun ( n , x , f ) implicit none integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( out ) :: f integer :: i , j real ( wp ) :: temp f = 0.0_wp do i = 4 , n , 2 do j = 2 , i - 2 , 2 temp = ( x ( i - 1 ) - x ( j - 1 )) ** 2 + ( x ( i ) - x ( j )) ** 2 temp = max ( temp , 1.0e-6_wp ) f = f + 1.0_wp / sqrt ( temp ) end do end do end subroutine calfun end subroutine bobyqa_test !***************************************************************************************** !***************************************************************************************** end module bobyqa_module !*****************************************************************************************","tags":"","loc":"sourcefile/bobyqa.f90.html"}]}